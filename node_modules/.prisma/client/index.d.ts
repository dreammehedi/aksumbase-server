
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model RolePackage
 * 
 */
export type RolePackage = $Result.DefaultSelection<Prisma.$RolePackagePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model HeroBanner
 * 
 */
export type HeroBanner = $Result.DefaultSelection<Prisma.$HeroBannerPayload>
/**
 * Model MarketTrends
 * 
 */
export type MarketTrends = $Result.DefaultSelection<Prisma.$MarketTrendsPayload>
/**
 * Model MortageTools
 * 
 */
export type MortageTools = $Result.DefaultSelection<Prisma.$MortageToolsPayload>
/**
 * Model PrivacyPolicy
 * 
 */
export type PrivacyPolicy = $Result.DefaultSelection<Prisma.$PrivacyPolicyPayload>
/**
 * Model TermsOfUse
 * 
 */
export type TermsOfUse = $Result.DefaultSelection<Prisma.$TermsOfUsePayload>
/**
 * Model BuyingGuides
 * 
 */
export type BuyingGuides = $Result.DefaultSelection<Prisma.$BuyingGuidesPayload>
/**
 * Model SellingTips
 * 
 */
export type SellingTips = $Result.DefaultSelection<Prisma.$SellingTipsPayload>
/**
 * Model MarketInsights
 * 
 */
export type MarketInsights = $Result.DefaultSelection<Prisma.$MarketInsightsPayload>
/**
 * Model MarketAnalysis
 * 
 */
export type MarketAnalysis = $Result.DefaultSelection<Prisma.$MarketAnalysisPayload>
/**
 * Model Press
 * 
 */
export type Press = $Result.DefaultSelection<Prisma.$PressPayload>
/**
 * Model Blog
 * 
 */
export type Blog = $Result.DefaultSelection<Prisma.$BlogPayload>
/**
 * Model EmailConfiguration
 * 
 */
export type EmailConfiguration = $Result.DefaultSelection<Prisma.$EmailConfigurationPayload>
/**
 * Model StripeConfiguration
 * 
 */
export type StripeConfiguration = $Result.DefaultSelection<Prisma.$StripeConfigurationPayload>
/**
 * Model SellPageBanner
 * 
 */
export type SellPageBanner = $Result.DefaultSelection<Prisma.$SellPageBannerPayload>
/**
 * Model SellTypes
 * 
 */
export type SellTypes = $Result.DefaultSelection<Prisma.$SellTypesPayload>
/**
 * Model SellerResources
 * 
 */
export type SellerResources = $Result.DefaultSelection<Prisma.$SellerResourcesPayload>
/**
 * Model DevelopmentPlatform
 * 
 */
export type DevelopmentPlatform = $Result.DefaultSelection<Prisma.$DevelopmentPlatformPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Bookmark
 * 
 */
export type Bookmark = $Result.DefaultSelection<Prisma.$BookmarkPayload>
/**
 * Model PropertyView
 * 
 */
export type PropertyView = $Result.DefaultSelection<Prisma.$PropertyViewPayload>
/**
 * Model PropertyTourRequest
 * 
 */
export type PropertyTourRequest = $Result.DefaultSelection<Prisma.$PropertyTourRequestPayload>
/**
 * Model PropertyContactUserRequest
 * 
 */
export type PropertyContactUserRequest = $Result.DefaultSelection<Prisma.$PropertyContactUserRequestPayload>
/**
 * Model ContactUser
 * 
 */
export type ContactUser = $Result.DefaultSelection<Prisma.$ContactUserPayload>
/**
 * Model GetEstimate
 * 
 */
export type GetEstimate = $Result.DefaultSelection<Prisma.$GetEstimatePayload>
/**
 * Model Faqs
 * 
 */
export type Faqs = $Result.DefaultSelection<Prisma.$FaqsPayload>
/**
 * Model ContactInformation
 * 
 */
export type ContactInformation = $Result.DefaultSelection<Prisma.$ContactInformationPayload>
/**
 * Model SocialNetwork
 * 
 */
export type SocialNetwork = $Result.DefaultSelection<Prisma.$SocialNetworkPayload>
/**
 * Model SiteConfiguration
 * 
 */
export type SiteConfiguration = $Result.DefaultSelection<Prisma.$SiteConfigurationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  active: 'active',
  inactive: 'inactive',
  pending: 'pending'
};

export type Status = (typeof Status)[keyof typeof Status]


export const RoleName: {
  homeowner_landlord: 'homeowner_landlord',
  agent_broker: 'agent_broker',
  property_manager: 'property_manager'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const PropertyType: {
  buy: 'buy',
  rent: 'rent'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const PropertyCategory: {
  apartment: 'apartment',
  house: 'house',
  condo: 'condo',
  townhome: 'townhome',
  multiFamily: 'multiFamily',
  land: 'land',
  room: 'room',
  duplex: 'duplex'
};

export type PropertyCategory = (typeof PropertyCategory)[keyof typeof PropertyCategory]


export const PropertyStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const ListingStatus: {
  active: 'active',
  inactive: 'inactive',
  sold: 'sold',
  archived: 'archived'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type PropertyCategory = $Enums.PropertyCategory

export const PropertyCategory: typeof $Enums.PropertyCategory

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Notifications
 * const notifications = await prisma.notification.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePackage`: Exposes CRUD operations for the **RolePackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePackages
    * const rolePackages = await prisma.rolePackage.findMany()
    * ```
    */
  get rolePackage(): Prisma.RolePackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.heroBanner`: Exposes CRUD operations for the **HeroBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HeroBanners
    * const heroBanners = await prisma.heroBanner.findMany()
    * ```
    */
  get heroBanner(): Prisma.HeroBannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketTrends`: Exposes CRUD operations for the **MarketTrends** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketTrends
    * const marketTrends = await prisma.marketTrends.findMany()
    * ```
    */
  get marketTrends(): Prisma.MarketTrendsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mortageTools`: Exposes CRUD operations for the **MortageTools** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MortageTools
    * const mortageTools = await prisma.mortageTools.findMany()
    * ```
    */
  get mortageTools(): Prisma.MortageToolsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privacyPolicy`: Exposes CRUD operations for the **PrivacyPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivacyPolicies
    * const privacyPolicies = await prisma.privacyPolicy.findMany()
    * ```
    */
  get privacyPolicy(): Prisma.PrivacyPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termsOfUse`: Exposes CRUD operations for the **TermsOfUse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TermsOfUses
    * const termsOfUses = await prisma.termsOfUse.findMany()
    * ```
    */
  get termsOfUse(): Prisma.TermsOfUseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.buyingGuides`: Exposes CRUD operations for the **BuyingGuides** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BuyingGuides
    * const buyingGuides = await prisma.buyingGuides.findMany()
    * ```
    */
  get buyingGuides(): Prisma.BuyingGuidesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellingTips`: Exposes CRUD operations for the **SellingTips** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellingTips
    * const sellingTips = await prisma.sellingTips.findMany()
    * ```
    */
  get sellingTips(): Prisma.SellingTipsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketInsights`: Exposes CRUD operations for the **MarketInsights** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketInsights
    * const marketInsights = await prisma.marketInsights.findMany()
    * ```
    */
  get marketInsights(): Prisma.MarketInsightsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketAnalysis`: Exposes CRUD operations for the **MarketAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketAnalyses
    * const marketAnalyses = await prisma.marketAnalysis.findMany()
    * ```
    */
  get marketAnalysis(): Prisma.MarketAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.press`: Exposes CRUD operations for the **Press** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Presses
    * const presses = await prisma.press.findMany()
    * ```
    */
  get press(): Prisma.PressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blog`: Exposes CRUD operations for the **Blog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blog.findMany()
    * ```
    */
  get blog(): Prisma.BlogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailConfiguration`: Exposes CRUD operations for the **EmailConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailConfigurations
    * const emailConfigurations = await prisma.emailConfiguration.findMany()
    * ```
    */
  get emailConfiguration(): Prisma.EmailConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stripeConfiguration`: Exposes CRUD operations for the **StripeConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeConfigurations
    * const stripeConfigurations = await prisma.stripeConfiguration.findMany()
    * ```
    */
  get stripeConfiguration(): Prisma.StripeConfigurationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellPageBanner`: Exposes CRUD operations for the **SellPageBanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellPageBanners
    * const sellPageBanners = await prisma.sellPageBanner.findMany()
    * ```
    */
  get sellPageBanner(): Prisma.SellPageBannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellTypes`: Exposes CRUD operations for the **SellTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellTypes
    * const sellTypes = await prisma.sellTypes.findMany()
    * ```
    */
  get sellTypes(): Prisma.SellTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sellerResources`: Exposes CRUD operations for the **SellerResources** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SellerResources
    * const sellerResources = await prisma.sellerResources.findMany()
    * ```
    */
  get sellerResources(): Prisma.SellerResourcesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.developmentPlatform`: Exposes CRUD operations for the **DevelopmentPlatform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DevelopmentPlatforms
    * const developmentPlatforms = await prisma.developmentPlatform.findMany()
    * ```
    */
  get developmentPlatform(): Prisma.DevelopmentPlatformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmark`: Exposes CRUD operations for the **Bookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookmarks
    * const bookmarks = await prisma.bookmark.findMany()
    * ```
    */
  get bookmark(): Prisma.BookmarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyView`: Exposes CRUD operations for the **PropertyView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyViews
    * const propertyViews = await prisma.propertyView.findMany()
    * ```
    */
  get propertyView(): Prisma.PropertyViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyTourRequest`: Exposes CRUD operations for the **PropertyTourRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyTourRequests
    * const propertyTourRequests = await prisma.propertyTourRequest.findMany()
    * ```
    */
  get propertyTourRequest(): Prisma.PropertyTourRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyContactUserRequest`: Exposes CRUD operations for the **PropertyContactUserRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyContactUserRequests
    * const propertyContactUserRequests = await prisma.propertyContactUserRequest.findMany()
    * ```
    */
  get propertyContactUserRequest(): Prisma.PropertyContactUserRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactUser`: Exposes CRUD operations for the **ContactUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactUsers
    * const contactUsers = await prisma.contactUser.findMany()
    * ```
    */
  get contactUser(): Prisma.ContactUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.getEstimate`: Exposes CRUD operations for the **GetEstimate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GetEstimates
    * const getEstimates = await prisma.getEstimate.findMany()
    * ```
    */
  get getEstimate(): Prisma.GetEstimateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.faqs`: Exposes CRUD operations for the **Faqs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faqs
    * const faqs = await prisma.faqs.findMany()
    * ```
    */
  get faqs(): Prisma.FaqsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactInformation`: Exposes CRUD operations for the **ContactInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactInformations
    * const contactInformations = await prisma.contactInformation.findMany()
    * ```
    */
  get contactInformation(): Prisma.ContactInformationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialNetwork`: Exposes CRUD operations for the **SocialNetwork** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialNetworks
    * const socialNetworks = await prisma.socialNetwork.findMany()
    * ```
    */
  get socialNetwork(): Prisma.SocialNetworkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteConfiguration`: Exposes CRUD operations for the **SiteConfiguration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteConfigurations
    * const siteConfigurations = await prisma.siteConfiguration.findMany()
    * ```
    */
  get siteConfiguration(): Prisma.SiteConfigurationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Notification: 'Notification',
    RolePackage: 'RolePackage',
    User: 'User',
    UserRole: 'UserRole',
    Transaction: 'Transaction',
    Session: 'Session',
    Review: 'Review',
    HeroBanner: 'HeroBanner',
    MarketTrends: 'MarketTrends',
    MortageTools: 'MortageTools',
    PrivacyPolicy: 'PrivacyPolicy',
    TermsOfUse: 'TermsOfUse',
    BuyingGuides: 'BuyingGuides',
    SellingTips: 'SellingTips',
    MarketInsights: 'MarketInsights',
    MarketAnalysis: 'MarketAnalysis',
    Press: 'Press',
    Blog: 'Blog',
    EmailConfiguration: 'EmailConfiguration',
    StripeConfiguration: 'StripeConfiguration',
    SellPageBanner: 'SellPageBanner',
    SellTypes: 'SellTypes',
    SellerResources: 'SellerResources',
    DevelopmentPlatform: 'DevelopmentPlatform',
    Property: 'Property',
    Bookmark: 'Bookmark',
    PropertyView: 'PropertyView',
    PropertyTourRequest: 'PropertyTourRequest',
    PropertyContactUserRequest: 'PropertyContactUserRequest',
    ContactUser: 'ContactUser',
    GetEstimate: 'GetEstimate',
    Faqs: 'Faqs',
    ContactInformation: 'ContactInformation',
    SocialNetwork: 'SocialNetwork',
    SiteConfiguration: 'SiteConfiguration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "notification" | "rolePackage" | "user" | "userRole" | "transaction" | "session" | "review" | "heroBanner" | "marketTrends" | "mortageTools" | "privacyPolicy" | "termsOfUse" | "buyingGuides" | "sellingTips" | "marketInsights" | "marketAnalysis" | "press" | "blog" | "emailConfiguration" | "stripeConfiguration" | "sellPageBanner" | "sellTypes" | "sellerResources" | "developmentPlatform" | "property" | "bookmark" | "propertyView" | "propertyTourRequest" | "propertyContactUserRequest" | "contactUser" | "getEstimate" | "faqs" | "contactInformation" | "socialNetwork" | "siteConfiguration"
      txIsolationLevel: never
    }
    model: {
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      RolePackage: {
        payload: Prisma.$RolePackagePayload<ExtArgs>
        fields: Prisma.RolePackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>
          }
          findFirst: {
            args: Prisma.RolePackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>
          }
          findMany: {
            args: Prisma.RolePackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>[]
          }
          create: {
            args: Prisma.RolePackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>
          }
          createMany: {
            args: Prisma.RolePackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>
          }
          update: {
            args: Prisma.RolePackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>
          }
          deleteMany: {
            args: Prisma.RolePackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePackagePayload>
          }
          aggregate: {
            args: Prisma.RolePackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePackage>
          }
          groupBy: {
            args: Prisma.RolePackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePackageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RolePackageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RolePackageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RolePackageCountArgs<ExtArgs>
            result: $Utils.Optional<RolePackageCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserRoleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserRoleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TransactionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TransactionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReviewFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReviewAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      HeroBanner: {
        payload: Prisma.$HeroBannerPayload<ExtArgs>
        fields: Prisma.HeroBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HeroBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HeroBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          findFirst: {
            args: Prisma.HeroBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HeroBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          findMany: {
            args: Prisma.HeroBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>[]
          }
          create: {
            args: Prisma.HeroBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          createMany: {
            args: Prisma.HeroBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HeroBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          update: {
            args: Prisma.HeroBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          deleteMany: {
            args: Prisma.HeroBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HeroBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HeroBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HeroBannerPayload>
          }
          aggregate: {
            args: Prisma.HeroBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHeroBanner>
          }
          groupBy: {
            args: Prisma.HeroBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<HeroBannerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.HeroBannerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.HeroBannerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.HeroBannerCountArgs<ExtArgs>
            result: $Utils.Optional<HeroBannerCountAggregateOutputType> | number
          }
        }
      }
      MarketTrends: {
        payload: Prisma.$MarketTrendsPayload<ExtArgs>
        fields: Prisma.MarketTrendsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketTrendsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketTrendsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>
          }
          findFirst: {
            args: Prisma.MarketTrendsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketTrendsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>
          }
          findMany: {
            args: Prisma.MarketTrendsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>[]
          }
          create: {
            args: Prisma.MarketTrendsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>
          }
          createMany: {
            args: Prisma.MarketTrendsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketTrendsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>
          }
          update: {
            args: Prisma.MarketTrendsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>
          }
          deleteMany: {
            args: Prisma.MarketTrendsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketTrendsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketTrendsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketTrendsPayload>
          }
          aggregate: {
            args: Prisma.MarketTrendsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketTrends>
          }
          groupBy: {
            args: Prisma.MarketTrendsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketTrendsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MarketTrendsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MarketTrendsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MarketTrendsCountArgs<ExtArgs>
            result: $Utils.Optional<MarketTrendsCountAggregateOutputType> | number
          }
        }
      }
      MortageTools: {
        payload: Prisma.$MortageToolsPayload<ExtArgs>
        fields: Prisma.MortageToolsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MortageToolsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MortageToolsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>
          }
          findFirst: {
            args: Prisma.MortageToolsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MortageToolsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>
          }
          findMany: {
            args: Prisma.MortageToolsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>[]
          }
          create: {
            args: Prisma.MortageToolsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>
          }
          createMany: {
            args: Prisma.MortageToolsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MortageToolsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>
          }
          update: {
            args: Prisma.MortageToolsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>
          }
          deleteMany: {
            args: Prisma.MortageToolsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MortageToolsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MortageToolsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MortageToolsPayload>
          }
          aggregate: {
            args: Prisma.MortageToolsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMortageTools>
          }
          groupBy: {
            args: Prisma.MortageToolsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MortageToolsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MortageToolsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MortageToolsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MortageToolsCountArgs<ExtArgs>
            result: $Utils.Optional<MortageToolsCountAggregateOutputType> | number
          }
        }
      }
      PrivacyPolicy: {
        payload: Prisma.$PrivacyPolicyPayload<ExtArgs>
        fields: Prisma.PrivacyPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivacyPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findFirst: {
            args: Prisma.PrivacyPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          findMany: {
            args: Prisma.PrivacyPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>[]
          }
          create: {
            args: Prisma.PrivacyPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          createMany: {
            args: Prisma.PrivacyPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrivacyPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          update: {
            args: Prisma.PrivacyPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          deleteMany: {
            args: Prisma.PrivacyPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivacyPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrivacyPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivacyPolicyPayload>
          }
          aggregate: {
            args: Prisma.PrivacyPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivacyPolicy>
          }
          groupBy: {
            args: Prisma.PrivacyPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PrivacyPolicyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PrivacyPolicyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PrivacyPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<PrivacyPolicyCountAggregateOutputType> | number
          }
        }
      }
      TermsOfUse: {
        payload: Prisma.$TermsOfUsePayload<ExtArgs>
        fields: Prisma.TermsOfUseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermsOfUseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermsOfUseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>
          }
          findFirst: {
            args: Prisma.TermsOfUseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermsOfUseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>
          }
          findMany: {
            args: Prisma.TermsOfUseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>[]
          }
          create: {
            args: Prisma.TermsOfUseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>
          }
          createMany: {
            args: Prisma.TermsOfUseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TermsOfUseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>
          }
          update: {
            args: Prisma.TermsOfUseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>
          }
          deleteMany: {
            args: Prisma.TermsOfUseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TermsOfUseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TermsOfUseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TermsOfUsePayload>
          }
          aggregate: {
            args: Prisma.TermsOfUseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermsOfUse>
          }
          groupBy: {
            args: Prisma.TermsOfUseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TermsOfUseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TermsOfUseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TermsOfUseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TermsOfUseCountArgs<ExtArgs>
            result: $Utils.Optional<TermsOfUseCountAggregateOutputType> | number
          }
        }
      }
      BuyingGuides: {
        payload: Prisma.$BuyingGuidesPayload<ExtArgs>
        fields: Prisma.BuyingGuidesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuyingGuidesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuyingGuidesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>
          }
          findFirst: {
            args: Prisma.BuyingGuidesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuyingGuidesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>
          }
          findMany: {
            args: Prisma.BuyingGuidesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>[]
          }
          create: {
            args: Prisma.BuyingGuidesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>
          }
          createMany: {
            args: Prisma.BuyingGuidesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BuyingGuidesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>
          }
          update: {
            args: Prisma.BuyingGuidesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>
          }
          deleteMany: {
            args: Prisma.BuyingGuidesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuyingGuidesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuyingGuidesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuyingGuidesPayload>
          }
          aggregate: {
            args: Prisma.BuyingGuidesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuyingGuides>
          }
          groupBy: {
            args: Prisma.BuyingGuidesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuyingGuidesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BuyingGuidesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BuyingGuidesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BuyingGuidesCountArgs<ExtArgs>
            result: $Utils.Optional<BuyingGuidesCountAggregateOutputType> | number
          }
        }
      }
      SellingTips: {
        payload: Prisma.$SellingTipsPayload<ExtArgs>
        fields: Prisma.SellingTipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellingTipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellingTipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>
          }
          findFirst: {
            args: Prisma.SellingTipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellingTipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>
          }
          findMany: {
            args: Prisma.SellingTipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>[]
          }
          create: {
            args: Prisma.SellingTipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>
          }
          createMany: {
            args: Prisma.SellingTipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellingTipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>
          }
          update: {
            args: Prisma.SellingTipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>
          }
          deleteMany: {
            args: Prisma.SellingTipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellingTipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellingTipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellingTipsPayload>
          }
          aggregate: {
            args: Prisma.SellingTipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellingTips>
          }
          groupBy: {
            args: Prisma.SellingTipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellingTipsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SellingTipsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SellingTipsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SellingTipsCountArgs<ExtArgs>
            result: $Utils.Optional<SellingTipsCountAggregateOutputType> | number
          }
        }
      }
      MarketInsights: {
        payload: Prisma.$MarketInsightsPayload<ExtArgs>
        fields: Prisma.MarketInsightsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketInsightsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketInsightsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>
          }
          findFirst: {
            args: Prisma.MarketInsightsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketInsightsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>
          }
          findMany: {
            args: Prisma.MarketInsightsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>[]
          }
          create: {
            args: Prisma.MarketInsightsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>
          }
          createMany: {
            args: Prisma.MarketInsightsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketInsightsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>
          }
          update: {
            args: Prisma.MarketInsightsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>
          }
          deleteMany: {
            args: Prisma.MarketInsightsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketInsightsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketInsightsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketInsightsPayload>
          }
          aggregate: {
            args: Prisma.MarketInsightsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketInsights>
          }
          groupBy: {
            args: Prisma.MarketInsightsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketInsightsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MarketInsightsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MarketInsightsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MarketInsightsCountArgs<ExtArgs>
            result: $Utils.Optional<MarketInsightsCountAggregateOutputType> | number
          }
        }
      }
      MarketAnalysis: {
        payload: Prisma.$MarketAnalysisPayload<ExtArgs>
        fields: Prisma.MarketAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>
          }
          findFirst: {
            args: Prisma.MarketAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>
          }
          findMany: {
            args: Prisma.MarketAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>[]
          }
          create: {
            args: Prisma.MarketAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>
          }
          createMany: {
            args: Prisma.MarketAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MarketAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>
          }
          update: {
            args: Prisma.MarketAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.MarketAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketAnalysisPayload>
          }
          aggregate: {
            args: Prisma.MarketAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketAnalysis>
          }
          groupBy: {
            args: Prisma.MarketAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketAnalysisGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MarketAnalysisFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MarketAnalysisAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MarketAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<MarketAnalysisCountAggregateOutputType> | number
          }
        }
      }
      Press: {
        payload: Prisma.$PressPayload<ExtArgs>
        fields: Prisma.PressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>
          }
          findFirst: {
            args: Prisma.PressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>
          }
          findMany: {
            args: Prisma.PressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>[]
          }
          create: {
            args: Prisma.PressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>
          }
          createMany: {
            args: Prisma.PressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>
          }
          update: {
            args: Prisma.PressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>
          }
          deleteMany: {
            args: Prisma.PressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PressPayload>
          }
          aggregate: {
            args: Prisma.PressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePress>
          }
          groupBy: {
            args: Prisma.PressGroupByArgs<ExtArgs>
            result: $Utils.Optional<PressGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PressFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PressAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PressCountArgs<ExtArgs>
            result: $Utils.Optional<PressCountAggregateOutputType> | number
          }
        }
      }
      Blog: {
        payload: Prisma.$BlogPayload<ExtArgs>
        fields: Prisma.BlogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findFirst: {
            args: Prisma.BlogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          findMany: {
            args: Prisma.BlogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>[]
          }
          create: {
            args: Prisma.BlogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          createMany: {
            args: Prisma.BlogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BlogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          update: {
            args: Prisma.BlogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          deleteMany: {
            args: Prisma.BlogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BlogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPayload>
          }
          aggregate: {
            args: Prisma.BlogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlog>
          }
          groupBy: {
            args: Prisma.BlogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BlogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BlogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BlogCountArgs<ExtArgs>
            result: $Utils.Optional<BlogCountAggregateOutputType> | number
          }
        }
      }
      EmailConfiguration: {
        payload: Prisma.$EmailConfigurationPayload<ExtArgs>
        fields: Prisma.EmailConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>
          }
          findFirst: {
            args: Prisma.EmailConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>
          }
          findMany: {
            args: Prisma.EmailConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>[]
          }
          create: {
            args: Prisma.EmailConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>
          }
          createMany: {
            args: Prisma.EmailConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>
          }
          update: {
            args: Prisma.EmailConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.EmailConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailConfigurationPayload>
          }
          aggregate: {
            args: Prisma.EmailConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailConfiguration>
          }
          groupBy: {
            args: Prisma.EmailConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailConfigurationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EmailConfigurationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EmailConfigurationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EmailConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailConfigurationCountAggregateOutputType> | number
          }
        }
      }
      StripeConfiguration: {
        payload: Prisma.$StripeConfigurationPayload<ExtArgs>
        fields: Prisma.StripeConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>
          }
          findFirst: {
            args: Prisma.StripeConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>
          }
          findMany: {
            args: Prisma.StripeConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>[]
          }
          create: {
            args: Prisma.StripeConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>
          }
          createMany: {
            args: Prisma.StripeConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StripeConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>
          }
          update: {
            args: Prisma.StripeConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.StripeConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StripeConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StripeConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeConfigurationPayload>
          }
          aggregate: {
            args: Prisma.StripeConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStripeConfiguration>
          }
          groupBy: {
            args: Prisma.StripeConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StripeConfigurationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StripeConfigurationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StripeConfigurationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StripeConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<StripeConfigurationCountAggregateOutputType> | number
          }
        }
      }
      SellPageBanner: {
        payload: Prisma.$SellPageBannerPayload<ExtArgs>
        fields: Prisma.SellPageBannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellPageBannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellPageBannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>
          }
          findFirst: {
            args: Prisma.SellPageBannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellPageBannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>
          }
          findMany: {
            args: Prisma.SellPageBannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>[]
          }
          create: {
            args: Prisma.SellPageBannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>
          }
          createMany: {
            args: Prisma.SellPageBannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellPageBannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>
          }
          update: {
            args: Prisma.SellPageBannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>
          }
          deleteMany: {
            args: Prisma.SellPageBannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellPageBannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellPageBannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellPageBannerPayload>
          }
          aggregate: {
            args: Prisma.SellPageBannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellPageBanner>
          }
          groupBy: {
            args: Prisma.SellPageBannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellPageBannerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SellPageBannerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SellPageBannerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SellPageBannerCountArgs<ExtArgs>
            result: $Utils.Optional<SellPageBannerCountAggregateOutputType> | number
          }
        }
      }
      SellTypes: {
        payload: Prisma.$SellTypesPayload<ExtArgs>
        fields: Prisma.SellTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>
          }
          findFirst: {
            args: Prisma.SellTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>
          }
          findMany: {
            args: Prisma.SellTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>[]
          }
          create: {
            args: Prisma.SellTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>
          }
          createMany: {
            args: Prisma.SellTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>
          }
          update: {
            args: Prisma.SellTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>
          }
          deleteMany: {
            args: Prisma.SellTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellTypesPayload>
          }
          aggregate: {
            args: Prisma.SellTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellTypes>
          }
          groupBy: {
            args: Prisma.SellTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellTypesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SellTypesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SellTypesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SellTypesCountArgs<ExtArgs>
            result: $Utils.Optional<SellTypesCountAggregateOutputType> | number
          }
        }
      }
      SellerResources: {
        payload: Prisma.$SellerResourcesPayload<ExtArgs>
        fields: Prisma.SellerResourcesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerResourcesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerResourcesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>
          }
          findFirst: {
            args: Prisma.SellerResourcesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerResourcesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>
          }
          findMany: {
            args: Prisma.SellerResourcesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>[]
          }
          create: {
            args: Prisma.SellerResourcesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>
          }
          createMany: {
            args: Prisma.SellerResourcesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellerResourcesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>
          }
          update: {
            args: Prisma.SellerResourcesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>
          }
          deleteMany: {
            args: Prisma.SellerResourcesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerResourcesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellerResourcesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerResourcesPayload>
          }
          aggregate: {
            args: Prisma.SellerResourcesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSellerResources>
          }
          groupBy: {
            args: Prisma.SellerResourcesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerResourcesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SellerResourcesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SellerResourcesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SellerResourcesCountArgs<ExtArgs>
            result: $Utils.Optional<SellerResourcesCountAggregateOutputType> | number
          }
        }
      }
      DevelopmentPlatform: {
        payload: Prisma.$DevelopmentPlatformPayload<ExtArgs>
        fields: Prisma.DevelopmentPlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DevelopmentPlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DevelopmentPlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>
          }
          findFirst: {
            args: Prisma.DevelopmentPlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DevelopmentPlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>
          }
          findMany: {
            args: Prisma.DevelopmentPlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>[]
          }
          create: {
            args: Prisma.DevelopmentPlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>
          }
          createMany: {
            args: Prisma.DevelopmentPlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DevelopmentPlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>
          }
          update: {
            args: Prisma.DevelopmentPlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>
          }
          deleteMany: {
            args: Prisma.DevelopmentPlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DevelopmentPlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DevelopmentPlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevelopmentPlatformPayload>
          }
          aggregate: {
            args: Prisma.DevelopmentPlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevelopmentPlatform>
          }
          groupBy: {
            args: Prisma.DevelopmentPlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<DevelopmentPlatformGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DevelopmentPlatformFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DevelopmentPlatformAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DevelopmentPlatformCountArgs<ExtArgs>
            result: $Utils.Optional<DevelopmentPlatformCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PropertyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PropertyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Bookmark: {
        payload: Prisma.$BookmarkPayload<ExtArgs>
        fields: Prisma.BookmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findFirst: {
            args: Prisma.BookmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findMany: {
            args: Prisma.BookmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          create: {
            args: Prisma.BookmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          createMany: {
            args: Prisma.BookmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          update: {
            args: Prisma.BookmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          aggregate: {
            args: Prisma.BookmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmark>
          }
          groupBy: {
            args: Prisma.BookmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BookmarkFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BookmarkAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BookmarkCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCountAggregateOutputType> | number
          }
        }
      }
      PropertyView: {
        payload: Prisma.$PropertyViewPayload<ExtArgs>
        fields: Prisma.PropertyViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findFirst: {
            args: Prisma.PropertyViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          findMany: {
            args: Prisma.PropertyViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>[]
          }
          create: {
            args: Prisma.PropertyViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          createMany: {
            args: Prisma.PropertyViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PropertyViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          update: {
            args: Prisma.PropertyViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          deleteMany: {
            args: Prisma.PropertyViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyViewPayload>
          }
          aggregate: {
            args: Prisma.PropertyViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyView>
          }
          groupBy: {
            args: Prisma.PropertyViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PropertyViewFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PropertyViewAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PropertyViewCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyViewCountAggregateOutputType> | number
          }
        }
      }
      PropertyTourRequest: {
        payload: Prisma.$PropertyTourRequestPayload<ExtArgs>
        fields: Prisma.PropertyTourRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyTourRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyTourRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>
          }
          findFirst: {
            args: Prisma.PropertyTourRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyTourRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>
          }
          findMany: {
            args: Prisma.PropertyTourRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>[]
          }
          create: {
            args: Prisma.PropertyTourRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>
          }
          createMany: {
            args: Prisma.PropertyTourRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PropertyTourRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>
          }
          update: {
            args: Prisma.PropertyTourRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>
          }
          deleteMany: {
            args: Prisma.PropertyTourRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyTourRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyTourRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyTourRequestPayload>
          }
          aggregate: {
            args: Prisma.PropertyTourRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyTourRequest>
          }
          groupBy: {
            args: Prisma.PropertyTourRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyTourRequestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PropertyTourRequestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PropertyTourRequestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PropertyTourRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyTourRequestCountAggregateOutputType> | number
          }
        }
      }
      PropertyContactUserRequest: {
        payload: Prisma.$PropertyContactUserRequestPayload<ExtArgs>
        fields: Prisma.PropertyContactUserRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyContactUserRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyContactUserRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>
          }
          findFirst: {
            args: Prisma.PropertyContactUserRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyContactUserRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>
          }
          findMany: {
            args: Prisma.PropertyContactUserRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>[]
          }
          create: {
            args: Prisma.PropertyContactUserRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>
          }
          createMany: {
            args: Prisma.PropertyContactUserRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PropertyContactUserRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>
          }
          update: {
            args: Prisma.PropertyContactUserRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>
          }
          deleteMany: {
            args: Prisma.PropertyContactUserRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyContactUserRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PropertyContactUserRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyContactUserRequestPayload>
          }
          aggregate: {
            args: Prisma.PropertyContactUserRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyContactUserRequest>
          }
          groupBy: {
            args: Prisma.PropertyContactUserRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyContactUserRequestGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PropertyContactUserRequestFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PropertyContactUserRequestAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PropertyContactUserRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyContactUserRequestCountAggregateOutputType> | number
          }
        }
      }
      ContactUser: {
        payload: Prisma.$ContactUserPayload<ExtArgs>
        fields: Prisma.ContactUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>
          }
          findFirst: {
            args: Prisma.ContactUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>
          }
          findMany: {
            args: Prisma.ContactUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>[]
          }
          create: {
            args: Prisma.ContactUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>
          }
          createMany: {
            args: Prisma.ContactUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>
          }
          update: {
            args: Prisma.ContactUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>
          }
          deleteMany: {
            args: Prisma.ContactUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactUserPayload>
          }
          aggregate: {
            args: Prisma.ContactUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactUser>
          }
          groupBy: {
            args: Prisma.ContactUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactUserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContactUserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContactUserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContactUserCountArgs<ExtArgs>
            result: $Utils.Optional<ContactUserCountAggregateOutputType> | number
          }
        }
      }
      GetEstimate: {
        payload: Prisma.$GetEstimatePayload<ExtArgs>
        fields: Prisma.GetEstimateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GetEstimateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GetEstimateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>
          }
          findFirst: {
            args: Prisma.GetEstimateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GetEstimateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>
          }
          findMany: {
            args: Prisma.GetEstimateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>[]
          }
          create: {
            args: Prisma.GetEstimateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>
          }
          createMany: {
            args: Prisma.GetEstimateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GetEstimateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>
          }
          update: {
            args: Prisma.GetEstimateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>
          }
          deleteMany: {
            args: Prisma.GetEstimateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GetEstimateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GetEstimateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GetEstimatePayload>
          }
          aggregate: {
            args: Prisma.GetEstimateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGetEstimate>
          }
          groupBy: {
            args: Prisma.GetEstimateGroupByArgs<ExtArgs>
            result: $Utils.Optional<GetEstimateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GetEstimateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GetEstimateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GetEstimateCountArgs<ExtArgs>
            result: $Utils.Optional<GetEstimateCountAggregateOutputType> | number
          }
        }
      }
      Faqs: {
        payload: Prisma.$FaqsPayload<ExtArgs>
        fields: Prisma.FaqsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FaqsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FaqsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>
          }
          findFirst: {
            args: Prisma.FaqsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FaqsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>
          }
          findMany: {
            args: Prisma.FaqsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>[]
          }
          create: {
            args: Prisma.FaqsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>
          }
          createMany: {
            args: Prisma.FaqsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FaqsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>
          }
          update: {
            args: Prisma.FaqsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>
          }
          deleteMany: {
            args: Prisma.FaqsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FaqsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FaqsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FaqsPayload>
          }
          aggregate: {
            args: Prisma.FaqsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaqs>
          }
          groupBy: {
            args: Prisma.FaqsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FaqsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FaqsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FaqsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FaqsCountArgs<ExtArgs>
            result: $Utils.Optional<FaqsCountAggregateOutputType> | number
          }
        }
      }
      ContactInformation: {
        payload: Prisma.$ContactInformationPayload<ExtArgs>
        fields: Prisma.ContactInformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactInformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactInformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>
          }
          findFirst: {
            args: Prisma.ContactInformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactInformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>
          }
          findMany: {
            args: Prisma.ContactInformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>[]
          }
          create: {
            args: Prisma.ContactInformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>
          }
          createMany: {
            args: Prisma.ContactInformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContactInformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>
          }
          update: {
            args: Prisma.ContactInformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>
          }
          deleteMany: {
            args: Prisma.ContactInformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactInformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactInformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactInformationPayload>
          }
          aggregate: {
            args: Prisma.ContactInformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactInformation>
          }
          groupBy: {
            args: Prisma.ContactInformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactInformationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContactInformationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContactInformationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ContactInformationCountArgs<ExtArgs>
            result: $Utils.Optional<ContactInformationCountAggregateOutputType> | number
          }
        }
      }
      SocialNetwork: {
        payload: Prisma.$SocialNetworkPayload<ExtArgs>
        fields: Prisma.SocialNetworkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialNetworkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialNetworkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>
          }
          findFirst: {
            args: Prisma.SocialNetworkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialNetworkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>
          }
          findMany: {
            args: Prisma.SocialNetworkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>[]
          }
          create: {
            args: Prisma.SocialNetworkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>
          }
          createMany: {
            args: Prisma.SocialNetworkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SocialNetworkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>
          }
          update: {
            args: Prisma.SocialNetworkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>
          }
          deleteMany: {
            args: Prisma.SocialNetworkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialNetworkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SocialNetworkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialNetworkPayload>
          }
          aggregate: {
            args: Prisma.SocialNetworkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialNetwork>
          }
          groupBy: {
            args: Prisma.SocialNetworkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialNetworkGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SocialNetworkFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SocialNetworkAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SocialNetworkCountArgs<ExtArgs>
            result: $Utils.Optional<SocialNetworkCountAggregateOutputType> | number
          }
        }
      }
      SiteConfiguration: {
        payload: Prisma.$SiteConfigurationPayload<ExtArgs>
        fields: Prisma.SiteConfigurationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteConfigurationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteConfigurationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>
          }
          findFirst: {
            args: Prisma.SiteConfigurationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteConfigurationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>
          }
          findMany: {
            args: Prisma.SiteConfigurationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>[]
          }
          create: {
            args: Prisma.SiteConfigurationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>
          }
          createMany: {
            args: Prisma.SiteConfigurationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SiteConfigurationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>
          }
          update: {
            args: Prisma.SiteConfigurationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>
          }
          deleteMany: {
            args: Prisma.SiteConfigurationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteConfigurationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SiteConfigurationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteConfigurationPayload>
          }
          aggregate: {
            args: Prisma.SiteConfigurationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteConfiguration>
          }
          groupBy: {
            args: Prisma.SiteConfigurationGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigurationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SiteConfigurationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SiteConfigurationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SiteConfigurationCountArgs<ExtArgs>
            result: $Utils.Optional<SiteConfigurationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    notification?: NotificationOmit
    rolePackage?: RolePackageOmit
    user?: UserOmit
    userRole?: UserRoleOmit
    transaction?: TransactionOmit
    session?: SessionOmit
    review?: ReviewOmit
    heroBanner?: HeroBannerOmit
    marketTrends?: MarketTrendsOmit
    mortageTools?: MortageToolsOmit
    privacyPolicy?: PrivacyPolicyOmit
    termsOfUse?: TermsOfUseOmit
    buyingGuides?: BuyingGuidesOmit
    sellingTips?: SellingTipsOmit
    marketInsights?: MarketInsightsOmit
    marketAnalysis?: MarketAnalysisOmit
    press?: PressOmit
    blog?: BlogOmit
    emailConfiguration?: EmailConfigurationOmit
    stripeConfiguration?: StripeConfigurationOmit
    sellPageBanner?: SellPageBannerOmit
    sellTypes?: SellTypesOmit
    sellerResources?: SellerResourcesOmit
    developmentPlatform?: DevelopmentPlatformOmit
    property?: PropertyOmit
    bookmark?: BookmarkOmit
    propertyView?: PropertyViewOmit
    propertyTourRequest?: PropertyTourRequestOmit
    propertyContactUserRequest?: PropertyContactUserRequestOmit
    contactUser?: ContactUserOmit
    getEstimate?: GetEstimateOmit
    faqs?: FaqsOmit
    contactInformation?: ContactInformationOmit
    socialNetwork?: SocialNetworkOmit
    siteConfiguration?: SiteConfigurationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RolePackageCountOutputType
   */

  export type RolePackageCountOutputType = {
    userRoles: number
  }

  export type RolePackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RolePackageCountOutputTypeCountUserRolesArgs
  }

  // Custom InputTypes
  /**
   * RolePackageCountOutputType without action
   */
  export type RolePackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackageCountOutputType
     */
    select?: RolePackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolePackageCountOutputType without action
   */
  export type RolePackageCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
    userRoles: number
    sessions: number
    property: number
    Bookmark: number
    PropertyView: number
    PropertyTourRequest: number
    PropertyContactUserRequest: number
    transactions: number
    reviewsGiven: number
    reviewsReceived: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    userRoles?: boolean | UserCountOutputTypeCountUserRolesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    property?: boolean | UserCountOutputTypeCountPropertyArgs
    Bookmark?: boolean | UserCountOutputTypeCountBookmarkArgs
    PropertyView?: boolean | UserCountOutputTypeCountPropertyViewArgs
    PropertyTourRequest?: boolean | UserCountOutputTypeCountPropertyTourRequestArgs
    PropertyContactUserRequest?: boolean | UserCountOutputTypeCountPropertyContactUserRequestArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    reviewsGiven?: boolean | UserCountOutputTypeCountReviewsGivenArgs
    reviewsReceived?: boolean | UserCountOutputTypeCountReviewsReceivedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyTourRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTourRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyContactUserRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyContactUserRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type UserRoleCountOutputType
   */

  export type UserRoleCountOutputType = {
    transactions: number
  }

  export type UserRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | UserRoleCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleCountOutputType
     */
    select?: UserRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    Bookmark: number
    PropertyView: number
    PropertyTourRequest: number
    PropertyContactUserRequest: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookmark?: boolean | PropertyCountOutputTypeCountBookmarkArgs
    PropertyView?: boolean | PropertyCountOutputTypeCountPropertyViewArgs
    PropertyTourRequest?: boolean | PropertyCountOutputTypeCountPropertyTourRequestArgs
    PropertyContactUserRequest?: boolean | PropertyCountOutputTypeCountPropertyContactUserRequestArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountBookmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyTourRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTourRequestWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPropertyContactUserRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyContactUserRequestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: string | null
    read: boolean | null
    link: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    read: number
    link: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    link?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    link?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    link?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: string
    read: boolean
    link: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    link?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    link?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "read" | "link" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: string
      read: boolean
      link: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model RolePackage
   */

  export type AggregateRolePackage = {
    _count: RolePackageCountAggregateOutputType | null
    _avg: RolePackageAvgAggregateOutputType | null
    _sum: RolePackageSumAggregateOutputType | null
    _min: RolePackageMinAggregateOutputType | null
    _max: RolePackageMaxAggregateOutputType | null
  }

  export type RolePackageAvgAggregateOutputType = {
    price: number | null
    durationDays: number | null
  }

  export type RolePackageSumAggregateOutputType = {
    price: number | null
    durationDays: number | null
  }

  export type RolePackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    roleName: $Enums.RoleName | null
    price: number | null
    durationDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    roleName: $Enums.RoleName | null
    price: number | null
    durationDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RolePackageCountAggregateOutputType = {
    id: number
    name: number
    roleName: number
    price: number
    durationDays: number
    features: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RolePackageAvgAggregateInputType = {
    price?: true
    durationDays?: true
  }

  export type RolePackageSumAggregateInputType = {
    price?: true
    durationDays?: true
  }

  export type RolePackageMinAggregateInputType = {
    id?: true
    name?: true
    roleName?: true
    price?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePackageMaxAggregateInputType = {
    id?: true
    name?: true
    roleName?: true
    price?: true
    durationDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RolePackageCountAggregateInputType = {
    id?: true
    name?: true
    roleName?: true
    price?: true
    durationDays?: true
    features?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RolePackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePackage to aggregate.
     */
    where?: RolePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePackages to fetch.
     */
    orderBy?: RolePackageOrderByWithRelationInput | RolePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePackages
    **/
    _count?: true | RolePackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolePackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolePackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePackageMaxAggregateInputType
  }

  export type GetRolePackageAggregateType<T extends RolePackageAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePackage[P]>
      : GetScalarType<T[P], AggregateRolePackage[P]>
  }




  export type RolePackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePackageWhereInput
    orderBy?: RolePackageOrderByWithAggregationInput | RolePackageOrderByWithAggregationInput[]
    by: RolePackageScalarFieldEnum[] | RolePackageScalarFieldEnum
    having?: RolePackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePackageCountAggregateInputType | true
    _avg?: RolePackageAvgAggregateInputType
    _sum?: RolePackageSumAggregateInputType
    _min?: RolePackageMinAggregateInputType
    _max?: RolePackageMaxAggregateInputType
  }

  export type RolePackageGroupByOutputType = {
    id: string
    name: string
    roleName: $Enums.RoleName
    price: number
    durationDays: number
    features: string[]
    createdAt: Date
    updatedAt: Date
    _count: RolePackageCountAggregateOutputType | null
    _avg: RolePackageAvgAggregateOutputType | null
    _sum: RolePackageSumAggregateOutputType | null
    _min: RolePackageMinAggregateOutputType | null
    _max: RolePackageMaxAggregateOutputType | null
  }

  type GetRolePackageGroupByPayload<T extends RolePackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePackageGroupByOutputType[P]>
            : GetScalarType<T[P], RolePackageGroupByOutputType[P]>
        }
      >
    >


  export type RolePackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    roleName?: boolean
    price?: boolean
    durationDays?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userRoles?: boolean | RolePackage$userRolesArgs<ExtArgs>
    _count?: boolean | RolePackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePackage"]>



  export type RolePackageSelectScalar = {
    id?: boolean
    name?: boolean
    roleName?: boolean
    price?: boolean
    durationDays?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RolePackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "roleName" | "price" | "durationDays" | "features" | "createdAt" | "updatedAt", ExtArgs["result"]["rolePackage"]>
  export type RolePackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRoles?: boolean | RolePackage$userRolesArgs<ExtArgs>
    _count?: boolean | RolePackageCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePackage"
    objects: {
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      roleName: $Enums.RoleName
      price: number
      durationDays: number
      features: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rolePackage"]>
    composites: {}
  }

  type RolePackageGetPayload<S extends boolean | null | undefined | RolePackageDefaultArgs> = $Result.GetResult<Prisma.$RolePackagePayload, S>

  type RolePackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePackageCountAggregateInputType | true
    }

  export interface RolePackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePackage'], meta: { name: 'RolePackage' } }
    /**
     * Find zero or one RolePackage that matches the filter.
     * @param {RolePackageFindUniqueArgs} args - Arguments to find a RolePackage
     * @example
     * // Get one RolePackage
     * const rolePackage = await prisma.rolePackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePackageFindUniqueArgs>(args: SelectSubset<T, RolePackageFindUniqueArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePackageFindUniqueOrThrowArgs} args - Arguments to find a RolePackage
     * @example
     * // Get one RolePackage
     * const rolePackage = await prisma.rolePackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePackageFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageFindFirstArgs} args - Arguments to find a RolePackage
     * @example
     * // Get one RolePackage
     * const rolePackage = await prisma.rolePackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePackageFindFirstArgs>(args?: SelectSubset<T, RolePackageFindFirstArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageFindFirstOrThrowArgs} args - Arguments to find a RolePackage
     * @example
     * // Get one RolePackage
     * const rolePackage = await prisma.rolePackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePackageFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePackages
     * const rolePackages = await prisma.rolePackage.findMany()
     * 
     * // Get first 10 RolePackages
     * const rolePackages = await prisma.rolePackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePackageWithIdOnly = await prisma.rolePackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePackageFindManyArgs>(args?: SelectSubset<T, RolePackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePackage.
     * @param {RolePackageCreateArgs} args - Arguments to create a RolePackage.
     * @example
     * // Create one RolePackage
     * const RolePackage = await prisma.rolePackage.create({
     *   data: {
     *     // ... data to create a RolePackage
     *   }
     * })
     * 
     */
    create<T extends RolePackageCreateArgs>(args: SelectSubset<T, RolePackageCreateArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePackages.
     * @param {RolePackageCreateManyArgs} args - Arguments to create many RolePackages.
     * @example
     * // Create many RolePackages
     * const rolePackage = await prisma.rolePackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePackageCreateManyArgs>(args?: SelectSubset<T, RolePackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePackage.
     * @param {RolePackageDeleteArgs} args - Arguments to delete one RolePackage.
     * @example
     * // Delete one RolePackage
     * const RolePackage = await prisma.rolePackage.delete({
     *   where: {
     *     // ... filter to delete one RolePackage
     *   }
     * })
     * 
     */
    delete<T extends RolePackageDeleteArgs>(args: SelectSubset<T, RolePackageDeleteArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePackage.
     * @param {RolePackageUpdateArgs} args - Arguments to update one RolePackage.
     * @example
     * // Update one RolePackage
     * const rolePackage = await prisma.rolePackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePackageUpdateArgs>(args: SelectSubset<T, RolePackageUpdateArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePackages.
     * @param {RolePackageDeleteManyArgs} args - Arguments to filter RolePackages to delete.
     * @example
     * // Delete a few RolePackages
     * const { count } = await prisma.rolePackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePackageDeleteManyArgs>(args?: SelectSubset<T, RolePackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePackages
     * const rolePackage = await prisma.rolePackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePackageUpdateManyArgs>(args: SelectSubset<T, RolePackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePackage.
     * @param {RolePackageUpsertArgs} args - Arguments to update or create a RolePackage.
     * @example
     * // Update or create a RolePackage
     * const rolePackage = await prisma.rolePackage.upsert({
     *   create: {
     *     // ... data to create a RolePackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePackage we want to update
     *   }
     * })
     */
    upsert<T extends RolePackageUpsertArgs>(args: SelectSubset<T, RolePackageUpsertArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePackages that matches the filter.
     * @param {RolePackageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rolePackage = await prisma.rolePackage.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RolePackageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RolePackage.
     * @param {RolePackageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rolePackage = await prisma.rolePackage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RolePackageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RolePackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageCountArgs} args - Arguments to filter RolePackages to count.
     * @example
     * // Count the number of RolePackages
     * const count = await prisma.rolePackage.count({
     *   where: {
     *     // ... the filter for the RolePackages we want to count
     *   }
     * })
    **/
    count<T extends RolePackageCountArgs>(
      args?: Subset<T, RolePackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePackageAggregateArgs>(args: Subset<T, RolePackageAggregateArgs>): Prisma.PrismaPromise<GetRolePackageAggregateType<T>>

    /**
     * Group by RolePackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePackageGroupByArgs['orderBy'] }
        : { orderBy?: RolePackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePackage model
   */
  readonly fields: RolePackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRoles<T extends RolePackage$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, RolePackage$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePackage model
   */
  interface RolePackageFieldRefs {
    readonly id: FieldRef<"RolePackage", 'String'>
    readonly name: FieldRef<"RolePackage", 'String'>
    readonly roleName: FieldRef<"RolePackage", 'RoleName'>
    readonly price: FieldRef<"RolePackage", 'Float'>
    readonly durationDays: FieldRef<"RolePackage", 'Int'>
    readonly features: FieldRef<"RolePackage", 'String[]'>
    readonly createdAt: FieldRef<"RolePackage", 'DateTime'>
    readonly updatedAt: FieldRef<"RolePackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePackage findUnique
   */
  export type RolePackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * Filter, which RolePackage to fetch.
     */
    where: RolePackageWhereUniqueInput
  }

  /**
   * RolePackage findUniqueOrThrow
   */
  export type RolePackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * Filter, which RolePackage to fetch.
     */
    where: RolePackageWhereUniqueInput
  }

  /**
   * RolePackage findFirst
   */
  export type RolePackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * Filter, which RolePackage to fetch.
     */
    where?: RolePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePackages to fetch.
     */
    orderBy?: RolePackageOrderByWithRelationInput | RolePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePackages.
     */
    cursor?: RolePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePackages.
     */
    distinct?: RolePackageScalarFieldEnum | RolePackageScalarFieldEnum[]
  }

  /**
   * RolePackage findFirstOrThrow
   */
  export type RolePackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * Filter, which RolePackage to fetch.
     */
    where?: RolePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePackages to fetch.
     */
    orderBy?: RolePackageOrderByWithRelationInput | RolePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePackages.
     */
    cursor?: RolePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePackages.
     */
    distinct?: RolePackageScalarFieldEnum | RolePackageScalarFieldEnum[]
  }

  /**
   * RolePackage findMany
   */
  export type RolePackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * Filter, which RolePackages to fetch.
     */
    where?: RolePackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePackages to fetch.
     */
    orderBy?: RolePackageOrderByWithRelationInput | RolePackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePackages.
     */
    cursor?: RolePackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePackages.
     */
    skip?: number
    distinct?: RolePackageScalarFieldEnum | RolePackageScalarFieldEnum[]
  }

  /**
   * RolePackage create
   */
  export type RolePackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePackage.
     */
    data: XOR<RolePackageCreateInput, RolePackageUncheckedCreateInput>
  }

  /**
   * RolePackage createMany
   */
  export type RolePackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePackages.
     */
    data: RolePackageCreateManyInput | RolePackageCreateManyInput[]
  }

  /**
   * RolePackage update
   */
  export type RolePackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePackage.
     */
    data: XOR<RolePackageUpdateInput, RolePackageUncheckedUpdateInput>
    /**
     * Choose, which RolePackage to update.
     */
    where: RolePackageWhereUniqueInput
  }

  /**
   * RolePackage updateMany
   */
  export type RolePackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePackages.
     */
    data: XOR<RolePackageUpdateManyMutationInput, RolePackageUncheckedUpdateManyInput>
    /**
     * Filter which RolePackages to update
     */
    where?: RolePackageWhereInput
    /**
     * Limit how many RolePackages to update.
     */
    limit?: number
  }

  /**
   * RolePackage upsert
   */
  export type RolePackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePackage to update in case it exists.
     */
    where: RolePackageWhereUniqueInput
    /**
     * In case the RolePackage found by the `where` argument doesn't exist, create a new RolePackage with this data.
     */
    create: XOR<RolePackageCreateInput, RolePackageUncheckedCreateInput>
    /**
     * In case the RolePackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePackageUpdateInput, RolePackageUncheckedUpdateInput>
  }

  /**
   * RolePackage delete
   */
  export type RolePackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
    /**
     * Filter which RolePackage to delete.
     */
    where: RolePackageWhereUniqueInput
  }

  /**
   * RolePackage deleteMany
   */
  export type RolePackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePackages to delete
     */
    where?: RolePackageWhereInput
    /**
     * Limit how many RolePackages to delete.
     */
    limit?: number
  }

  /**
   * RolePackage findRaw
   */
  export type RolePackageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RolePackage aggregateRaw
   */
  export type RolePackageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RolePackage.userRoles
   */
  export type RolePackage$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * RolePackage without action
   */
  export type RolePackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePackage
     */
    select?: RolePackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePackage
     */
    omit?: RolePackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePackageInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    reputationScore: number | null
  }

  export type UserSumAggregateOutputType = {
    reputationScore: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    avatar: string | null
    avatarPublicId: string | null
    phone: string | null
    bio: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    previousRole: string | null
    role: string | null
    isAdmin: boolean | null
    status: $Enums.Status | null
    resetCode: string | null
    resetCodeExpiration: Date | null
    flagged: boolean | null
    flagReason: string | null
    isNotificationEnabled: boolean | null
    isTwoFactorEnabled: boolean | null
    twoFactorTempToken: string | null
    twoFactorTempExp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    reputationScore: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    avatar: string | null
    avatarPublicId: string | null
    phone: string | null
    bio: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    previousRole: string | null
    role: string | null
    isAdmin: boolean | null
    status: $Enums.Status | null
    resetCode: string | null
    resetCodeExpiration: Date | null
    flagged: boolean | null
    flagReason: string | null
    isNotificationEnabled: boolean | null
    isTwoFactorEnabled: boolean | null
    twoFactorTempToken: string | null
    twoFactorTempExp: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    reputationScore: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    avatar: number
    avatarPublicId: number
    phone: number
    bio: number
    address: number
    city: number
    state: number
    zipCode: number
    previousRole: number
    role: number
    isAdmin: number
    status: number
    resetCode: number
    resetCodeExpiration: number
    flagged: number
    flagReason: number
    isNotificationEnabled: number
    isTwoFactorEnabled: number
    twoFactorTempToken: number
    twoFactorTempExp: number
    createdAt: number
    updatedAt: number
    reputationScore: number
    reputationHistory: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    reputationScore?: true
  }

  export type UserSumAggregateInputType = {
    reputationScore?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    avatar?: true
    avatarPublicId?: true
    phone?: true
    bio?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    previousRole?: true
    role?: true
    isAdmin?: true
    status?: true
    resetCode?: true
    resetCodeExpiration?: true
    flagged?: true
    flagReason?: true
    isNotificationEnabled?: true
    isTwoFactorEnabled?: true
    twoFactorTempToken?: true
    twoFactorTempExp?: true
    createdAt?: true
    updatedAt?: true
    reputationScore?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    avatar?: true
    avatarPublicId?: true
    phone?: true
    bio?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    previousRole?: true
    role?: true
    isAdmin?: true
    status?: true
    resetCode?: true
    resetCodeExpiration?: true
    flagged?: true
    flagReason?: true
    isNotificationEnabled?: true
    isTwoFactorEnabled?: true
    twoFactorTempToken?: true
    twoFactorTempExp?: true
    createdAt?: true
    updatedAt?: true
    reputationScore?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    avatar?: true
    avatarPublicId?: true
    phone?: true
    bio?: true
    address?: true
    city?: true
    state?: true
    zipCode?: true
    previousRole?: true
    role?: true
    isAdmin?: true
    status?: true
    resetCode?: true
    resetCodeExpiration?: true
    flagged?: true
    flagReason?: true
    isNotificationEnabled?: true
    isTwoFactorEnabled?: true
    twoFactorTempToken?: true
    twoFactorTempExp?: true
    createdAt?: true
    updatedAt?: true
    reputationScore?: true
    reputationHistory?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    avatar: string | null
    avatarPublicId: string | null
    phone: string | null
    bio: string | null
    address: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    previousRole: string | null
    role: string
    isAdmin: boolean
    status: $Enums.Status
    resetCode: string | null
    resetCodeExpiration: Date | null
    flagged: boolean | null
    flagReason: string | null
    isNotificationEnabled: boolean
    isTwoFactorEnabled: boolean
    twoFactorTempToken: string | null
    twoFactorTempExp: Date | null
    createdAt: Date
    updatedAt: Date
    reputationScore: number
    reputationHistory: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    avatarPublicId?: boolean
    phone?: boolean
    bio?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    previousRole?: boolean
    role?: boolean
    isAdmin?: boolean
    status?: boolean
    resetCode?: boolean
    resetCodeExpiration?: boolean
    flagged?: boolean
    flagReason?: boolean
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: boolean
    twoFactorTempExp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reputationScore?: boolean
    reputationHistory?: boolean
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    property?: boolean | User$propertyArgs<ExtArgs>
    Bookmark?: boolean | User$BookmarkArgs<ExtArgs>
    PropertyView?: boolean | User$PropertyViewArgs<ExtArgs>
    PropertyTourRequest?: boolean | User$PropertyTourRequestArgs<ExtArgs>
    PropertyContactUserRequest?: boolean | User$PropertyContactUserRequestArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatar?: boolean
    avatarPublicId?: boolean
    phone?: boolean
    bio?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    previousRole?: boolean
    role?: boolean
    isAdmin?: boolean
    status?: boolean
    resetCode?: boolean
    resetCodeExpiration?: boolean
    flagged?: boolean
    flagReason?: boolean
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: boolean
    twoFactorTempExp?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reputationScore?: boolean
    reputationHistory?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "avatar" | "avatarPublicId" | "phone" | "bio" | "address" | "city" | "state" | "zipCode" | "previousRole" | "role" | "isAdmin" | "status" | "resetCode" | "resetCodeExpiration" | "flagged" | "flagReason" | "isNotificationEnabled" | "isTwoFactorEnabled" | "twoFactorTempToken" | "twoFactorTempExp" | "createdAt" | "updatedAt" | "reputationScore" | "reputationHistory", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    userRoles?: boolean | User$userRolesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    property?: boolean | User$propertyArgs<ExtArgs>
    Bookmark?: boolean | User$BookmarkArgs<ExtArgs>
    PropertyView?: boolean | User$PropertyViewArgs<ExtArgs>
    PropertyTourRequest?: boolean | User$PropertyTourRequestArgs<ExtArgs>
    PropertyContactUserRequest?: boolean | User$PropertyContactUserRequestArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      userRoles: Prisma.$UserRolePayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      property: Prisma.$PropertyPayload<ExtArgs>[]
      Bookmark: Prisma.$BookmarkPayload<ExtArgs>[]
      PropertyView: Prisma.$PropertyViewPayload<ExtArgs>[]
      PropertyTourRequest: Prisma.$PropertyTourRequestPayload<ExtArgs>[]
      PropertyContactUserRequest: Prisma.$PropertyContactUserRequestPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      reviewsGiven: Prisma.$ReviewPayload<ExtArgs>[]
      reviewsReceived: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      avatar: string | null
      avatarPublicId: string | null
      phone: string | null
      bio: string | null
      address: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      previousRole: string | null
      role: string
      isAdmin: boolean
      status: $Enums.Status
      resetCode: string | null
      resetCodeExpiration: Date | null
      flagged: boolean | null
      flagReason: string | null
      isNotificationEnabled: boolean
      isTwoFactorEnabled: boolean
      twoFactorTempToken: string | null
      twoFactorTempExp: Date | null
      createdAt: Date
      updatedAt: Date
      reputationScore: number
      reputationHistory: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userRoles<T extends User$userRolesArgs<ExtArgs> = {}>(args?: Subset<T, User$userRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    property<T extends User$propertyArgs<ExtArgs> = {}>(args?: Subset<T, User$propertyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Bookmark<T extends User$BookmarkArgs<ExtArgs> = {}>(args?: Subset<T, User$BookmarkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyView<T extends User$PropertyViewArgs<ExtArgs> = {}>(args?: Subset<T, User$PropertyViewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyTourRequest<T extends User$PropertyTourRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$PropertyTourRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyContactUserRequest<T extends User$PropertyContactUserRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$PropertyContactUserRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsGiven<T extends User$reviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsReceived<T extends User$reviewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly avatarPublicId: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly zipCode: FieldRef<"User", 'String'>
    readonly previousRole: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'Status'>
    readonly resetCode: FieldRef<"User", 'String'>
    readonly resetCodeExpiration: FieldRef<"User", 'DateTime'>
    readonly flagged: FieldRef<"User", 'Boolean'>
    readonly flagReason: FieldRef<"User", 'String'>
    readonly isNotificationEnabled: FieldRef<"User", 'Boolean'>
    readonly isTwoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorTempToken: FieldRef<"User", 'String'>
    readonly twoFactorTempExp: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly reputationScore: FieldRef<"User", 'Int'>
    readonly reputationHistory: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.userRoles
   */
  export type User$userRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.property
   */
  export type User$propertyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.Bookmark
   */
  export type User$BookmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * User.PropertyView
   */
  export type User$PropertyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * User.PropertyTourRequest
   */
  export type User$PropertyTourRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    where?: PropertyTourRequestWhereInput
    orderBy?: PropertyTourRequestOrderByWithRelationInput | PropertyTourRequestOrderByWithRelationInput[]
    cursor?: PropertyTourRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyTourRequestScalarFieldEnum | PropertyTourRequestScalarFieldEnum[]
  }

  /**
   * User.PropertyContactUserRequest
   */
  export type User$PropertyContactUserRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    where?: PropertyContactUserRequestWhereInput
    orderBy?: PropertyContactUserRequestOrderByWithRelationInput | PropertyContactUserRequestOrderByWithRelationInput[]
    cursor?: PropertyContactUserRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyContactUserRequestScalarFieldEnum | PropertyContactUserRequestScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.reviewsGiven
   */
  export type User$reviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewsReceived
   */
  export type User$reviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    rolePackageId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isPaused: boolean | null
    isExpired: boolean | null
    message: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
    verifiedBy: string | null
    createdAt: Date | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    rolePackageId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    isPaused: boolean | null
    isExpired: boolean | null
    message: string | null
    isVerified: boolean | null
    verifiedAt: Date | null
    verifiedBy: string | null
    createdAt: Date | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    userId: number
    rolePackageId: number
    startDate: number
    endDate: number
    isActive: number
    isPaused: number
    isExpired: number
    message: number
    isVerified: number
    verifiedAt: number
    verifiedBy: number
    createdAt: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    id?: true
    userId?: true
    rolePackageId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isPaused?: true
    isExpired?: true
    message?: true
    isVerified?: true
    verifiedAt?: true
    verifiedBy?: true
    createdAt?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    userId?: true
    rolePackageId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isPaused?: true
    isExpired?: true
    message?: true
    isVerified?: true
    verifiedAt?: true
    verifiedBy?: true
    createdAt?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    userId?: true
    rolePackageId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    isPaused?: true
    isExpired?: true
    message?: true
    isVerified?: true
    verifiedAt?: true
    verifiedBy?: true
    createdAt?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: string
    userId: string
    rolePackageId: string
    startDate: Date | null
    endDate: Date | null
    isActive: boolean
    isPaused: boolean
    isExpired: boolean
    message: string | null
    isVerified: boolean
    verifiedAt: Date | null
    verifiedBy: string | null
    createdAt: Date
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rolePackageId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    rolePackage?: boolean | RolePackageDefaultArgs<ExtArgs>
    transactions?: boolean | UserRole$transactionsArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>



  export type UserRoleSelectScalar = {
    id?: boolean
    userId?: boolean
    rolePackageId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: boolean
    isVerified?: boolean
    verifiedAt?: boolean
    verifiedBy?: boolean
    createdAt?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "rolePackageId" | "startDate" | "endDate" | "isActive" | "isPaused" | "isExpired" | "message" | "isVerified" | "verifiedAt" | "verifiedBy" | "createdAt", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    rolePackage?: boolean | RolePackageDefaultArgs<ExtArgs>
    transactions?: boolean | UserRole$transactionsArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      rolePackage: Prisma.$RolePackagePayload<ExtArgs>
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      rolePackageId: string
      startDate: Date | null
      endDate: Date | null
      isActive: boolean
      isPaused: boolean
      isExpired: boolean
      message: string | null
      isVerified: boolean
      verifiedAt: Date | null
      verifiedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * @param {UserRoleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userRole = await prisma.userRole.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserRoleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserRole.
     * @param {UserRoleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userRole = await prisma.userRole.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserRoleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rolePackage<T extends RolePackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolePackageDefaultArgs<ExtArgs>>): Prisma__RolePackageClient<$Result.GetResult<Prisma.$RolePackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends UserRole$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'String'>
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly rolePackageId: FieldRef<"UserRole", 'String'>
    readonly startDate: FieldRef<"UserRole", 'DateTime'>
    readonly endDate: FieldRef<"UserRole", 'DateTime'>
    readonly isActive: FieldRef<"UserRole", 'Boolean'>
    readonly isPaused: FieldRef<"UserRole", 'Boolean'>
    readonly isExpired: FieldRef<"UserRole", 'Boolean'>
    readonly message: FieldRef<"UserRole", 'String'>
    readonly isVerified: FieldRef<"UserRole", 'Boolean'>
    readonly verifiedAt: FieldRef<"UserRole", 'DateTime'>
    readonly verifiedBy: FieldRef<"UserRole", 'String'>
    readonly createdAt: FieldRef<"UserRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole findRaw
   */
  export type UserRoleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserRole aggregateRaw
   */
  export type UserRoleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserRole.transactions
   */
  export type UserRole$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userRoleId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    method: string | null
    stripeId: string | null
    invoiceUrl: string | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userRoleId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    method: string | null
    stripeId: string | null
    invoiceUrl: string | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    userRoleId: number
    amount: number
    currency: number
    status: number
    method: number
    stripeId: number
    invoiceUrl: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    userRoleId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    stripeId?: true
    invoiceUrl?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    userRoleId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    stripeId?: true
    invoiceUrl?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    userRoleId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    stripeId?: true
    invoiceUrl?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    userRoleId: string
    amount: number
    currency: string
    status: string
    method: string | null
    stripeId: string
    invoiceUrl: string | null
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userRoleId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    stripeId?: boolean
    invoiceUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    userRole?: boolean | UserRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>



  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    userRoleId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    stripeId?: boolean
    invoiceUrl?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userRoleId" | "amount" | "currency" | "status" | "method" | "stripeId" | "invoiceUrl" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    userRole?: boolean | UserRoleDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      userRole: Prisma.$UserRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userRoleId: string
      amount: number
      currency: string
      status: string
      method: string | null
      stripeId: string
      invoiceUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * @param {TransactionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const transaction = await prisma.transaction.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TransactionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Transaction.
     * @param {TransactionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const transaction = await prisma.transaction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TransactionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userRole<T extends UserRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserRoleDefaultArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly userRoleId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly method: FieldRef<"Transaction", 'String'>
    readonly stripeId: FieldRef<"Transaction", 'String'>
    readonly invoiceUrl: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction findRaw
   */
  export type TransactionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Transaction aggregateRaw
   */
  export type TransactionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceInfo: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceInfo: string | null
    isActive: boolean | null
    lastUsedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    deviceInfo: number
    isActive: number
    lastUsedAt: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    isActive?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    isActive?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    isActive?: true
    lastUsedAt?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    deviceInfo: string
    isActive: boolean
    lastUsedAt: Date | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>



  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    isActive?: boolean
    lastUsedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "deviceInfo" | "isActive" | "lastUsedAt" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      deviceInfo: string
      isActive: boolean
      lastUsedAt: Date | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly deviceInfo: FieldRef<"Session", 'String'>
    readonly isActive: FieldRef<"Session", 'Boolean'>
    readonly lastUsedAt: FieldRef<"Session", 'DateTime'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    reviewerId: string | null
    targetUserId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    reviewerId: string | null
    targetUserId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    reviewerId: number
    targetUserId: number
    rating: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    reviewerId?: true
    targetUserId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    reviewerId?: true
    targetUserId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    reviewerId?: true
    targetUserId?: true
    rating?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    reviewerId: string
    targetUserId: string
    rating: number
    comment: string
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewerId?: boolean
    targetUserId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>



  export type ReviewSelectScalar = {
    id?: boolean
    reviewerId?: boolean
    targetUserId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewerId" | "targetUserId" | "rating" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    targetUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      reviewer: Prisma.$UserPayload<ExtArgs>
      targetUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewerId: string
      targetUserId: string
      rating: number
      comment: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * @param {ReviewFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const review = await prisma.review.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ReviewFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Review.
     * @param {ReviewAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const review = await prisma.review.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReviewAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly reviewerId: FieldRef<"Review", 'String'>
    readonly targetUserId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review findRaw
   */
  export type ReviewFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Review aggregateRaw
   */
  export type ReviewAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model HeroBanner
   */

  export type AggregateHeroBanner = {
    _count: HeroBannerCountAggregateOutputType | null
    _min: HeroBannerMinAggregateOutputType | null
    _max: HeroBannerMaxAggregateOutputType | null
  }

  export type HeroBannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroBannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HeroBannerCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    imagePublicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HeroBannerMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroBannerMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HeroBannerCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HeroBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBanner to aggregate.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HeroBanners
    **/
    _count?: true | HeroBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HeroBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HeroBannerMaxAggregateInputType
  }

  export type GetHeroBannerAggregateType<T extends HeroBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateHeroBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHeroBanner[P]>
      : GetScalarType<T[P], AggregateHeroBanner[P]>
  }




  export type HeroBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HeroBannerWhereInput
    orderBy?: HeroBannerOrderByWithAggregationInput | HeroBannerOrderByWithAggregationInput[]
    by: HeroBannerScalarFieldEnum[] | HeroBannerScalarFieldEnum
    having?: HeroBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HeroBannerCountAggregateInputType | true
    _min?: HeroBannerMinAggregateInputType
    _max?: HeroBannerMaxAggregateInputType
  }

  export type HeroBannerGroupByOutputType = {
    id: string
    title: string
    description: string
    image: string
    imagePublicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: HeroBannerCountAggregateOutputType | null
    _min: HeroBannerMinAggregateOutputType | null
    _max: HeroBannerMaxAggregateOutputType | null
  }

  type GetHeroBannerGroupByPayload<T extends HeroBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HeroBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HeroBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HeroBannerGroupByOutputType[P]>
            : GetScalarType<T[P], HeroBannerGroupByOutputType[P]>
        }
      >
    >


  export type HeroBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["heroBanner"]>



  export type HeroBannerSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HeroBannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "image" | "imagePublicId" | "createdAt" | "updatedAt", ExtArgs["result"]["heroBanner"]>

  export type $HeroBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HeroBanner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      image: string
      imagePublicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["heroBanner"]>
    composites: {}
  }

  type HeroBannerGetPayload<S extends boolean | null | undefined | HeroBannerDefaultArgs> = $Result.GetResult<Prisma.$HeroBannerPayload, S>

  type HeroBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HeroBannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HeroBannerCountAggregateInputType | true
    }

  export interface HeroBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HeroBanner'], meta: { name: 'HeroBanner' } }
    /**
     * Find zero or one HeroBanner that matches the filter.
     * @param {HeroBannerFindUniqueArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HeroBannerFindUniqueArgs>(args: SelectSubset<T, HeroBannerFindUniqueArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HeroBanner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HeroBannerFindUniqueOrThrowArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HeroBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, HeroBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerFindFirstArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HeroBannerFindFirstArgs>(args?: SelectSubset<T, HeroBannerFindFirstArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HeroBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerFindFirstOrThrowArgs} args - Arguments to find a HeroBanner
     * @example
     * // Get one HeroBanner
     * const heroBanner = await prisma.heroBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HeroBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, HeroBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HeroBanners
     * const heroBanners = await prisma.heroBanner.findMany()
     * 
     * // Get first 10 HeroBanners
     * const heroBanners = await prisma.heroBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const heroBannerWithIdOnly = await prisma.heroBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HeroBannerFindManyArgs>(args?: SelectSubset<T, HeroBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HeroBanner.
     * @param {HeroBannerCreateArgs} args - Arguments to create a HeroBanner.
     * @example
     * // Create one HeroBanner
     * const HeroBanner = await prisma.heroBanner.create({
     *   data: {
     *     // ... data to create a HeroBanner
     *   }
     * })
     * 
     */
    create<T extends HeroBannerCreateArgs>(args: SelectSubset<T, HeroBannerCreateArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HeroBanners.
     * @param {HeroBannerCreateManyArgs} args - Arguments to create many HeroBanners.
     * @example
     * // Create many HeroBanners
     * const heroBanner = await prisma.heroBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HeroBannerCreateManyArgs>(args?: SelectSubset<T, HeroBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HeroBanner.
     * @param {HeroBannerDeleteArgs} args - Arguments to delete one HeroBanner.
     * @example
     * // Delete one HeroBanner
     * const HeroBanner = await prisma.heroBanner.delete({
     *   where: {
     *     // ... filter to delete one HeroBanner
     *   }
     * })
     * 
     */
    delete<T extends HeroBannerDeleteArgs>(args: SelectSubset<T, HeroBannerDeleteArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HeroBanner.
     * @param {HeroBannerUpdateArgs} args - Arguments to update one HeroBanner.
     * @example
     * // Update one HeroBanner
     * const heroBanner = await prisma.heroBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HeroBannerUpdateArgs>(args: SelectSubset<T, HeroBannerUpdateArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HeroBanners.
     * @param {HeroBannerDeleteManyArgs} args - Arguments to filter HeroBanners to delete.
     * @example
     * // Delete a few HeroBanners
     * const { count } = await prisma.heroBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HeroBannerDeleteManyArgs>(args?: SelectSubset<T, HeroBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HeroBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HeroBanners
     * const heroBanner = await prisma.heroBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HeroBannerUpdateManyArgs>(args: SelectSubset<T, HeroBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HeroBanner.
     * @param {HeroBannerUpsertArgs} args - Arguments to update or create a HeroBanner.
     * @example
     * // Update or create a HeroBanner
     * const heroBanner = await prisma.heroBanner.upsert({
     *   create: {
     *     // ... data to create a HeroBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HeroBanner we want to update
     *   }
     * })
     */
    upsert<T extends HeroBannerUpsertArgs>(args: SelectSubset<T, HeroBannerUpsertArgs<ExtArgs>>): Prisma__HeroBannerClient<$Result.GetResult<Prisma.$HeroBannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HeroBanners that matches the filter.
     * @param {HeroBannerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const heroBanner = await prisma.heroBanner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: HeroBannerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a HeroBanner.
     * @param {HeroBannerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const heroBanner = await prisma.heroBanner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: HeroBannerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of HeroBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerCountArgs} args - Arguments to filter HeroBanners to count.
     * @example
     * // Count the number of HeroBanners
     * const count = await prisma.heroBanner.count({
     *   where: {
     *     // ... the filter for the HeroBanners we want to count
     *   }
     * })
    **/
    count<T extends HeroBannerCountArgs>(
      args?: Subset<T, HeroBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HeroBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HeroBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HeroBannerAggregateArgs>(args: Subset<T, HeroBannerAggregateArgs>): Prisma.PrismaPromise<GetHeroBannerAggregateType<T>>

    /**
     * Group by HeroBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HeroBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HeroBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HeroBannerGroupByArgs['orderBy'] }
        : { orderBy?: HeroBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HeroBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHeroBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HeroBanner model
   */
  readonly fields: HeroBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HeroBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HeroBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HeroBanner model
   */
  interface HeroBannerFieldRefs {
    readonly id: FieldRef<"HeroBanner", 'String'>
    readonly title: FieldRef<"HeroBanner", 'String'>
    readonly description: FieldRef<"HeroBanner", 'String'>
    readonly image: FieldRef<"HeroBanner", 'String'>
    readonly imagePublicId: FieldRef<"HeroBanner", 'String'>
    readonly createdAt: FieldRef<"HeroBanner", 'DateTime'>
    readonly updatedAt: FieldRef<"HeroBanner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HeroBanner findUnique
   */
  export type HeroBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner findUniqueOrThrow
   */
  export type HeroBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner findFirst
   */
  export type HeroBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBanners.
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBanners.
     */
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * HeroBanner findFirstOrThrow
   */
  export type HeroBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Filter, which HeroBanner to fetch.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HeroBanners.
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HeroBanners.
     */
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * HeroBanner findMany
   */
  export type HeroBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Filter, which HeroBanners to fetch.
     */
    where?: HeroBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HeroBanners to fetch.
     */
    orderBy?: HeroBannerOrderByWithRelationInput | HeroBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HeroBanners.
     */
    cursor?: HeroBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HeroBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HeroBanners.
     */
    skip?: number
    distinct?: HeroBannerScalarFieldEnum | HeroBannerScalarFieldEnum[]
  }

  /**
   * HeroBanner create
   */
  export type HeroBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * The data needed to create a HeroBanner.
     */
    data: XOR<HeroBannerCreateInput, HeroBannerUncheckedCreateInput>
  }

  /**
   * HeroBanner createMany
   */
  export type HeroBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HeroBanners.
     */
    data: HeroBannerCreateManyInput | HeroBannerCreateManyInput[]
  }

  /**
   * HeroBanner update
   */
  export type HeroBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * The data needed to update a HeroBanner.
     */
    data: XOR<HeroBannerUpdateInput, HeroBannerUncheckedUpdateInput>
    /**
     * Choose, which HeroBanner to update.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner updateMany
   */
  export type HeroBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HeroBanners.
     */
    data: XOR<HeroBannerUpdateManyMutationInput, HeroBannerUncheckedUpdateManyInput>
    /**
     * Filter which HeroBanners to update
     */
    where?: HeroBannerWhereInput
    /**
     * Limit how many HeroBanners to update.
     */
    limit?: number
  }

  /**
   * HeroBanner upsert
   */
  export type HeroBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * The filter to search for the HeroBanner to update in case it exists.
     */
    where: HeroBannerWhereUniqueInput
    /**
     * In case the HeroBanner found by the `where` argument doesn't exist, create a new HeroBanner with this data.
     */
    create: XOR<HeroBannerCreateInput, HeroBannerUncheckedCreateInput>
    /**
     * In case the HeroBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HeroBannerUpdateInput, HeroBannerUncheckedUpdateInput>
  }

  /**
   * HeroBanner delete
   */
  export type HeroBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
    /**
     * Filter which HeroBanner to delete.
     */
    where: HeroBannerWhereUniqueInput
  }

  /**
   * HeroBanner deleteMany
   */
  export type HeroBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HeroBanners to delete
     */
    where?: HeroBannerWhereInput
    /**
     * Limit how many HeroBanners to delete.
     */
    limit?: number
  }

  /**
   * HeroBanner findRaw
   */
  export type HeroBannerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * HeroBanner aggregateRaw
   */
  export type HeroBannerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * HeroBanner without action
   */
  export type HeroBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HeroBanner
     */
    select?: HeroBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HeroBanner
     */
    omit?: HeroBannerOmit<ExtArgs> | null
  }


  /**
   * Model MarketTrends
   */

  export type AggregateMarketTrends = {
    _count: MarketTrendsCountAggregateOutputType | null
    _avg: MarketTrendsAvgAggregateOutputType | null
    _sum: MarketTrendsSumAggregateOutputType | null
    _min: MarketTrendsMinAggregateOutputType | null
    _max: MarketTrendsMaxAggregateOutputType | null
  }

  export type MarketTrendsAvgAggregateOutputType = {
    price: number | null
    day: number | null
  }

  export type MarketTrendsSumAggregateOutputType = {
    price: number | null
    day: number | null
  }

  export type MarketTrendsMinAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    day: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketTrendsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    price: number | null
    day: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketTrendsCountAggregateOutputType = {
    id: number
    name: number
    price: number
    day: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketTrendsAvgAggregateInputType = {
    price?: true
    day?: true
  }

  export type MarketTrendsSumAggregateInputType = {
    price?: true
    day?: true
  }

  export type MarketTrendsMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    day?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketTrendsMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    day?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketTrendsCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    day?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketTrendsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTrends to aggregate.
     */
    where?: MarketTrendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendsOrderByWithRelationInput | MarketTrendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketTrendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketTrends
    **/
    _count?: true | MarketTrendsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketTrendsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketTrendsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketTrendsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketTrendsMaxAggregateInputType
  }

  export type GetMarketTrendsAggregateType<T extends MarketTrendsAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketTrends]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketTrends[P]>
      : GetScalarType<T[P], AggregateMarketTrends[P]>
  }




  export type MarketTrendsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketTrendsWhereInput
    orderBy?: MarketTrendsOrderByWithAggregationInput | MarketTrendsOrderByWithAggregationInput[]
    by: MarketTrendsScalarFieldEnum[] | MarketTrendsScalarFieldEnum
    having?: MarketTrendsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketTrendsCountAggregateInputType | true
    _avg?: MarketTrendsAvgAggregateInputType
    _sum?: MarketTrendsSumAggregateInputType
    _min?: MarketTrendsMinAggregateInputType
    _max?: MarketTrendsMaxAggregateInputType
  }

  export type MarketTrendsGroupByOutputType = {
    id: string
    name: string
    price: number
    day: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: MarketTrendsCountAggregateOutputType | null
    _avg: MarketTrendsAvgAggregateOutputType | null
    _sum: MarketTrendsSumAggregateOutputType | null
    _min: MarketTrendsMinAggregateOutputType | null
    _max: MarketTrendsMaxAggregateOutputType | null
  }

  type GetMarketTrendsGroupByPayload<T extends MarketTrendsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketTrendsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketTrendsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketTrendsGroupByOutputType[P]>
            : GetScalarType<T[P], MarketTrendsGroupByOutputType[P]>
        }
      >
    >


  export type MarketTrendsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    day?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketTrends"]>



  export type MarketTrendsSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    day?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketTrendsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "day" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["marketTrends"]>

  export type $MarketTrendsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketTrends"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      price: number
      day: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketTrends"]>
    composites: {}
  }

  type MarketTrendsGetPayload<S extends boolean | null | undefined | MarketTrendsDefaultArgs> = $Result.GetResult<Prisma.$MarketTrendsPayload, S>

  type MarketTrendsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketTrendsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketTrendsCountAggregateInputType | true
    }

  export interface MarketTrendsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketTrends'], meta: { name: 'MarketTrends' } }
    /**
     * Find zero or one MarketTrends that matches the filter.
     * @param {MarketTrendsFindUniqueArgs} args - Arguments to find a MarketTrends
     * @example
     * // Get one MarketTrends
     * const marketTrends = await prisma.marketTrends.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketTrendsFindUniqueArgs>(args: SelectSubset<T, MarketTrendsFindUniqueArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketTrends that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketTrendsFindUniqueOrThrowArgs} args - Arguments to find a MarketTrends
     * @example
     * // Get one MarketTrends
     * const marketTrends = await prisma.marketTrends.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketTrendsFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketTrendsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketTrends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsFindFirstArgs} args - Arguments to find a MarketTrends
     * @example
     * // Get one MarketTrends
     * const marketTrends = await prisma.marketTrends.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketTrendsFindFirstArgs>(args?: SelectSubset<T, MarketTrendsFindFirstArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketTrends that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsFindFirstOrThrowArgs} args - Arguments to find a MarketTrends
     * @example
     * // Get one MarketTrends
     * const marketTrends = await prisma.marketTrends.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketTrendsFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketTrendsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketTrends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketTrends
     * const marketTrends = await prisma.marketTrends.findMany()
     * 
     * // Get first 10 MarketTrends
     * const marketTrends = await prisma.marketTrends.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketTrendsWithIdOnly = await prisma.marketTrends.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketTrendsFindManyArgs>(args?: SelectSubset<T, MarketTrendsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketTrends.
     * @param {MarketTrendsCreateArgs} args - Arguments to create a MarketTrends.
     * @example
     * // Create one MarketTrends
     * const MarketTrends = await prisma.marketTrends.create({
     *   data: {
     *     // ... data to create a MarketTrends
     *   }
     * })
     * 
     */
    create<T extends MarketTrendsCreateArgs>(args: SelectSubset<T, MarketTrendsCreateArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketTrends.
     * @param {MarketTrendsCreateManyArgs} args - Arguments to create many MarketTrends.
     * @example
     * // Create many MarketTrends
     * const marketTrends = await prisma.marketTrends.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketTrendsCreateManyArgs>(args?: SelectSubset<T, MarketTrendsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketTrends.
     * @param {MarketTrendsDeleteArgs} args - Arguments to delete one MarketTrends.
     * @example
     * // Delete one MarketTrends
     * const MarketTrends = await prisma.marketTrends.delete({
     *   where: {
     *     // ... filter to delete one MarketTrends
     *   }
     * })
     * 
     */
    delete<T extends MarketTrendsDeleteArgs>(args: SelectSubset<T, MarketTrendsDeleteArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketTrends.
     * @param {MarketTrendsUpdateArgs} args - Arguments to update one MarketTrends.
     * @example
     * // Update one MarketTrends
     * const marketTrends = await prisma.marketTrends.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketTrendsUpdateArgs>(args: SelectSubset<T, MarketTrendsUpdateArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketTrends.
     * @param {MarketTrendsDeleteManyArgs} args - Arguments to filter MarketTrends to delete.
     * @example
     * // Delete a few MarketTrends
     * const { count } = await prisma.marketTrends.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketTrendsDeleteManyArgs>(args?: SelectSubset<T, MarketTrendsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketTrends
     * const marketTrends = await prisma.marketTrends.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketTrendsUpdateManyArgs>(args: SelectSubset<T, MarketTrendsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketTrends.
     * @param {MarketTrendsUpsertArgs} args - Arguments to update or create a MarketTrends.
     * @example
     * // Update or create a MarketTrends
     * const marketTrends = await prisma.marketTrends.upsert({
     *   create: {
     *     // ... data to create a MarketTrends
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketTrends we want to update
     *   }
     * })
     */
    upsert<T extends MarketTrendsUpsertArgs>(args: SelectSubset<T, MarketTrendsUpsertArgs<ExtArgs>>): Prisma__MarketTrendsClient<$Result.GetResult<Prisma.$MarketTrendsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketTrends that matches the filter.
     * @param {MarketTrendsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const marketTrends = await prisma.marketTrends.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MarketTrendsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MarketTrends.
     * @param {MarketTrendsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const marketTrends = await prisma.marketTrends.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MarketTrendsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MarketTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsCountArgs} args - Arguments to filter MarketTrends to count.
     * @example
     * // Count the number of MarketTrends
     * const count = await prisma.marketTrends.count({
     *   where: {
     *     // ... the filter for the MarketTrends we want to count
     *   }
     * })
    **/
    count<T extends MarketTrendsCountArgs>(
      args?: Subset<T, MarketTrendsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketTrendsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketTrendsAggregateArgs>(args: Subset<T, MarketTrendsAggregateArgs>): Prisma.PrismaPromise<GetMarketTrendsAggregateType<T>>

    /**
     * Group by MarketTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketTrendsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketTrendsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketTrendsGroupByArgs['orderBy'] }
        : { orderBy?: MarketTrendsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketTrendsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketTrendsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketTrends model
   */
  readonly fields: MarketTrendsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketTrends.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketTrendsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketTrends model
   */
  interface MarketTrendsFieldRefs {
    readonly id: FieldRef<"MarketTrends", 'String'>
    readonly name: FieldRef<"MarketTrends", 'String'>
    readonly price: FieldRef<"MarketTrends", 'Float'>
    readonly day: FieldRef<"MarketTrends", 'Int'>
    readonly status: FieldRef<"MarketTrends", 'String'>
    readonly createdAt: FieldRef<"MarketTrends", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketTrends", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketTrends findUnique
   */
  export type MarketTrendsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * Filter, which MarketTrends to fetch.
     */
    where: MarketTrendsWhereUniqueInput
  }

  /**
   * MarketTrends findUniqueOrThrow
   */
  export type MarketTrendsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * Filter, which MarketTrends to fetch.
     */
    where: MarketTrendsWhereUniqueInput
  }

  /**
   * MarketTrends findFirst
   */
  export type MarketTrendsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * Filter, which MarketTrends to fetch.
     */
    where?: MarketTrendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendsOrderByWithRelationInput | MarketTrendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTrends.
     */
    cursor?: MarketTrendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTrends.
     */
    distinct?: MarketTrendsScalarFieldEnum | MarketTrendsScalarFieldEnum[]
  }

  /**
   * MarketTrends findFirstOrThrow
   */
  export type MarketTrendsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * Filter, which MarketTrends to fetch.
     */
    where?: MarketTrendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendsOrderByWithRelationInput | MarketTrendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketTrends.
     */
    cursor?: MarketTrendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketTrends.
     */
    distinct?: MarketTrendsScalarFieldEnum | MarketTrendsScalarFieldEnum[]
  }

  /**
   * MarketTrends findMany
   */
  export type MarketTrendsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * Filter, which MarketTrends to fetch.
     */
    where?: MarketTrendsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketTrends to fetch.
     */
    orderBy?: MarketTrendsOrderByWithRelationInput | MarketTrendsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketTrends.
     */
    cursor?: MarketTrendsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketTrends.
     */
    skip?: number
    distinct?: MarketTrendsScalarFieldEnum | MarketTrendsScalarFieldEnum[]
  }

  /**
   * MarketTrends create
   */
  export type MarketTrendsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketTrends.
     */
    data: XOR<MarketTrendsCreateInput, MarketTrendsUncheckedCreateInput>
  }

  /**
   * MarketTrends createMany
   */
  export type MarketTrendsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketTrends.
     */
    data: MarketTrendsCreateManyInput | MarketTrendsCreateManyInput[]
  }

  /**
   * MarketTrends update
   */
  export type MarketTrendsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketTrends.
     */
    data: XOR<MarketTrendsUpdateInput, MarketTrendsUncheckedUpdateInput>
    /**
     * Choose, which MarketTrends to update.
     */
    where: MarketTrendsWhereUniqueInput
  }

  /**
   * MarketTrends updateMany
   */
  export type MarketTrendsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketTrends.
     */
    data: XOR<MarketTrendsUpdateManyMutationInput, MarketTrendsUncheckedUpdateManyInput>
    /**
     * Filter which MarketTrends to update
     */
    where?: MarketTrendsWhereInput
    /**
     * Limit how many MarketTrends to update.
     */
    limit?: number
  }

  /**
   * MarketTrends upsert
   */
  export type MarketTrendsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketTrends to update in case it exists.
     */
    where: MarketTrendsWhereUniqueInput
    /**
     * In case the MarketTrends found by the `where` argument doesn't exist, create a new MarketTrends with this data.
     */
    create: XOR<MarketTrendsCreateInput, MarketTrendsUncheckedCreateInput>
    /**
     * In case the MarketTrends was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketTrendsUpdateInput, MarketTrendsUncheckedUpdateInput>
  }

  /**
   * MarketTrends delete
   */
  export type MarketTrendsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
    /**
     * Filter which MarketTrends to delete.
     */
    where: MarketTrendsWhereUniqueInput
  }

  /**
   * MarketTrends deleteMany
   */
  export type MarketTrendsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketTrends to delete
     */
    where?: MarketTrendsWhereInput
    /**
     * Limit how many MarketTrends to delete.
     */
    limit?: number
  }

  /**
   * MarketTrends findRaw
   */
  export type MarketTrendsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketTrends aggregateRaw
   */
  export type MarketTrendsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketTrends without action
   */
  export type MarketTrendsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketTrends
     */
    select?: MarketTrendsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketTrends
     */
    omit?: MarketTrendsOmit<ExtArgs> | null
  }


  /**
   * Model MortageTools
   */

  export type AggregateMortageTools = {
    _count: MortageToolsCountAggregateOutputType | null
    _min: MortageToolsMinAggregateOutputType | null
    _max: MortageToolsMaxAggregateOutputType | null
  }

  export type MortageToolsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ctaName: string | null
    ctaLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MortageToolsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ctaName: string | null
    ctaLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MortageToolsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ctaName: number
    ctaLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MortageToolsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ctaName?: true
    ctaLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MortageToolsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ctaName?: true
    ctaLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MortageToolsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ctaName?: true
    ctaLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MortageToolsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MortageTools to aggregate.
     */
    where?: MortageToolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MortageTools to fetch.
     */
    orderBy?: MortageToolsOrderByWithRelationInput | MortageToolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MortageToolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MortageTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MortageTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MortageTools
    **/
    _count?: true | MortageToolsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MortageToolsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MortageToolsMaxAggregateInputType
  }

  export type GetMortageToolsAggregateType<T extends MortageToolsAggregateArgs> = {
        [P in keyof T & keyof AggregateMortageTools]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMortageTools[P]>
      : GetScalarType<T[P], AggregateMortageTools[P]>
  }




  export type MortageToolsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MortageToolsWhereInput
    orderBy?: MortageToolsOrderByWithAggregationInput | MortageToolsOrderByWithAggregationInput[]
    by: MortageToolsScalarFieldEnum[] | MortageToolsScalarFieldEnum
    having?: MortageToolsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MortageToolsCountAggregateInputType | true
    _min?: MortageToolsMinAggregateInputType
    _max?: MortageToolsMaxAggregateInputType
  }

  export type MortageToolsGroupByOutputType = {
    id: string
    name: string
    description: string
    ctaName: string
    ctaLink: string
    createdAt: Date
    updatedAt: Date
    _count: MortageToolsCountAggregateOutputType | null
    _min: MortageToolsMinAggregateOutputType | null
    _max: MortageToolsMaxAggregateOutputType | null
  }

  type GetMortageToolsGroupByPayload<T extends MortageToolsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MortageToolsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MortageToolsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MortageToolsGroupByOutputType[P]>
            : GetScalarType<T[P], MortageToolsGroupByOutputType[P]>
        }
      >
    >


  export type MortageToolsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ctaName?: boolean
    ctaLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mortageTools"]>



  export type MortageToolsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ctaName?: boolean
    ctaLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MortageToolsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ctaName" | "ctaLink" | "createdAt" | "updatedAt", ExtArgs["result"]["mortageTools"]>

  export type $MortageToolsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MortageTools"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      ctaName: string
      ctaLink: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mortageTools"]>
    composites: {}
  }

  type MortageToolsGetPayload<S extends boolean | null | undefined | MortageToolsDefaultArgs> = $Result.GetResult<Prisma.$MortageToolsPayload, S>

  type MortageToolsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MortageToolsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MortageToolsCountAggregateInputType | true
    }

  export interface MortageToolsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MortageTools'], meta: { name: 'MortageTools' } }
    /**
     * Find zero or one MortageTools that matches the filter.
     * @param {MortageToolsFindUniqueArgs} args - Arguments to find a MortageTools
     * @example
     * // Get one MortageTools
     * const mortageTools = await prisma.mortageTools.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MortageToolsFindUniqueArgs>(args: SelectSubset<T, MortageToolsFindUniqueArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MortageTools that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MortageToolsFindUniqueOrThrowArgs} args - Arguments to find a MortageTools
     * @example
     * // Get one MortageTools
     * const mortageTools = await prisma.mortageTools.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MortageToolsFindUniqueOrThrowArgs>(args: SelectSubset<T, MortageToolsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MortageTools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsFindFirstArgs} args - Arguments to find a MortageTools
     * @example
     * // Get one MortageTools
     * const mortageTools = await prisma.mortageTools.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MortageToolsFindFirstArgs>(args?: SelectSubset<T, MortageToolsFindFirstArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MortageTools that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsFindFirstOrThrowArgs} args - Arguments to find a MortageTools
     * @example
     * // Get one MortageTools
     * const mortageTools = await prisma.mortageTools.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MortageToolsFindFirstOrThrowArgs>(args?: SelectSubset<T, MortageToolsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MortageTools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MortageTools
     * const mortageTools = await prisma.mortageTools.findMany()
     * 
     * // Get first 10 MortageTools
     * const mortageTools = await prisma.mortageTools.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mortageToolsWithIdOnly = await prisma.mortageTools.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MortageToolsFindManyArgs>(args?: SelectSubset<T, MortageToolsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MortageTools.
     * @param {MortageToolsCreateArgs} args - Arguments to create a MortageTools.
     * @example
     * // Create one MortageTools
     * const MortageTools = await prisma.mortageTools.create({
     *   data: {
     *     // ... data to create a MortageTools
     *   }
     * })
     * 
     */
    create<T extends MortageToolsCreateArgs>(args: SelectSubset<T, MortageToolsCreateArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MortageTools.
     * @param {MortageToolsCreateManyArgs} args - Arguments to create many MortageTools.
     * @example
     * // Create many MortageTools
     * const mortageTools = await prisma.mortageTools.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MortageToolsCreateManyArgs>(args?: SelectSubset<T, MortageToolsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MortageTools.
     * @param {MortageToolsDeleteArgs} args - Arguments to delete one MortageTools.
     * @example
     * // Delete one MortageTools
     * const MortageTools = await prisma.mortageTools.delete({
     *   where: {
     *     // ... filter to delete one MortageTools
     *   }
     * })
     * 
     */
    delete<T extends MortageToolsDeleteArgs>(args: SelectSubset<T, MortageToolsDeleteArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MortageTools.
     * @param {MortageToolsUpdateArgs} args - Arguments to update one MortageTools.
     * @example
     * // Update one MortageTools
     * const mortageTools = await prisma.mortageTools.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MortageToolsUpdateArgs>(args: SelectSubset<T, MortageToolsUpdateArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MortageTools.
     * @param {MortageToolsDeleteManyArgs} args - Arguments to filter MortageTools to delete.
     * @example
     * // Delete a few MortageTools
     * const { count } = await prisma.mortageTools.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MortageToolsDeleteManyArgs>(args?: SelectSubset<T, MortageToolsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MortageTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MortageTools
     * const mortageTools = await prisma.mortageTools.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MortageToolsUpdateManyArgs>(args: SelectSubset<T, MortageToolsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MortageTools.
     * @param {MortageToolsUpsertArgs} args - Arguments to update or create a MortageTools.
     * @example
     * // Update or create a MortageTools
     * const mortageTools = await prisma.mortageTools.upsert({
     *   create: {
     *     // ... data to create a MortageTools
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MortageTools we want to update
     *   }
     * })
     */
    upsert<T extends MortageToolsUpsertArgs>(args: SelectSubset<T, MortageToolsUpsertArgs<ExtArgs>>): Prisma__MortageToolsClient<$Result.GetResult<Prisma.$MortageToolsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MortageTools that matches the filter.
     * @param {MortageToolsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const mortageTools = await prisma.mortageTools.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MortageToolsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MortageTools.
     * @param {MortageToolsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const mortageTools = await prisma.mortageTools.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MortageToolsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MortageTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsCountArgs} args - Arguments to filter MortageTools to count.
     * @example
     * // Count the number of MortageTools
     * const count = await prisma.mortageTools.count({
     *   where: {
     *     // ... the filter for the MortageTools we want to count
     *   }
     * })
    **/
    count<T extends MortageToolsCountArgs>(
      args?: Subset<T, MortageToolsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MortageToolsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MortageTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MortageToolsAggregateArgs>(args: Subset<T, MortageToolsAggregateArgs>): Prisma.PrismaPromise<GetMortageToolsAggregateType<T>>

    /**
     * Group by MortageTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MortageToolsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MortageToolsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MortageToolsGroupByArgs['orderBy'] }
        : { orderBy?: MortageToolsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MortageToolsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMortageToolsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MortageTools model
   */
  readonly fields: MortageToolsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MortageTools.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MortageToolsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MortageTools model
   */
  interface MortageToolsFieldRefs {
    readonly id: FieldRef<"MortageTools", 'String'>
    readonly name: FieldRef<"MortageTools", 'String'>
    readonly description: FieldRef<"MortageTools", 'String'>
    readonly ctaName: FieldRef<"MortageTools", 'String'>
    readonly ctaLink: FieldRef<"MortageTools", 'String'>
    readonly createdAt: FieldRef<"MortageTools", 'DateTime'>
    readonly updatedAt: FieldRef<"MortageTools", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MortageTools findUnique
   */
  export type MortageToolsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * Filter, which MortageTools to fetch.
     */
    where: MortageToolsWhereUniqueInput
  }

  /**
   * MortageTools findUniqueOrThrow
   */
  export type MortageToolsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * Filter, which MortageTools to fetch.
     */
    where: MortageToolsWhereUniqueInput
  }

  /**
   * MortageTools findFirst
   */
  export type MortageToolsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * Filter, which MortageTools to fetch.
     */
    where?: MortageToolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MortageTools to fetch.
     */
    orderBy?: MortageToolsOrderByWithRelationInput | MortageToolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MortageTools.
     */
    cursor?: MortageToolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MortageTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MortageTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MortageTools.
     */
    distinct?: MortageToolsScalarFieldEnum | MortageToolsScalarFieldEnum[]
  }

  /**
   * MortageTools findFirstOrThrow
   */
  export type MortageToolsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * Filter, which MortageTools to fetch.
     */
    where?: MortageToolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MortageTools to fetch.
     */
    orderBy?: MortageToolsOrderByWithRelationInput | MortageToolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MortageTools.
     */
    cursor?: MortageToolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MortageTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MortageTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MortageTools.
     */
    distinct?: MortageToolsScalarFieldEnum | MortageToolsScalarFieldEnum[]
  }

  /**
   * MortageTools findMany
   */
  export type MortageToolsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * Filter, which MortageTools to fetch.
     */
    where?: MortageToolsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MortageTools to fetch.
     */
    orderBy?: MortageToolsOrderByWithRelationInput | MortageToolsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MortageTools.
     */
    cursor?: MortageToolsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MortageTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MortageTools.
     */
    skip?: number
    distinct?: MortageToolsScalarFieldEnum | MortageToolsScalarFieldEnum[]
  }

  /**
   * MortageTools create
   */
  export type MortageToolsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * The data needed to create a MortageTools.
     */
    data: XOR<MortageToolsCreateInput, MortageToolsUncheckedCreateInput>
  }

  /**
   * MortageTools createMany
   */
  export type MortageToolsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MortageTools.
     */
    data: MortageToolsCreateManyInput | MortageToolsCreateManyInput[]
  }

  /**
   * MortageTools update
   */
  export type MortageToolsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * The data needed to update a MortageTools.
     */
    data: XOR<MortageToolsUpdateInput, MortageToolsUncheckedUpdateInput>
    /**
     * Choose, which MortageTools to update.
     */
    where: MortageToolsWhereUniqueInput
  }

  /**
   * MortageTools updateMany
   */
  export type MortageToolsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MortageTools.
     */
    data: XOR<MortageToolsUpdateManyMutationInput, MortageToolsUncheckedUpdateManyInput>
    /**
     * Filter which MortageTools to update
     */
    where?: MortageToolsWhereInput
    /**
     * Limit how many MortageTools to update.
     */
    limit?: number
  }

  /**
   * MortageTools upsert
   */
  export type MortageToolsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * The filter to search for the MortageTools to update in case it exists.
     */
    where: MortageToolsWhereUniqueInput
    /**
     * In case the MortageTools found by the `where` argument doesn't exist, create a new MortageTools with this data.
     */
    create: XOR<MortageToolsCreateInput, MortageToolsUncheckedCreateInput>
    /**
     * In case the MortageTools was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MortageToolsUpdateInput, MortageToolsUncheckedUpdateInput>
  }

  /**
   * MortageTools delete
   */
  export type MortageToolsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
    /**
     * Filter which MortageTools to delete.
     */
    where: MortageToolsWhereUniqueInput
  }

  /**
   * MortageTools deleteMany
   */
  export type MortageToolsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MortageTools to delete
     */
    where?: MortageToolsWhereInput
    /**
     * Limit how many MortageTools to delete.
     */
    limit?: number
  }

  /**
   * MortageTools findRaw
   */
  export type MortageToolsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MortageTools aggregateRaw
   */
  export type MortageToolsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MortageTools without action
   */
  export type MortageToolsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MortageTools
     */
    select?: MortageToolsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MortageTools
     */
    omit?: MortageToolsOmit<ExtArgs> | null
  }


  /**
   * Model PrivacyPolicy
   */

  export type AggregatePrivacyPolicy = {
    _count: PrivacyPolicyCountAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  export type PrivacyPolicyMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyPolicyMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivacyPolicyCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivacyPolicyMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyPolicyMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivacyPolicyCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivacyPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicy to aggregate.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivacyPolicies
    **/
    _count?: true | PrivacyPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivacyPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type GetPrivacyPolicyAggregateType<T extends PrivacyPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivacyPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
      : GetScalarType<T[P], AggregatePrivacyPolicy[P]>
  }




  export type PrivacyPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivacyPolicyWhereInput
    orderBy?: PrivacyPolicyOrderByWithAggregationInput | PrivacyPolicyOrderByWithAggregationInput[]
    by: PrivacyPolicyScalarFieldEnum[] | PrivacyPolicyScalarFieldEnum
    having?: PrivacyPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivacyPolicyCountAggregateInputType | true
    _min?: PrivacyPolicyMinAggregateInputType
    _max?: PrivacyPolicyMaxAggregateInputType
  }

  export type PrivacyPolicyGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: PrivacyPolicyCountAggregateOutputType | null
    _min: PrivacyPolicyMinAggregateOutputType | null
    _max: PrivacyPolicyMaxAggregateOutputType | null
  }

  type GetPrivacyPolicyGroupByPayload<T extends PrivacyPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivacyPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivacyPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], PrivacyPolicyGroupByOutputType[P]>
        }
      >
    >


  export type PrivacyPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["privacyPolicy"]>



  export type PrivacyPolicySelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivacyPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["privacyPolicy"]>

  export type $PrivacyPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivacyPolicy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privacyPolicy"]>
    composites: {}
  }

  type PrivacyPolicyGetPayload<S extends boolean | null | undefined | PrivacyPolicyDefaultArgs> = $Result.GetResult<Prisma.$PrivacyPolicyPayload, S>

  type PrivacyPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivacyPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivacyPolicyCountAggregateInputType | true
    }

  export interface PrivacyPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivacyPolicy'], meta: { name: 'PrivacyPolicy' } }
    /**
     * Find zero or one PrivacyPolicy that matches the filter.
     * @param {PrivacyPolicyFindUniqueArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivacyPolicyFindUniqueArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivacyPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivacyPolicyFindUniqueOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivacyPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivacyPolicyFindFirstArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivacyPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindFirstOrThrowArgs} args - Arguments to find a PrivacyPolicy
     * @example
     * // Get one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivacyPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivacyPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivacyPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany()
     * 
     * // Get first 10 PrivacyPolicies
     * const privacyPolicies = await prisma.privacyPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privacyPolicyWithIdOnly = await prisma.privacyPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivacyPolicyFindManyArgs>(args?: SelectSubset<T, PrivacyPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivacyPolicy.
     * @param {PrivacyPolicyCreateArgs} args - Arguments to create a PrivacyPolicy.
     * @example
     * // Create one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.create({
     *   data: {
     *     // ... data to create a PrivacyPolicy
     *   }
     * })
     * 
     */
    create<T extends PrivacyPolicyCreateArgs>(args: SelectSubset<T, PrivacyPolicyCreateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivacyPolicies.
     * @param {PrivacyPolicyCreateManyArgs} args - Arguments to create many PrivacyPolicies.
     * @example
     * // Create many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivacyPolicyCreateManyArgs>(args?: SelectSubset<T, PrivacyPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrivacyPolicy.
     * @param {PrivacyPolicyDeleteArgs} args - Arguments to delete one PrivacyPolicy.
     * @example
     * // Delete one PrivacyPolicy
     * const PrivacyPolicy = await prisma.privacyPolicy.delete({
     *   where: {
     *     // ... filter to delete one PrivacyPolicy
     *   }
     * })
     * 
     */
    delete<T extends PrivacyPolicyDeleteArgs>(args: SelectSubset<T, PrivacyPolicyDeleteArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivacyPolicy.
     * @param {PrivacyPolicyUpdateArgs} args - Arguments to update one PrivacyPolicy.
     * @example
     * // Update one PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivacyPolicyUpdateArgs>(args: SelectSubset<T, PrivacyPolicyUpdateArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivacyPolicies.
     * @param {PrivacyPolicyDeleteManyArgs} args - Arguments to filter PrivacyPolicies to delete.
     * @example
     * // Delete a few PrivacyPolicies
     * const { count } = await prisma.privacyPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivacyPolicyDeleteManyArgs>(args?: SelectSubset<T, PrivacyPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivacyPolicies
     * const privacyPolicy = await prisma.privacyPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivacyPolicyUpdateManyArgs>(args: SelectSubset<T, PrivacyPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrivacyPolicy.
     * @param {PrivacyPolicyUpsertArgs} args - Arguments to update or create a PrivacyPolicy.
     * @example
     * // Update or create a PrivacyPolicy
     * const privacyPolicy = await prisma.privacyPolicy.upsert({
     *   create: {
     *     // ... data to create a PrivacyPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivacyPolicy we want to update
     *   }
     * })
     */
    upsert<T extends PrivacyPolicyUpsertArgs>(args: SelectSubset<T, PrivacyPolicyUpsertArgs<ExtArgs>>): Prisma__PrivacyPolicyClient<$Result.GetResult<Prisma.$PrivacyPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivacyPolicies that matches the filter.
     * @param {PrivacyPolicyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const privacyPolicy = await prisma.privacyPolicy.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PrivacyPolicyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PrivacyPolicy.
     * @param {PrivacyPolicyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const privacyPolicy = await prisma.privacyPolicy.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PrivacyPolicyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PrivacyPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyCountArgs} args - Arguments to filter PrivacyPolicies to count.
     * @example
     * // Count the number of PrivacyPolicies
     * const count = await prisma.privacyPolicy.count({
     *   where: {
     *     // ... the filter for the PrivacyPolicies we want to count
     *   }
     * })
    **/
    count<T extends PrivacyPolicyCountArgs>(
      args?: Subset<T, PrivacyPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivacyPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivacyPolicyAggregateArgs>(args: Subset<T, PrivacyPolicyAggregateArgs>): Prisma.PrismaPromise<GetPrivacyPolicyAggregateType<T>>

    /**
     * Group by PrivacyPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivacyPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivacyPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivacyPolicyGroupByArgs['orderBy'] }
        : { orderBy?: PrivacyPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivacyPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivacyPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivacyPolicy model
   */
  readonly fields: PrivacyPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivacyPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivacyPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivacyPolicy model
   */
  interface PrivacyPolicyFieldRefs {
    readonly id: FieldRef<"PrivacyPolicy", 'String'>
    readonly content: FieldRef<"PrivacyPolicy", 'String'>
    readonly createdAt: FieldRef<"PrivacyPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivacyPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivacyPolicy findUnique
   */
  export type PrivacyPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findUniqueOrThrow
   */
  export type PrivacyPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy findFirst
   */
  export type PrivacyPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findFirstOrThrow
   */
  export type PrivacyPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicy to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivacyPolicies.
     */
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy findMany
   */
  export type PrivacyPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter, which PrivacyPolicies to fetch.
     */
    where?: PrivacyPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivacyPolicies to fetch.
     */
    orderBy?: PrivacyPolicyOrderByWithRelationInput | PrivacyPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivacyPolicies.
     */
    cursor?: PrivacyPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivacyPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivacyPolicies.
     */
    skip?: number
    distinct?: PrivacyPolicyScalarFieldEnum | PrivacyPolicyScalarFieldEnum[]
  }

  /**
   * PrivacyPolicy create
   */
  export type PrivacyPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to create a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
  }

  /**
   * PrivacyPolicy createMany
   */
  export type PrivacyPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivacyPolicies.
     */
    data: PrivacyPolicyCreateManyInput | PrivacyPolicyCreateManyInput[]
  }

  /**
   * PrivacyPolicy update
   */
  export type PrivacyPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The data needed to update a PrivacyPolicy.
     */
    data: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
    /**
     * Choose, which PrivacyPolicy to update.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy updateMany
   */
  export type PrivacyPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivacyPolicies.
     */
    data: XOR<PrivacyPolicyUpdateManyMutationInput, PrivacyPolicyUncheckedUpdateManyInput>
    /**
     * Filter which PrivacyPolicies to update
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to update.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy upsert
   */
  export type PrivacyPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * The filter to search for the PrivacyPolicy to update in case it exists.
     */
    where: PrivacyPolicyWhereUniqueInput
    /**
     * In case the PrivacyPolicy found by the `where` argument doesn't exist, create a new PrivacyPolicy with this data.
     */
    create: XOR<PrivacyPolicyCreateInput, PrivacyPolicyUncheckedCreateInput>
    /**
     * In case the PrivacyPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivacyPolicyUpdateInput, PrivacyPolicyUncheckedUpdateInput>
  }

  /**
   * PrivacyPolicy delete
   */
  export type PrivacyPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
    /**
     * Filter which PrivacyPolicy to delete.
     */
    where: PrivacyPolicyWhereUniqueInput
  }

  /**
   * PrivacyPolicy deleteMany
   */
  export type PrivacyPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivacyPolicies to delete
     */
    where?: PrivacyPolicyWhereInput
    /**
     * Limit how many PrivacyPolicies to delete.
     */
    limit?: number
  }

  /**
   * PrivacyPolicy findRaw
   */
  export type PrivacyPolicyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PrivacyPolicy aggregateRaw
   */
  export type PrivacyPolicyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PrivacyPolicy without action
   */
  export type PrivacyPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivacyPolicy
     */
    select?: PrivacyPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivacyPolicy
     */
    omit?: PrivacyPolicyOmit<ExtArgs> | null
  }


  /**
   * Model TermsOfUse
   */

  export type AggregateTermsOfUse = {
    _count: TermsOfUseCountAggregateOutputType | null
    _min: TermsOfUseMinAggregateOutputType | null
    _max: TermsOfUseMaxAggregateOutputType | null
  }

  export type TermsOfUseMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsOfUseMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TermsOfUseCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TermsOfUseMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsOfUseMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TermsOfUseCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TermsOfUseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsOfUse to aggregate.
     */
    where?: TermsOfUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsOfUses to fetch.
     */
    orderBy?: TermsOfUseOrderByWithRelationInput | TermsOfUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermsOfUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsOfUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsOfUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TermsOfUses
    **/
    _count?: true | TermsOfUseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermsOfUseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermsOfUseMaxAggregateInputType
  }

  export type GetTermsOfUseAggregateType<T extends TermsOfUseAggregateArgs> = {
        [P in keyof T & keyof AggregateTermsOfUse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermsOfUse[P]>
      : GetScalarType<T[P], AggregateTermsOfUse[P]>
  }




  export type TermsOfUseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermsOfUseWhereInput
    orderBy?: TermsOfUseOrderByWithAggregationInput | TermsOfUseOrderByWithAggregationInput[]
    by: TermsOfUseScalarFieldEnum[] | TermsOfUseScalarFieldEnum
    having?: TermsOfUseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermsOfUseCountAggregateInputType | true
    _min?: TermsOfUseMinAggregateInputType
    _max?: TermsOfUseMaxAggregateInputType
  }

  export type TermsOfUseGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: TermsOfUseCountAggregateOutputType | null
    _min: TermsOfUseMinAggregateOutputType | null
    _max: TermsOfUseMaxAggregateOutputType | null
  }

  type GetTermsOfUseGroupByPayload<T extends TermsOfUseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermsOfUseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermsOfUseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsOfUseGroupByOutputType[P]>
            : GetScalarType<T[P], TermsOfUseGroupByOutputType[P]>
        }
      >
    >


  export type TermsOfUseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["termsOfUse"]>



  export type TermsOfUseSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TermsOfUseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["termsOfUse"]>

  export type $TermsOfUsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TermsOfUse"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["termsOfUse"]>
    composites: {}
  }

  type TermsOfUseGetPayload<S extends boolean | null | undefined | TermsOfUseDefaultArgs> = $Result.GetResult<Prisma.$TermsOfUsePayload, S>

  type TermsOfUseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TermsOfUseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TermsOfUseCountAggregateInputType | true
    }

  export interface TermsOfUseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TermsOfUse'], meta: { name: 'TermsOfUse' } }
    /**
     * Find zero or one TermsOfUse that matches the filter.
     * @param {TermsOfUseFindUniqueArgs} args - Arguments to find a TermsOfUse
     * @example
     * // Get one TermsOfUse
     * const termsOfUse = await prisma.termsOfUse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TermsOfUseFindUniqueArgs>(args: SelectSubset<T, TermsOfUseFindUniqueArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TermsOfUse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TermsOfUseFindUniqueOrThrowArgs} args - Arguments to find a TermsOfUse
     * @example
     * // Get one TermsOfUse
     * const termsOfUse = await prisma.termsOfUse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TermsOfUseFindUniqueOrThrowArgs>(args: SelectSubset<T, TermsOfUseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsOfUse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseFindFirstArgs} args - Arguments to find a TermsOfUse
     * @example
     * // Get one TermsOfUse
     * const termsOfUse = await prisma.termsOfUse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TermsOfUseFindFirstArgs>(args?: SelectSubset<T, TermsOfUseFindFirstArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TermsOfUse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseFindFirstOrThrowArgs} args - Arguments to find a TermsOfUse
     * @example
     * // Get one TermsOfUse
     * const termsOfUse = await prisma.termsOfUse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TermsOfUseFindFirstOrThrowArgs>(args?: SelectSubset<T, TermsOfUseFindFirstOrThrowArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TermsOfUses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TermsOfUses
     * const termsOfUses = await prisma.termsOfUse.findMany()
     * 
     * // Get first 10 TermsOfUses
     * const termsOfUses = await prisma.termsOfUse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsOfUseWithIdOnly = await prisma.termsOfUse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TermsOfUseFindManyArgs>(args?: SelectSubset<T, TermsOfUseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TermsOfUse.
     * @param {TermsOfUseCreateArgs} args - Arguments to create a TermsOfUse.
     * @example
     * // Create one TermsOfUse
     * const TermsOfUse = await prisma.termsOfUse.create({
     *   data: {
     *     // ... data to create a TermsOfUse
     *   }
     * })
     * 
     */
    create<T extends TermsOfUseCreateArgs>(args: SelectSubset<T, TermsOfUseCreateArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TermsOfUses.
     * @param {TermsOfUseCreateManyArgs} args - Arguments to create many TermsOfUses.
     * @example
     * // Create many TermsOfUses
     * const termsOfUse = await prisma.termsOfUse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TermsOfUseCreateManyArgs>(args?: SelectSubset<T, TermsOfUseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TermsOfUse.
     * @param {TermsOfUseDeleteArgs} args - Arguments to delete one TermsOfUse.
     * @example
     * // Delete one TermsOfUse
     * const TermsOfUse = await prisma.termsOfUse.delete({
     *   where: {
     *     // ... filter to delete one TermsOfUse
     *   }
     * })
     * 
     */
    delete<T extends TermsOfUseDeleteArgs>(args: SelectSubset<T, TermsOfUseDeleteArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TermsOfUse.
     * @param {TermsOfUseUpdateArgs} args - Arguments to update one TermsOfUse.
     * @example
     * // Update one TermsOfUse
     * const termsOfUse = await prisma.termsOfUse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TermsOfUseUpdateArgs>(args: SelectSubset<T, TermsOfUseUpdateArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TermsOfUses.
     * @param {TermsOfUseDeleteManyArgs} args - Arguments to filter TermsOfUses to delete.
     * @example
     * // Delete a few TermsOfUses
     * const { count } = await prisma.termsOfUse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TermsOfUseDeleteManyArgs>(args?: SelectSubset<T, TermsOfUseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TermsOfUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TermsOfUses
     * const termsOfUse = await prisma.termsOfUse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TermsOfUseUpdateManyArgs>(args: SelectSubset<T, TermsOfUseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TermsOfUse.
     * @param {TermsOfUseUpsertArgs} args - Arguments to update or create a TermsOfUse.
     * @example
     * // Update or create a TermsOfUse
     * const termsOfUse = await prisma.termsOfUse.upsert({
     *   create: {
     *     // ... data to create a TermsOfUse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TermsOfUse we want to update
     *   }
     * })
     */
    upsert<T extends TermsOfUseUpsertArgs>(args: SelectSubset<T, TermsOfUseUpsertArgs<ExtArgs>>): Prisma__TermsOfUseClient<$Result.GetResult<Prisma.$TermsOfUsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TermsOfUses that matches the filter.
     * @param {TermsOfUseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const termsOfUse = await prisma.termsOfUse.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TermsOfUseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TermsOfUse.
     * @param {TermsOfUseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const termsOfUse = await prisma.termsOfUse.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TermsOfUseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TermsOfUses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseCountArgs} args - Arguments to filter TermsOfUses to count.
     * @example
     * // Count the number of TermsOfUses
     * const count = await prisma.termsOfUse.count({
     *   where: {
     *     // ... the filter for the TermsOfUses we want to count
     *   }
     * })
    **/
    count<T extends TermsOfUseCountArgs>(
      args?: Subset<T, TermsOfUseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsOfUseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TermsOfUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsOfUseAggregateArgs>(args: Subset<T, TermsOfUseAggregateArgs>): Prisma.PrismaPromise<GetTermsOfUseAggregateType<T>>

    /**
     * Group by TermsOfUse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsOfUseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermsOfUseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsOfUseGroupByArgs['orderBy'] }
        : { orderBy?: TermsOfUseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermsOfUseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermsOfUseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TermsOfUse model
   */
  readonly fields: TermsOfUseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TermsOfUse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsOfUseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TermsOfUse model
   */
  interface TermsOfUseFieldRefs {
    readonly id: FieldRef<"TermsOfUse", 'String'>
    readonly content: FieldRef<"TermsOfUse", 'String'>
    readonly createdAt: FieldRef<"TermsOfUse", 'DateTime'>
    readonly updatedAt: FieldRef<"TermsOfUse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TermsOfUse findUnique
   */
  export type TermsOfUseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * Filter, which TermsOfUse to fetch.
     */
    where: TermsOfUseWhereUniqueInput
  }

  /**
   * TermsOfUse findUniqueOrThrow
   */
  export type TermsOfUseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * Filter, which TermsOfUse to fetch.
     */
    where: TermsOfUseWhereUniqueInput
  }

  /**
   * TermsOfUse findFirst
   */
  export type TermsOfUseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * Filter, which TermsOfUse to fetch.
     */
    where?: TermsOfUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsOfUses to fetch.
     */
    orderBy?: TermsOfUseOrderByWithRelationInput | TermsOfUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsOfUses.
     */
    cursor?: TermsOfUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsOfUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsOfUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsOfUses.
     */
    distinct?: TermsOfUseScalarFieldEnum | TermsOfUseScalarFieldEnum[]
  }

  /**
   * TermsOfUse findFirstOrThrow
   */
  export type TermsOfUseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * Filter, which TermsOfUse to fetch.
     */
    where?: TermsOfUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsOfUses to fetch.
     */
    orderBy?: TermsOfUseOrderByWithRelationInput | TermsOfUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TermsOfUses.
     */
    cursor?: TermsOfUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsOfUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsOfUses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TermsOfUses.
     */
    distinct?: TermsOfUseScalarFieldEnum | TermsOfUseScalarFieldEnum[]
  }

  /**
   * TermsOfUse findMany
   */
  export type TermsOfUseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * Filter, which TermsOfUses to fetch.
     */
    where?: TermsOfUseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TermsOfUses to fetch.
     */
    orderBy?: TermsOfUseOrderByWithRelationInput | TermsOfUseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TermsOfUses.
     */
    cursor?: TermsOfUseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TermsOfUses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TermsOfUses.
     */
    skip?: number
    distinct?: TermsOfUseScalarFieldEnum | TermsOfUseScalarFieldEnum[]
  }

  /**
   * TermsOfUse create
   */
  export type TermsOfUseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * The data needed to create a TermsOfUse.
     */
    data: XOR<TermsOfUseCreateInput, TermsOfUseUncheckedCreateInput>
  }

  /**
   * TermsOfUse createMany
   */
  export type TermsOfUseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TermsOfUses.
     */
    data: TermsOfUseCreateManyInput | TermsOfUseCreateManyInput[]
  }

  /**
   * TermsOfUse update
   */
  export type TermsOfUseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * The data needed to update a TermsOfUse.
     */
    data: XOR<TermsOfUseUpdateInput, TermsOfUseUncheckedUpdateInput>
    /**
     * Choose, which TermsOfUse to update.
     */
    where: TermsOfUseWhereUniqueInput
  }

  /**
   * TermsOfUse updateMany
   */
  export type TermsOfUseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TermsOfUses.
     */
    data: XOR<TermsOfUseUpdateManyMutationInput, TermsOfUseUncheckedUpdateManyInput>
    /**
     * Filter which TermsOfUses to update
     */
    where?: TermsOfUseWhereInput
    /**
     * Limit how many TermsOfUses to update.
     */
    limit?: number
  }

  /**
   * TermsOfUse upsert
   */
  export type TermsOfUseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * The filter to search for the TermsOfUse to update in case it exists.
     */
    where: TermsOfUseWhereUniqueInput
    /**
     * In case the TermsOfUse found by the `where` argument doesn't exist, create a new TermsOfUse with this data.
     */
    create: XOR<TermsOfUseCreateInput, TermsOfUseUncheckedCreateInput>
    /**
     * In case the TermsOfUse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsOfUseUpdateInput, TermsOfUseUncheckedUpdateInput>
  }

  /**
   * TermsOfUse delete
   */
  export type TermsOfUseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
    /**
     * Filter which TermsOfUse to delete.
     */
    where: TermsOfUseWhereUniqueInput
  }

  /**
   * TermsOfUse deleteMany
   */
  export type TermsOfUseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TermsOfUses to delete
     */
    where?: TermsOfUseWhereInput
    /**
     * Limit how many TermsOfUses to delete.
     */
    limit?: number
  }

  /**
   * TermsOfUse findRaw
   */
  export type TermsOfUseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TermsOfUse aggregateRaw
   */
  export type TermsOfUseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TermsOfUse without action
   */
  export type TermsOfUseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsOfUse
     */
    select?: TermsOfUseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TermsOfUse
     */
    omit?: TermsOfUseOmit<ExtArgs> | null
  }


  /**
   * Model BuyingGuides
   */

  export type AggregateBuyingGuides = {
    _count: BuyingGuidesCountAggregateOutputType | null
    _min: BuyingGuidesMinAggregateOutputType | null
    _max: BuyingGuidesMaxAggregateOutputType | null
  }

  export type BuyingGuidesMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuyingGuidesMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuyingGuidesCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuyingGuidesMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuyingGuidesMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuyingGuidesCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuyingGuidesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuyingGuides to aggregate.
     */
    where?: BuyingGuidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyingGuides to fetch.
     */
    orderBy?: BuyingGuidesOrderByWithRelationInput | BuyingGuidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuyingGuidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyingGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyingGuides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BuyingGuides
    **/
    _count?: true | BuyingGuidesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuyingGuidesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuyingGuidesMaxAggregateInputType
  }

  export type GetBuyingGuidesAggregateType<T extends BuyingGuidesAggregateArgs> = {
        [P in keyof T & keyof AggregateBuyingGuides]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuyingGuides[P]>
      : GetScalarType<T[P], AggregateBuyingGuides[P]>
  }




  export type BuyingGuidesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuyingGuidesWhereInput
    orderBy?: BuyingGuidesOrderByWithAggregationInput | BuyingGuidesOrderByWithAggregationInput[]
    by: BuyingGuidesScalarFieldEnum[] | BuyingGuidesScalarFieldEnum
    having?: BuyingGuidesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuyingGuidesCountAggregateInputType | true
    _min?: BuyingGuidesMinAggregateInputType
    _max?: BuyingGuidesMaxAggregateInputType
  }

  export type BuyingGuidesGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: BuyingGuidesCountAggregateOutputType | null
    _min: BuyingGuidesMinAggregateOutputType | null
    _max: BuyingGuidesMaxAggregateOutputType | null
  }

  type GetBuyingGuidesGroupByPayload<T extends BuyingGuidesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuyingGuidesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuyingGuidesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuyingGuidesGroupByOutputType[P]>
            : GetScalarType<T[P], BuyingGuidesGroupByOutputType[P]>
        }
      >
    >


  export type BuyingGuidesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["buyingGuides"]>



  export type BuyingGuidesSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuyingGuidesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["buyingGuides"]>

  export type $BuyingGuidesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BuyingGuides"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["buyingGuides"]>
    composites: {}
  }

  type BuyingGuidesGetPayload<S extends boolean | null | undefined | BuyingGuidesDefaultArgs> = $Result.GetResult<Prisma.$BuyingGuidesPayload, S>

  type BuyingGuidesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BuyingGuidesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuyingGuidesCountAggregateInputType | true
    }

  export interface BuyingGuidesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BuyingGuides'], meta: { name: 'BuyingGuides' } }
    /**
     * Find zero or one BuyingGuides that matches the filter.
     * @param {BuyingGuidesFindUniqueArgs} args - Arguments to find a BuyingGuides
     * @example
     * // Get one BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuyingGuidesFindUniqueArgs>(args: SelectSubset<T, BuyingGuidesFindUniqueArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BuyingGuides that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BuyingGuidesFindUniqueOrThrowArgs} args - Arguments to find a BuyingGuides
     * @example
     * // Get one BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuyingGuidesFindUniqueOrThrowArgs>(args: SelectSubset<T, BuyingGuidesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuyingGuides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesFindFirstArgs} args - Arguments to find a BuyingGuides
     * @example
     * // Get one BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuyingGuidesFindFirstArgs>(args?: SelectSubset<T, BuyingGuidesFindFirstArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BuyingGuides that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesFindFirstOrThrowArgs} args - Arguments to find a BuyingGuides
     * @example
     * // Get one BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuyingGuidesFindFirstOrThrowArgs>(args?: SelectSubset<T, BuyingGuidesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuyingGuides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.findMany()
     * 
     * // Get first 10 BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buyingGuidesWithIdOnly = await prisma.buyingGuides.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuyingGuidesFindManyArgs>(args?: SelectSubset<T, BuyingGuidesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BuyingGuides.
     * @param {BuyingGuidesCreateArgs} args - Arguments to create a BuyingGuides.
     * @example
     * // Create one BuyingGuides
     * const BuyingGuides = await prisma.buyingGuides.create({
     *   data: {
     *     // ... data to create a BuyingGuides
     *   }
     * })
     * 
     */
    create<T extends BuyingGuidesCreateArgs>(args: SelectSubset<T, BuyingGuidesCreateArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BuyingGuides.
     * @param {BuyingGuidesCreateManyArgs} args - Arguments to create many BuyingGuides.
     * @example
     * // Create many BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuyingGuidesCreateManyArgs>(args?: SelectSubset<T, BuyingGuidesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BuyingGuides.
     * @param {BuyingGuidesDeleteArgs} args - Arguments to delete one BuyingGuides.
     * @example
     * // Delete one BuyingGuides
     * const BuyingGuides = await prisma.buyingGuides.delete({
     *   where: {
     *     // ... filter to delete one BuyingGuides
     *   }
     * })
     * 
     */
    delete<T extends BuyingGuidesDeleteArgs>(args: SelectSubset<T, BuyingGuidesDeleteArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BuyingGuides.
     * @param {BuyingGuidesUpdateArgs} args - Arguments to update one BuyingGuides.
     * @example
     * // Update one BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuyingGuidesUpdateArgs>(args: SelectSubset<T, BuyingGuidesUpdateArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BuyingGuides.
     * @param {BuyingGuidesDeleteManyArgs} args - Arguments to filter BuyingGuides to delete.
     * @example
     * // Delete a few BuyingGuides
     * const { count } = await prisma.buyingGuides.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuyingGuidesDeleteManyArgs>(args?: SelectSubset<T, BuyingGuidesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BuyingGuides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuyingGuidesUpdateManyArgs>(args: SelectSubset<T, BuyingGuidesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BuyingGuides.
     * @param {BuyingGuidesUpsertArgs} args - Arguments to update or create a BuyingGuides.
     * @example
     * // Update or create a BuyingGuides
     * const buyingGuides = await prisma.buyingGuides.upsert({
     *   create: {
     *     // ... data to create a BuyingGuides
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BuyingGuides we want to update
     *   }
     * })
     */
    upsert<T extends BuyingGuidesUpsertArgs>(args: SelectSubset<T, BuyingGuidesUpsertArgs<ExtArgs>>): Prisma__BuyingGuidesClient<$Result.GetResult<Prisma.$BuyingGuidesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BuyingGuides that matches the filter.
     * @param {BuyingGuidesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const buyingGuides = await prisma.buyingGuides.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BuyingGuidesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BuyingGuides.
     * @param {BuyingGuidesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const buyingGuides = await prisma.buyingGuides.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BuyingGuidesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BuyingGuides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesCountArgs} args - Arguments to filter BuyingGuides to count.
     * @example
     * // Count the number of BuyingGuides
     * const count = await prisma.buyingGuides.count({
     *   where: {
     *     // ... the filter for the BuyingGuides we want to count
     *   }
     * })
    **/
    count<T extends BuyingGuidesCountArgs>(
      args?: Subset<T, BuyingGuidesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuyingGuidesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BuyingGuides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuyingGuidesAggregateArgs>(args: Subset<T, BuyingGuidesAggregateArgs>): Prisma.PrismaPromise<GetBuyingGuidesAggregateType<T>>

    /**
     * Group by BuyingGuides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuyingGuidesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuyingGuidesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuyingGuidesGroupByArgs['orderBy'] }
        : { orderBy?: BuyingGuidesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuyingGuidesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuyingGuidesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BuyingGuides model
   */
  readonly fields: BuyingGuidesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BuyingGuides.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuyingGuidesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BuyingGuides model
   */
  interface BuyingGuidesFieldRefs {
    readonly id: FieldRef<"BuyingGuides", 'String'>
    readonly content: FieldRef<"BuyingGuides", 'String'>
    readonly createdAt: FieldRef<"BuyingGuides", 'DateTime'>
    readonly updatedAt: FieldRef<"BuyingGuides", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BuyingGuides findUnique
   */
  export type BuyingGuidesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * Filter, which BuyingGuides to fetch.
     */
    where: BuyingGuidesWhereUniqueInput
  }

  /**
   * BuyingGuides findUniqueOrThrow
   */
  export type BuyingGuidesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * Filter, which BuyingGuides to fetch.
     */
    where: BuyingGuidesWhereUniqueInput
  }

  /**
   * BuyingGuides findFirst
   */
  export type BuyingGuidesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * Filter, which BuyingGuides to fetch.
     */
    where?: BuyingGuidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyingGuides to fetch.
     */
    orderBy?: BuyingGuidesOrderByWithRelationInput | BuyingGuidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuyingGuides.
     */
    cursor?: BuyingGuidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyingGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyingGuides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuyingGuides.
     */
    distinct?: BuyingGuidesScalarFieldEnum | BuyingGuidesScalarFieldEnum[]
  }

  /**
   * BuyingGuides findFirstOrThrow
   */
  export type BuyingGuidesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * Filter, which BuyingGuides to fetch.
     */
    where?: BuyingGuidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyingGuides to fetch.
     */
    orderBy?: BuyingGuidesOrderByWithRelationInput | BuyingGuidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BuyingGuides.
     */
    cursor?: BuyingGuidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyingGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyingGuides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BuyingGuides.
     */
    distinct?: BuyingGuidesScalarFieldEnum | BuyingGuidesScalarFieldEnum[]
  }

  /**
   * BuyingGuides findMany
   */
  export type BuyingGuidesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * Filter, which BuyingGuides to fetch.
     */
    where?: BuyingGuidesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BuyingGuides to fetch.
     */
    orderBy?: BuyingGuidesOrderByWithRelationInput | BuyingGuidesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BuyingGuides.
     */
    cursor?: BuyingGuidesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BuyingGuides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BuyingGuides.
     */
    skip?: number
    distinct?: BuyingGuidesScalarFieldEnum | BuyingGuidesScalarFieldEnum[]
  }

  /**
   * BuyingGuides create
   */
  export type BuyingGuidesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * The data needed to create a BuyingGuides.
     */
    data: XOR<BuyingGuidesCreateInput, BuyingGuidesUncheckedCreateInput>
  }

  /**
   * BuyingGuides createMany
   */
  export type BuyingGuidesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BuyingGuides.
     */
    data: BuyingGuidesCreateManyInput | BuyingGuidesCreateManyInput[]
  }

  /**
   * BuyingGuides update
   */
  export type BuyingGuidesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * The data needed to update a BuyingGuides.
     */
    data: XOR<BuyingGuidesUpdateInput, BuyingGuidesUncheckedUpdateInput>
    /**
     * Choose, which BuyingGuides to update.
     */
    where: BuyingGuidesWhereUniqueInput
  }

  /**
   * BuyingGuides updateMany
   */
  export type BuyingGuidesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BuyingGuides.
     */
    data: XOR<BuyingGuidesUpdateManyMutationInput, BuyingGuidesUncheckedUpdateManyInput>
    /**
     * Filter which BuyingGuides to update
     */
    where?: BuyingGuidesWhereInput
    /**
     * Limit how many BuyingGuides to update.
     */
    limit?: number
  }

  /**
   * BuyingGuides upsert
   */
  export type BuyingGuidesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * The filter to search for the BuyingGuides to update in case it exists.
     */
    where: BuyingGuidesWhereUniqueInput
    /**
     * In case the BuyingGuides found by the `where` argument doesn't exist, create a new BuyingGuides with this data.
     */
    create: XOR<BuyingGuidesCreateInput, BuyingGuidesUncheckedCreateInput>
    /**
     * In case the BuyingGuides was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuyingGuidesUpdateInput, BuyingGuidesUncheckedUpdateInput>
  }

  /**
   * BuyingGuides delete
   */
  export type BuyingGuidesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
    /**
     * Filter which BuyingGuides to delete.
     */
    where: BuyingGuidesWhereUniqueInput
  }

  /**
   * BuyingGuides deleteMany
   */
  export type BuyingGuidesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BuyingGuides to delete
     */
    where?: BuyingGuidesWhereInput
    /**
     * Limit how many BuyingGuides to delete.
     */
    limit?: number
  }

  /**
   * BuyingGuides findRaw
   */
  export type BuyingGuidesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BuyingGuides aggregateRaw
   */
  export type BuyingGuidesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BuyingGuides without action
   */
  export type BuyingGuidesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuyingGuides
     */
    select?: BuyingGuidesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BuyingGuides
     */
    omit?: BuyingGuidesOmit<ExtArgs> | null
  }


  /**
   * Model SellingTips
   */

  export type AggregateSellingTips = {
    _count: SellingTipsCountAggregateOutputType | null
    _min: SellingTipsMinAggregateOutputType | null
    _max: SellingTipsMaxAggregateOutputType | null
  }

  export type SellingTipsMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellingTipsMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellingTipsCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellingTipsMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellingTipsMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellingTipsCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellingTipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingTips to aggregate.
     */
    where?: SellingTipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingTips to fetch.
     */
    orderBy?: SellingTipsOrderByWithRelationInput | SellingTipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellingTipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellingTips
    **/
    _count?: true | SellingTipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellingTipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellingTipsMaxAggregateInputType
  }

  export type GetSellingTipsAggregateType<T extends SellingTipsAggregateArgs> = {
        [P in keyof T & keyof AggregateSellingTips]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellingTips[P]>
      : GetScalarType<T[P], AggregateSellingTips[P]>
  }




  export type SellingTipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellingTipsWhereInput
    orderBy?: SellingTipsOrderByWithAggregationInput | SellingTipsOrderByWithAggregationInput[]
    by: SellingTipsScalarFieldEnum[] | SellingTipsScalarFieldEnum
    having?: SellingTipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellingTipsCountAggregateInputType | true
    _min?: SellingTipsMinAggregateInputType
    _max?: SellingTipsMaxAggregateInputType
  }

  export type SellingTipsGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: SellingTipsCountAggregateOutputType | null
    _min: SellingTipsMinAggregateOutputType | null
    _max: SellingTipsMaxAggregateOutputType | null
  }

  type GetSellingTipsGroupByPayload<T extends SellingTipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellingTipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellingTipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellingTipsGroupByOutputType[P]>
            : GetScalarType<T[P], SellingTipsGroupByOutputType[P]>
        }
      >
    >


  export type SellingTipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sellingTips"]>



  export type SellingTipsSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellingTipsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["sellingTips"]>

  export type $SellingTipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellingTips"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellingTips"]>
    composites: {}
  }

  type SellingTipsGetPayload<S extends boolean | null | undefined | SellingTipsDefaultArgs> = $Result.GetResult<Prisma.$SellingTipsPayload, S>

  type SellingTipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellingTipsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellingTipsCountAggregateInputType | true
    }

  export interface SellingTipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellingTips'], meta: { name: 'SellingTips' } }
    /**
     * Find zero or one SellingTips that matches the filter.
     * @param {SellingTipsFindUniqueArgs} args - Arguments to find a SellingTips
     * @example
     * // Get one SellingTips
     * const sellingTips = await prisma.sellingTips.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellingTipsFindUniqueArgs>(args: SelectSubset<T, SellingTipsFindUniqueArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellingTips that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellingTipsFindUniqueOrThrowArgs} args - Arguments to find a SellingTips
     * @example
     * // Get one SellingTips
     * const sellingTips = await prisma.sellingTips.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellingTipsFindUniqueOrThrowArgs>(args: SelectSubset<T, SellingTipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellingTips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsFindFirstArgs} args - Arguments to find a SellingTips
     * @example
     * // Get one SellingTips
     * const sellingTips = await prisma.sellingTips.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellingTipsFindFirstArgs>(args?: SelectSubset<T, SellingTipsFindFirstArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellingTips that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsFindFirstOrThrowArgs} args - Arguments to find a SellingTips
     * @example
     * // Get one SellingTips
     * const sellingTips = await prisma.sellingTips.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellingTipsFindFirstOrThrowArgs>(args?: SelectSubset<T, SellingTipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellingTips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellingTips
     * const sellingTips = await prisma.sellingTips.findMany()
     * 
     * // Get first 10 SellingTips
     * const sellingTips = await prisma.sellingTips.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellingTipsWithIdOnly = await prisma.sellingTips.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellingTipsFindManyArgs>(args?: SelectSubset<T, SellingTipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellingTips.
     * @param {SellingTipsCreateArgs} args - Arguments to create a SellingTips.
     * @example
     * // Create one SellingTips
     * const SellingTips = await prisma.sellingTips.create({
     *   data: {
     *     // ... data to create a SellingTips
     *   }
     * })
     * 
     */
    create<T extends SellingTipsCreateArgs>(args: SelectSubset<T, SellingTipsCreateArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellingTips.
     * @param {SellingTipsCreateManyArgs} args - Arguments to create many SellingTips.
     * @example
     * // Create many SellingTips
     * const sellingTips = await prisma.sellingTips.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellingTipsCreateManyArgs>(args?: SelectSubset<T, SellingTipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellingTips.
     * @param {SellingTipsDeleteArgs} args - Arguments to delete one SellingTips.
     * @example
     * // Delete one SellingTips
     * const SellingTips = await prisma.sellingTips.delete({
     *   where: {
     *     // ... filter to delete one SellingTips
     *   }
     * })
     * 
     */
    delete<T extends SellingTipsDeleteArgs>(args: SelectSubset<T, SellingTipsDeleteArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellingTips.
     * @param {SellingTipsUpdateArgs} args - Arguments to update one SellingTips.
     * @example
     * // Update one SellingTips
     * const sellingTips = await prisma.sellingTips.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellingTipsUpdateArgs>(args: SelectSubset<T, SellingTipsUpdateArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellingTips.
     * @param {SellingTipsDeleteManyArgs} args - Arguments to filter SellingTips to delete.
     * @example
     * // Delete a few SellingTips
     * const { count } = await prisma.sellingTips.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellingTipsDeleteManyArgs>(args?: SelectSubset<T, SellingTipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellingTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellingTips
     * const sellingTips = await prisma.sellingTips.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellingTipsUpdateManyArgs>(args: SelectSubset<T, SellingTipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellingTips.
     * @param {SellingTipsUpsertArgs} args - Arguments to update or create a SellingTips.
     * @example
     * // Update or create a SellingTips
     * const sellingTips = await prisma.sellingTips.upsert({
     *   create: {
     *     // ... data to create a SellingTips
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellingTips we want to update
     *   }
     * })
     */
    upsert<T extends SellingTipsUpsertArgs>(args: SelectSubset<T, SellingTipsUpsertArgs<ExtArgs>>): Prisma__SellingTipsClient<$Result.GetResult<Prisma.$SellingTipsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellingTips that matches the filter.
     * @param {SellingTipsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sellingTips = await prisma.sellingTips.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SellingTipsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SellingTips.
     * @param {SellingTipsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sellingTips = await prisma.sellingTips.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SellingTipsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SellingTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsCountArgs} args - Arguments to filter SellingTips to count.
     * @example
     * // Count the number of SellingTips
     * const count = await prisma.sellingTips.count({
     *   where: {
     *     // ... the filter for the SellingTips we want to count
     *   }
     * })
    **/
    count<T extends SellingTipsCountArgs>(
      args?: Subset<T, SellingTipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellingTipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellingTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellingTipsAggregateArgs>(args: Subset<T, SellingTipsAggregateArgs>): Prisma.PrismaPromise<GetSellingTipsAggregateType<T>>

    /**
     * Group by SellingTips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellingTipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellingTipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellingTipsGroupByArgs['orderBy'] }
        : { orderBy?: SellingTipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellingTipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellingTipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellingTips model
   */
  readonly fields: SellingTipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellingTips.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellingTipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellingTips model
   */
  interface SellingTipsFieldRefs {
    readonly id: FieldRef<"SellingTips", 'String'>
    readonly content: FieldRef<"SellingTips", 'String'>
    readonly createdAt: FieldRef<"SellingTips", 'DateTime'>
    readonly updatedAt: FieldRef<"SellingTips", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellingTips findUnique
   */
  export type SellingTipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * Filter, which SellingTips to fetch.
     */
    where: SellingTipsWhereUniqueInput
  }

  /**
   * SellingTips findUniqueOrThrow
   */
  export type SellingTipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * Filter, which SellingTips to fetch.
     */
    where: SellingTipsWhereUniqueInput
  }

  /**
   * SellingTips findFirst
   */
  export type SellingTipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * Filter, which SellingTips to fetch.
     */
    where?: SellingTipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingTips to fetch.
     */
    orderBy?: SellingTipsOrderByWithRelationInput | SellingTipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingTips.
     */
    cursor?: SellingTipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingTips.
     */
    distinct?: SellingTipsScalarFieldEnum | SellingTipsScalarFieldEnum[]
  }

  /**
   * SellingTips findFirstOrThrow
   */
  export type SellingTipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * Filter, which SellingTips to fetch.
     */
    where?: SellingTipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingTips to fetch.
     */
    orderBy?: SellingTipsOrderByWithRelationInput | SellingTipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellingTips.
     */
    cursor?: SellingTipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingTips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellingTips.
     */
    distinct?: SellingTipsScalarFieldEnum | SellingTipsScalarFieldEnum[]
  }

  /**
   * SellingTips findMany
   */
  export type SellingTipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * Filter, which SellingTips to fetch.
     */
    where?: SellingTipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellingTips to fetch.
     */
    orderBy?: SellingTipsOrderByWithRelationInput | SellingTipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellingTips.
     */
    cursor?: SellingTipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellingTips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellingTips.
     */
    skip?: number
    distinct?: SellingTipsScalarFieldEnum | SellingTipsScalarFieldEnum[]
  }

  /**
   * SellingTips create
   */
  export type SellingTipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * The data needed to create a SellingTips.
     */
    data: XOR<SellingTipsCreateInput, SellingTipsUncheckedCreateInput>
  }

  /**
   * SellingTips createMany
   */
  export type SellingTipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellingTips.
     */
    data: SellingTipsCreateManyInput | SellingTipsCreateManyInput[]
  }

  /**
   * SellingTips update
   */
  export type SellingTipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * The data needed to update a SellingTips.
     */
    data: XOR<SellingTipsUpdateInput, SellingTipsUncheckedUpdateInput>
    /**
     * Choose, which SellingTips to update.
     */
    where: SellingTipsWhereUniqueInput
  }

  /**
   * SellingTips updateMany
   */
  export type SellingTipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellingTips.
     */
    data: XOR<SellingTipsUpdateManyMutationInput, SellingTipsUncheckedUpdateManyInput>
    /**
     * Filter which SellingTips to update
     */
    where?: SellingTipsWhereInput
    /**
     * Limit how many SellingTips to update.
     */
    limit?: number
  }

  /**
   * SellingTips upsert
   */
  export type SellingTipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * The filter to search for the SellingTips to update in case it exists.
     */
    where: SellingTipsWhereUniqueInput
    /**
     * In case the SellingTips found by the `where` argument doesn't exist, create a new SellingTips with this data.
     */
    create: XOR<SellingTipsCreateInput, SellingTipsUncheckedCreateInput>
    /**
     * In case the SellingTips was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellingTipsUpdateInput, SellingTipsUncheckedUpdateInput>
  }

  /**
   * SellingTips delete
   */
  export type SellingTipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
    /**
     * Filter which SellingTips to delete.
     */
    where: SellingTipsWhereUniqueInput
  }

  /**
   * SellingTips deleteMany
   */
  export type SellingTipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellingTips to delete
     */
    where?: SellingTipsWhereInput
    /**
     * Limit how many SellingTips to delete.
     */
    limit?: number
  }

  /**
   * SellingTips findRaw
   */
  export type SellingTipsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellingTips aggregateRaw
   */
  export type SellingTipsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellingTips without action
   */
  export type SellingTipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellingTips
     */
    select?: SellingTipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellingTips
     */
    omit?: SellingTipsOmit<ExtArgs> | null
  }


  /**
   * Model MarketInsights
   */

  export type AggregateMarketInsights = {
    _count: MarketInsightsCountAggregateOutputType | null
    _min: MarketInsightsMinAggregateOutputType | null
    _max: MarketInsightsMaxAggregateOutputType | null
  }

  export type MarketInsightsMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketInsightsMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketInsightsCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketInsightsMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketInsightsMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketInsightsCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketInsightsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketInsights to aggregate.
     */
    where?: MarketInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketInsights to fetch.
     */
    orderBy?: MarketInsightsOrderByWithRelationInput | MarketInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketInsights
    **/
    _count?: true | MarketInsightsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketInsightsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketInsightsMaxAggregateInputType
  }

  export type GetMarketInsightsAggregateType<T extends MarketInsightsAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketInsights]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketInsights[P]>
      : GetScalarType<T[P], AggregateMarketInsights[P]>
  }




  export type MarketInsightsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketInsightsWhereInput
    orderBy?: MarketInsightsOrderByWithAggregationInput | MarketInsightsOrderByWithAggregationInput[]
    by: MarketInsightsScalarFieldEnum[] | MarketInsightsScalarFieldEnum
    having?: MarketInsightsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketInsightsCountAggregateInputType | true
    _min?: MarketInsightsMinAggregateInputType
    _max?: MarketInsightsMaxAggregateInputType
  }

  export type MarketInsightsGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: MarketInsightsCountAggregateOutputType | null
    _min: MarketInsightsMinAggregateOutputType | null
    _max: MarketInsightsMaxAggregateOutputType | null
  }

  type GetMarketInsightsGroupByPayload<T extends MarketInsightsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketInsightsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketInsightsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketInsightsGroupByOutputType[P]>
            : GetScalarType<T[P], MarketInsightsGroupByOutputType[P]>
        }
      >
    >


  export type MarketInsightsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketInsights"]>



  export type MarketInsightsSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketInsightsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["marketInsights"]>

  export type $MarketInsightsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketInsights"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketInsights"]>
    composites: {}
  }

  type MarketInsightsGetPayload<S extends boolean | null | undefined | MarketInsightsDefaultArgs> = $Result.GetResult<Prisma.$MarketInsightsPayload, S>

  type MarketInsightsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketInsightsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketInsightsCountAggregateInputType | true
    }

  export interface MarketInsightsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketInsights'], meta: { name: 'MarketInsights' } }
    /**
     * Find zero or one MarketInsights that matches the filter.
     * @param {MarketInsightsFindUniqueArgs} args - Arguments to find a MarketInsights
     * @example
     * // Get one MarketInsights
     * const marketInsights = await prisma.marketInsights.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketInsightsFindUniqueArgs>(args: SelectSubset<T, MarketInsightsFindUniqueArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketInsights that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketInsightsFindUniqueOrThrowArgs} args - Arguments to find a MarketInsights
     * @example
     * // Get one MarketInsights
     * const marketInsights = await prisma.marketInsights.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketInsightsFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketInsightsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsFindFirstArgs} args - Arguments to find a MarketInsights
     * @example
     * // Get one MarketInsights
     * const marketInsights = await prisma.marketInsights.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketInsightsFindFirstArgs>(args?: SelectSubset<T, MarketInsightsFindFirstArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketInsights that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsFindFirstOrThrowArgs} args - Arguments to find a MarketInsights
     * @example
     * // Get one MarketInsights
     * const marketInsights = await prisma.marketInsights.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketInsightsFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketInsightsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketInsights
     * const marketInsights = await prisma.marketInsights.findMany()
     * 
     * // Get first 10 MarketInsights
     * const marketInsights = await prisma.marketInsights.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketInsightsWithIdOnly = await prisma.marketInsights.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketInsightsFindManyArgs>(args?: SelectSubset<T, MarketInsightsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketInsights.
     * @param {MarketInsightsCreateArgs} args - Arguments to create a MarketInsights.
     * @example
     * // Create one MarketInsights
     * const MarketInsights = await prisma.marketInsights.create({
     *   data: {
     *     // ... data to create a MarketInsights
     *   }
     * })
     * 
     */
    create<T extends MarketInsightsCreateArgs>(args: SelectSubset<T, MarketInsightsCreateArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketInsights.
     * @param {MarketInsightsCreateManyArgs} args - Arguments to create many MarketInsights.
     * @example
     * // Create many MarketInsights
     * const marketInsights = await prisma.marketInsights.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketInsightsCreateManyArgs>(args?: SelectSubset<T, MarketInsightsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketInsights.
     * @param {MarketInsightsDeleteArgs} args - Arguments to delete one MarketInsights.
     * @example
     * // Delete one MarketInsights
     * const MarketInsights = await prisma.marketInsights.delete({
     *   where: {
     *     // ... filter to delete one MarketInsights
     *   }
     * })
     * 
     */
    delete<T extends MarketInsightsDeleteArgs>(args: SelectSubset<T, MarketInsightsDeleteArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketInsights.
     * @param {MarketInsightsUpdateArgs} args - Arguments to update one MarketInsights.
     * @example
     * // Update one MarketInsights
     * const marketInsights = await prisma.marketInsights.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketInsightsUpdateArgs>(args: SelectSubset<T, MarketInsightsUpdateArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketInsights.
     * @param {MarketInsightsDeleteManyArgs} args - Arguments to filter MarketInsights to delete.
     * @example
     * // Delete a few MarketInsights
     * const { count } = await prisma.marketInsights.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketInsightsDeleteManyArgs>(args?: SelectSubset<T, MarketInsightsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketInsights
     * const marketInsights = await prisma.marketInsights.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketInsightsUpdateManyArgs>(args: SelectSubset<T, MarketInsightsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketInsights.
     * @param {MarketInsightsUpsertArgs} args - Arguments to update or create a MarketInsights.
     * @example
     * // Update or create a MarketInsights
     * const marketInsights = await prisma.marketInsights.upsert({
     *   create: {
     *     // ... data to create a MarketInsights
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketInsights we want to update
     *   }
     * })
     */
    upsert<T extends MarketInsightsUpsertArgs>(args: SelectSubset<T, MarketInsightsUpsertArgs<ExtArgs>>): Prisma__MarketInsightsClient<$Result.GetResult<Prisma.$MarketInsightsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketInsights that matches the filter.
     * @param {MarketInsightsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const marketInsights = await prisma.marketInsights.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MarketInsightsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MarketInsights.
     * @param {MarketInsightsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const marketInsights = await prisma.marketInsights.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MarketInsightsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MarketInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsCountArgs} args - Arguments to filter MarketInsights to count.
     * @example
     * // Count the number of MarketInsights
     * const count = await prisma.marketInsights.count({
     *   where: {
     *     // ... the filter for the MarketInsights we want to count
     *   }
     * })
    **/
    count<T extends MarketInsightsCountArgs>(
      args?: Subset<T, MarketInsightsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketInsightsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketInsightsAggregateArgs>(args: Subset<T, MarketInsightsAggregateArgs>): Prisma.PrismaPromise<GetMarketInsightsAggregateType<T>>

    /**
     * Group by MarketInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketInsightsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketInsightsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketInsightsGroupByArgs['orderBy'] }
        : { orderBy?: MarketInsightsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketInsightsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketInsightsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketInsights model
   */
  readonly fields: MarketInsightsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketInsights.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketInsightsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketInsights model
   */
  interface MarketInsightsFieldRefs {
    readonly id: FieldRef<"MarketInsights", 'String'>
    readonly content: FieldRef<"MarketInsights", 'String'>
    readonly createdAt: FieldRef<"MarketInsights", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketInsights", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketInsights findUnique
   */
  export type MarketInsightsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * Filter, which MarketInsights to fetch.
     */
    where: MarketInsightsWhereUniqueInput
  }

  /**
   * MarketInsights findUniqueOrThrow
   */
  export type MarketInsightsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * Filter, which MarketInsights to fetch.
     */
    where: MarketInsightsWhereUniqueInput
  }

  /**
   * MarketInsights findFirst
   */
  export type MarketInsightsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * Filter, which MarketInsights to fetch.
     */
    where?: MarketInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketInsights to fetch.
     */
    orderBy?: MarketInsightsOrderByWithRelationInput | MarketInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketInsights.
     */
    cursor?: MarketInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketInsights.
     */
    distinct?: MarketInsightsScalarFieldEnum | MarketInsightsScalarFieldEnum[]
  }

  /**
   * MarketInsights findFirstOrThrow
   */
  export type MarketInsightsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * Filter, which MarketInsights to fetch.
     */
    where?: MarketInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketInsights to fetch.
     */
    orderBy?: MarketInsightsOrderByWithRelationInput | MarketInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketInsights.
     */
    cursor?: MarketInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketInsights.
     */
    distinct?: MarketInsightsScalarFieldEnum | MarketInsightsScalarFieldEnum[]
  }

  /**
   * MarketInsights findMany
   */
  export type MarketInsightsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * Filter, which MarketInsights to fetch.
     */
    where?: MarketInsightsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketInsights to fetch.
     */
    orderBy?: MarketInsightsOrderByWithRelationInput | MarketInsightsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketInsights.
     */
    cursor?: MarketInsightsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketInsights.
     */
    skip?: number
    distinct?: MarketInsightsScalarFieldEnum | MarketInsightsScalarFieldEnum[]
  }

  /**
   * MarketInsights create
   */
  export type MarketInsightsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketInsights.
     */
    data: XOR<MarketInsightsCreateInput, MarketInsightsUncheckedCreateInput>
  }

  /**
   * MarketInsights createMany
   */
  export type MarketInsightsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketInsights.
     */
    data: MarketInsightsCreateManyInput | MarketInsightsCreateManyInput[]
  }

  /**
   * MarketInsights update
   */
  export type MarketInsightsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketInsights.
     */
    data: XOR<MarketInsightsUpdateInput, MarketInsightsUncheckedUpdateInput>
    /**
     * Choose, which MarketInsights to update.
     */
    where: MarketInsightsWhereUniqueInput
  }

  /**
   * MarketInsights updateMany
   */
  export type MarketInsightsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketInsights.
     */
    data: XOR<MarketInsightsUpdateManyMutationInput, MarketInsightsUncheckedUpdateManyInput>
    /**
     * Filter which MarketInsights to update
     */
    where?: MarketInsightsWhereInput
    /**
     * Limit how many MarketInsights to update.
     */
    limit?: number
  }

  /**
   * MarketInsights upsert
   */
  export type MarketInsightsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketInsights to update in case it exists.
     */
    where: MarketInsightsWhereUniqueInput
    /**
     * In case the MarketInsights found by the `where` argument doesn't exist, create a new MarketInsights with this data.
     */
    create: XOR<MarketInsightsCreateInput, MarketInsightsUncheckedCreateInput>
    /**
     * In case the MarketInsights was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketInsightsUpdateInput, MarketInsightsUncheckedUpdateInput>
  }

  /**
   * MarketInsights delete
   */
  export type MarketInsightsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
    /**
     * Filter which MarketInsights to delete.
     */
    where: MarketInsightsWhereUniqueInput
  }

  /**
   * MarketInsights deleteMany
   */
  export type MarketInsightsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketInsights to delete
     */
    where?: MarketInsightsWhereInput
    /**
     * Limit how many MarketInsights to delete.
     */
    limit?: number
  }

  /**
   * MarketInsights findRaw
   */
  export type MarketInsightsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketInsights aggregateRaw
   */
  export type MarketInsightsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketInsights without action
   */
  export type MarketInsightsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketInsights
     */
    select?: MarketInsightsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketInsights
     */
    omit?: MarketInsightsOmit<ExtArgs> | null
  }


  /**
   * Model MarketAnalysis
   */

  export type AggregateMarketAnalysis = {
    _count: MarketAnalysisCountAggregateOutputType | null
    _min: MarketAnalysisMinAggregateOutputType | null
    _max: MarketAnalysisMaxAggregateOutputType | null
  }

  export type MarketAnalysisMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketAnalysisMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketAnalysisCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketAnalysisMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketAnalysisMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketAnalysisCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketAnalysis to aggregate.
     */
    where?: MarketAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketAnalyses to fetch.
     */
    orderBy?: MarketAnalysisOrderByWithRelationInput | MarketAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketAnalyses
    **/
    _count?: true | MarketAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketAnalysisMaxAggregateInputType
  }

  export type GetMarketAnalysisAggregateType<T extends MarketAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketAnalysis[P]>
      : GetScalarType<T[P], AggregateMarketAnalysis[P]>
  }




  export type MarketAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketAnalysisWhereInput
    orderBy?: MarketAnalysisOrderByWithAggregationInput | MarketAnalysisOrderByWithAggregationInput[]
    by: MarketAnalysisScalarFieldEnum[] | MarketAnalysisScalarFieldEnum
    having?: MarketAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketAnalysisCountAggregateInputType | true
    _min?: MarketAnalysisMinAggregateInputType
    _max?: MarketAnalysisMaxAggregateInputType
  }

  export type MarketAnalysisGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: MarketAnalysisCountAggregateOutputType | null
    _min: MarketAnalysisMinAggregateOutputType | null
    _max: MarketAnalysisMaxAggregateOutputType | null
  }

  type GetMarketAnalysisGroupByPayload<T extends MarketAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], MarketAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type MarketAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketAnalysis"]>



  export type MarketAnalysisSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["marketAnalysis"]>

  export type $MarketAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketAnalysis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketAnalysis"]>
    composites: {}
  }

  type MarketAnalysisGetPayload<S extends boolean | null | undefined | MarketAnalysisDefaultArgs> = $Result.GetResult<Prisma.$MarketAnalysisPayload, S>

  type MarketAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketAnalysisCountAggregateInputType | true
    }

  export interface MarketAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketAnalysis'], meta: { name: 'MarketAnalysis' } }
    /**
     * Find zero or one MarketAnalysis that matches the filter.
     * @param {MarketAnalysisFindUniqueArgs} args - Arguments to find a MarketAnalysis
     * @example
     * // Get one MarketAnalysis
     * const marketAnalysis = await prisma.marketAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketAnalysisFindUniqueArgs>(args: SelectSubset<T, MarketAnalysisFindUniqueArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketAnalysisFindUniqueOrThrowArgs} args - Arguments to find a MarketAnalysis
     * @example
     * // Get one MarketAnalysis
     * const marketAnalysis = await prisma.marketAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisFindFirstArgs} args - Arguments to find a MarketAnalysis
     * @example
     * // Get one MarketAnalysis
     * const marketAnalysis = await prisma.marketAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketAnalysisFindFirstArgs>(args?: SelectSubset<T, MarketAnalysisFindFirstArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisFindFirstOrThrowArgs} args - Arguments to find a MarketAnalysis
     * @example
     * // Get one MarketAnalysis
     * const marketAnalysis = await prisma.marketAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketAnalyses
     * const marketAnalyses = await prisma.marketAnalysis.findMany()
     * 
     * // Get first 10 MarketAnalyses
     * const marketAnalyses = await prisma.marketAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketAnalysisWithIdOnly = await prisma.marketAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketAnalysisFindManyArgs>(args?: SelectSubset<T, MarketAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketAnalysis.
     * @param {MarketAnalysisCreateArgs} args - Arguments to create a MarketAnalysis.
     * @example
     * // Create one MarketAnalysis
     * const MarketAnalysis = await prisma.marketAnalysis.create({
     *   data: {
     *     // ... data to create a MarketAnalysis
     *   }
     * })
     * 
     */
    create<T extends MarketAnalysisCreateArgs>(args: SelectSubset<T, MarketAnalysisCreateArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketAnalyses.
     * @param {MarketAnalysisCreateManyArgs} args - Arguments to create many MarketAnalyses.
     * @example
     * // Create many MarketAnalyses
     * const marketAnalysis = await prisma.marketAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketAnalysisCreateManyArgs>(args?: SelectSubset<T, MarketAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarketAnalysis.
     * @param {MarketAnalysisDeleteArgs} args - Arguments to delete one MarketAnalysis.
     * @example
     * // Delete one MarketAnalysis
     * const MarketAnalysis = await prisma.marketAnalysis.delete({
     *   where: {
     *     // ... filter to delete one MarketAnalysis
     *   }
     * })
     * 
     */
    delete<T extends MarketAnalysisDeleteArgs>(args: SelectSubset<T, MarketAnalysisDeleteArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketAnalysis.
     * @param {MarketAnalysisUpdateArgs} args - Arguments to update one MarketAnalysis.
     * @example
     * // Update one MarketAnalysis
     * const marketAnalysis = await prisma.marketAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketAnalysisUpdateArgs>(args: SelectSubset<T, MarketAnalysisUpdateArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketAnalyses.
     * @param {MarketAnalysisDeleteManyArgs} args - Arguments to filter MarketAnalyses to delete.
     * @example
     * // Delete a few MarketAnalyses
     * const { count } = await prisma.marketAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketAnalysisDeleteManyArgs>(args?: SelectSubset<T, MarketAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketAnalyses
     * const marketAnalysis = await prisma.marketAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketAnalysisUpdateManyArgs>(args: SelectSubset<T, MarketAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketAnalysis.
     * @param {MarketAnalysisUpsertArgs} args - Arguments to update or create a MarketAnalysis.
     * @example
     * // Update or create a MarketAnalysis
     * const marketAnalysis = await prisma.marketAnalysis.upsert({
     *   create: {
     *     // ... data to create a MarketAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends MarketAnalysisUpsertArgs>(args: SelectSubset<T, MarketAnalysisUpsertArgs<ExtArgs>>): Prisma__MarketAnalysisClient<$Result.GetResult<Prisma.$MarketAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketAnalyses that matches the filter.
     * @param {MarketAnalysisFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const marketAnalysis = await prisma.marketAnalysis.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MarketAnalysisFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MarketAnalysis.
     * @param {MarketAnalysisAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const marketAnalysis = await prisma.marketAnalysis.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MarketAnalysisAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MarketAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisCountArgs} args - Arguments to filter MarketAnalyses to count.
     * @example
     * // Count the number of MarketAnalyses
     * const count = await prisma.marketAnalysis.count({
     *   where: {
     *     // ... the filter for the MarketAnalyses we want to count
     *   }
     * })
    **/
    count<T extends MarketAnalysisCountArgs>(
      args?: Subset<T, MarketAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketAnalysisAggregateArgs>(args: Subset<T, MarketAnalysisAggregateArgs>): Prisma.PrismaPromise<GetMarketAnalysisAggregateType<T>>

    /**
     * Group by MarketAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: MarketAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketAnalysis model
   */
  readonly fields: MarketAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketAnalysis model
   */
  interface MarketAnalysisFieldRefs {
    readonly id: FieldRef<"MarketAnalysis", 'String'>
    readonly content: FieldRef<"MarketAnalysis", 'String'>
    readonly createdAt: FieldRef<"MarketAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketAnalysis findUnique
   */
  export type MarketAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MarketAnalysis to fetch.
     */
    where: MarketAnalysisWhereUniqueInput
  }

  /**
   * MarketAnalysis findUniqueOrThrow
   */
  export type MarketAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MarketAnalysis to fetch.
     */
    where: MarketAnalysisWhereUniqueInput
  }

  /**
   * MarketAnalysis findFirst
   */
  export type MarketAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MarketAnalysis to fetch.
     */
    where?: MarketAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketAnalyses to fetch.
     */
    orderBy?: MarketAnalysisOrderByWithRelationInput | MarketAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketAnalyses.
     */
    cursor?: MarketAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketAnalyses.
     */
    distinct?: MarketAnalysisScalarFieldEnum | MarketAnalysisScalarFieldEnum[]
  }

  /**
   * MarketAnalysis findFirstOrThrow
   */
  export type MarketAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MarketAnalysis to fetch.
     */
    where?: MarketAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketAnalyses to fetch.
     */
    orderBy?: MarketAnalysisOrderByWithRelationInput | MarketAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketAnalyses.
     */
    cursor?: MarketAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketAnalyses.
     */
    distinct?: MarketAnalysisScalarFieldEnum | MarketAnalysisScalarFieldEnum[]
  }

  /**
   * MarketAnalysis findMany
   */
  export type MarketAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which MarketAnalyses to fetch.
     */
    where?: MarketAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketAnalyses to fetch.
     */
    orderBy?: MarketAnalysisOrderByWithRelationInput | MarketAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketAnalyses.
     */
    cursor?: MarketAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketAnalyses.
     */
    skip?: number
    distinct?: MarketAnalysisScalarFieldEnum | MarketAnalysisScalarFieldEnum[]
  }

  /**
   * MarketAnalysis create
   */
  export type MarketAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketAnalysis.
     */
    data: XOR<MarketAnalysisCreateInput, MarketAnalysisUncheckedCreateInput>
  }

  /**
   * MarketAnalysis createMany
   */
  export type MarketAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketAnalyses.
     */
    data: MarketAnalysisCreateManyInput | MarketAnalysisCreateManyInput[]
  }

  /**
   * MarketAnalysis update
   */
  export type MarketAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketAnalysis.
     */
    data: XOR<MarketAnalysisUpdateInput, MarketAnalysisUncheckedUpdateInput>
    /**
     * Choose, which MarketAnalysis to update.
     */
    where: MarketAnalysisWhereUniqueInput
  }

  /**
   * MarketAnalysis updateMany
   */
  export type MarketAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketAnalyses.
     */
    data: XOR<MarketAnalysisUpdateManyMutationInput, MarketAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which MarketAnalyses to update
     */
    where?: MarketAnalysisWhereInput
    /**
     * Limit how many MarketAnalyses to update.
     */
    limit?: number
  }

  /**
   * MarketAnalysis upsert
   */
  export type MarketAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketAnalysis to update in case it exists.
     */
    where: MarketAnalysisWhereUniqueInput
    /**
     * In case the MarketAnalysis found by the `where` argument doesn't exist, create a new MarketAnalysis with this data.
     */
    create: XOR<MarketAnalysisCreateInput, MarketAnalysisUncheckedCreateInput>
    /**
     * In case the MarketAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketAnalysisUpdateInput, MarketAnalysisUncheckedUpdateInput>
  }

  /**
   * MarketAnalysis delete
   */
  export type MarketAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
    /**
     * Filter which MarketAnalysis to delete.
     */
    where: MarketAnalysisWhereUniqueInput
  }

  /**
   * MarketAnalysis deleteMany
   */
  export type MarketAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketAnalyses to delete
     */
    where?: MarketAnalysisWhereInput
    /**
     * Limit how many MarketAnalyses to delete.
     */
    limit?: number
  }

  /**
   * MarketAnalysis findRaw
   */
  export type MarketAnalysisFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketAnalysis aggregateRaw
   */
  export type MarketAnalysisAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MarketAnalysis without action
   */
  export type MarketAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketAnalysis
     */
    select?: MarketAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketAnalysis
     */
    omit?: MarketAnalysisOmit<ExtArgs> | null
  }


  /**
   * Model Press
   */

  export type AggregatePress = {
    _count: PressCountAggregateOutputType | null
    _min: PressMinAggregateOutputType | null
    _max: PressMaxAggregateOutputType | null
  }

  export type PressMinAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PressMaxAggregateOutputType = {
    id: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PressCountAggregateOutputType = {
    id: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PressMinAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PressMaxAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PressCountAggregateInputType = {
    id?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Press to aggregate.
     */
    where?: PressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presses to fetch.
     */
    orderBy?: PressOrderByWithRelationInput | PressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Presses
    **/
    _count?: true | PressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PressMaxAggregateInputType
  }

  export type GetPressAggregateType<T extends PressAggregateArgs> = {
        [P in keyof T & keyof AggregatePress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePress[P]>
      : GetScalarType<T[P], AggregatePress[P]>
  }




  export type PressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PressWhereInput
    orderBy?: PressOrderByWithAggregationInput | PressOrderByWithAggregationInput[]
    by: PressScalarFieldEnum[] | PressScalarFieldEnum
    having?: PressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PressCountAggregateInputType | true
    _min?: PressMinAggregateInputType
    _max?: PressMaxAggregateInputType
  }

  export type PressGroupByOutputType = {
    id: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: PressCountAggregateOutputType | null
    _min: PressMinAggregateOutputType | null
    _max: PressMaxAggregateOutputType | null
  }

  type GetPressGroupByPayload<T extends PressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PressGroupByOutputType[P]>
            : GetScalarType<T[P], PressGroupByOutputType[P]>
        }
      >
    >


  export type PressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["press"]>



  export type PressSelectScalar = {
    id?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["press"]>

  export type $PressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Press"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["press"]>
    composites: {}
  }

  type PressGetPayload<S extends boolean | null | undefined | PressDefaultArgs> = $Result.GetResult<Prisma.$PressPayload, S>

  type PressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PressCountAggregateInputType | true
    }

  export interface PressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Press'], meta: { name: 'Press' } }
    /**
     * Find zero or one Press that matches the filter.
     * @param {PressFindUniqueArgs} args - Arguments to find a Press
     * @example
     * // Get one Press
     * const press = await prisma.press.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PressFindUniqueArgs>(args: SelectSubset<T, PressFindUniqueArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Press that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PressFindUniqueOrThrowArgs} args - Arguments to find a Press
     * @example
     * // Get one Press
     * const press = await prisma.press.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PressFindUniqueOrThrowArgs>(args: SelectSubset<T, PressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Press that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressFindFirstArgs} args - Arguments to find a Press
     * @example
     * // Get one Press
     * const press = await prisma.press.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PressFindFirstArgs>(args?: SelectSubset<T, PressFindFirstArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Press that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressFindFirstOrThrowArgs} args - Arguments to find a Press
     * @example
     * // Get one Press
     * const press = await prisma.press.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PressFindFirstOrThrowArgs>(args?: SelectSubset<T, PressFindFirstOrThrowArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Presses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Presses
     * const presses = await prisma.press.findMany()
     * 
     * // Get first 10 Presses
     * const presses = await prisma.press.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pressWithIdOnly = await prisma.press.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PressFindManyArgs>(args?: SelectSubset<T, PressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Press.
     * @param {PressCreateArgs} args - Arguments to create a Press.
     * @example
     * // Create one Press
     * const Press = await prisma.press.create({
     *   data: {
     *     // ... data to create a Press
     *   }
     * })
     * 
     */
    create<T extends PressCreateArgs>(args: SelectSubset<T, PressCreateArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Presses.
     * @param {PressCreateManyArgs} args - Arguments to create many Presses.
     * @example
     * // Create many Presses
     * const press = await prisma.press.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PressCreateManyArgs>(args?: SelectSubset<T, PressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Press.
     * @param {PressDeleteArgs} args - Arguments to delete one Press.
     * @example
     * // Delete one Press
     * const Press = await prisma.press.delete({
     *   where: {
     *     // ... filter to delete one Press
     *   }
     * })
     * 
     */
    delete<T extends PressDeleteArgs>(args: SelectSubset<T, PressDeleteArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Press.
     * @param {PressUpdateArgs} args - Arguments to update one Press.
     * @example
     * // Update one Press
     * const press = await prisma.press.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PressUpdateArgs>(args: SelectSubset<T, PressUpdateArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Presses.
     * @param {PressDeleteManyArgs} args - Arguments to filter Presses to delete.
     * @example
     * // Delete a few Presses
     * const { count } = await prisma.press.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PressDeleteManyArgs>(args?: SelectSubset<T, PressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Presses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Presses
     * const press = await prisma.press.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PressUpdateManyArgs>(args: SelectSubset<T, PressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Press.
     * @param {PressUpsertArgs} args - Arguments to update or create a Press.
     * @example
     * // Update or create a Press
     * const press = await prisma.press.upsert({
     *   create: {
     *     // ... data to create a Press
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Press we want to update
     *   }
     * })
     */
    upsert<T extends PressUpsertArgs>(args: SelectSubset<T, PressUpsertArgs<ExtArgs>>): Prisma__PressClient<$Result.GetResult<Prisma.$PressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Presses that matches the filter.
     * @param {PressFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const press = await prisma.press.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PressFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Press.
     * @param {PressAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const press = await prisma.press.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PressAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Presses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressCountArgs} args - Arguments to filter Presses to count.
     * @example
     * // Count the number of Presses
     * const count = await prisma.press.count({
     *   where: {
     *     // ... the filter for the Presses we want to count
     *   }
     * })
    **/
    count<T extends PressCountArgs>(
      args?: Subset<T, PressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Press.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PressAggregateArgs>(args: Subset<T, PressAggregateArgs>): Prisma.PrismaPromise<GetPressAggregateType<T>>

    /**
     * Group by Press.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PressGroupByArgs['orderBy'] }
        : { orderBy?: PressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Press model
   */
  readonly fields: PressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Press.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Press model
   */
  interface PressFieldRefs {
    readonly id: FieldRef<"Press", 'String'>
    readonly content: FieldRef<"Press", 'String'>
    readonly createdAt: FieldRef<"Press", 'DateTime'>
    readonly updatedAt: FieldRef<"Press", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Press findUnique
   */
  export type PressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * Filter, which Press to fetch.
     */
    where: PressWhereUniqueInput
  }

  /**
   * Press findUniqueOrThrow
   */
  export type PressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * Filter, which Press to fetch.
     */
    where: PressWhereUniqueInput
  }

  /**
   * Press findFirst
   */
  export type PressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * Filter, which Press to fetch.
     */
    where?: PressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presses to fetch.
     */
    orderBy?: PressOrderByWithRelationInput | PressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presses.
     */
    cursor?: PressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presses.
     */
    distinct?: PressScalarFieldEnum | PressScalarFieldEnum[]
  }

  /**
   * Press findFirstOrThrow
   */
  export type PressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * Filter, which Press to fetch.
     */
    where?: PressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presses to fetch.
     */
    orderBy?: PressOrderByWithRelationInput | PressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Presses.
     */
    cursor?: PressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Presses.
     */
    distinct?: PressScalarFieldEnum | PressScalarFieldEnum[]
  }

  /**
   * Press findMany
   */
  export type PressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * Filter, which Presses to fetch.
     */
    where?: PressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Presses to fetch.
     */
    orderBy?: PressOrderByWithRelationInput | PressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Presses.
     */
    cursor?: PressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Presses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Presses.
     */
    skip?: number
    distinct?: PressScalarFieldEnum | PressScalarFieldEnum[]
  }

  /**
   * Press create
   */
  export type PressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * The data needed to create a Press.
     */
    data: XOR<PressCreateInput, PressUncheckedCreateInput>
  }

  /**
   * Press createMany
   */
  export type PressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Presses.
     */
    data: PressCreateManyInput | PressCreateManyInput[]
  }

  /**
   * Press update
   */
  export type PressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * The data needed to update a Press.
     */
    data: XOR<PressUpdateInput, PressUncheckedUpdateInput>
    /**
     * Choose, which Press to update.
     */
    where: PressWhereUniqueInput
  }

  /**
   * Press updateMany
   */
  export type PressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Presses.
     */
    data: XOR<PressUpdateManyMutationInput, PressUncheckedUpdateManyInput>
    /**
     * Filter which Presses to update
     */
    where?: PressWhereInput
    /**
     * Limit how many Presses to update.
     */
    limit?: number
  }

  /**
   * Press upsert
   */
  export type PressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * The filter to search for the Press to update in case it exists.
     */
    where: PressWhereUniqueInput
    /**
     * In case the Press found by the `where` argument doesn't exist, create a new Press with this data.
     */
    create: XOR<PressCreateInput, PressUncheckedCreateInput>
    /**
     * In case the Press was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PressUpdateInput, PressUncheckedUpdateInput>
  }

  /**
   * Press delete
   */
  export type PressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
    /**
     * Filter which Press to delete.
     */
    where: PressWhereUniqueInput
  }

  /**
   * Press deleteMany
   */
  export type PressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Presses to delete
     */
    where?: PressWhereInput
    /**
     * Limit how many Presses to delete.
     */
    limit?: number
  }

  /**
   * Press findRaw
   */
  export type PressFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Press aggregateRaw
   */
  export type PressAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Press without action
   */
  export type PressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Press
     */
    select?: PressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Press
     */
    omit?: PressOmit<ExtArgs> | null
  }


  /**
   * Model Blog
   */

  export type AggregateBlog = {
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  export type BlogAvgAggregateOutputType = {
    views: number | null
  }

  export type BlogSumAggregateOutputType = {
    views: number | null
  }

  export type BlogMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    shortDescription: string | null
    longDescription: string | null
    image: string | null
    imagePublicId: string | null
    category: string | null
    categorySlug: string | null
    location: string | null
    isFeatured: boolean | null
    authorName: string | null
    authorImage: string | null
    authorImagePublicId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    shortDescription: string | null
    longDescription: string | null
    image: string | null
    imagePublicId: string | null
    category: string | null
    categorySlug: string | null
    location: string | null
    isFeatured: boolean | null
    authorName: string | null
    authorImage: string | null
    authorImagePublicId: string | null
    views: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    shortDescription: number
    longDescription: number
    image: number
    imagePublicId: number
    category: number
    categorySlug: number
    tags: number
    location: number
    isFeatured: number
    authorName: number
    authorImage: number
    authorImagePublicId: number
    views: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogAvgAggregateInputType = {
    views?: true
  }

  export type BlogSumAggregateInputType = {
    views?: true
  }

  export type BlogMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    shortDescription?: true
    longDescription?: true
    image?: true
    imagePublicId?: true
    category?: true
    categorySlug?: true
    location?: true
    isFeatured?: true
    authorName?: true
    authorImage?: true
    authorImagePublicId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    shortDescription?: true
    longDescription?: true
    image?: true
    imagePublicId?: true
    category?: true
    categorySlug?: true
    location?: true
    isFeatured?: true
    authorName?: true
    authorImage?: true
    authorImagePublicId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    shortDescription?: true
    longDescription?: true
    image?: true
    imagePublicId?: true
    category?: true
    categorySlug?: true
    tags?: true
    location?: true
    isFeatured?: true
    authorName?: true
    authorImage?: true
    authorImagePublicId?: true
    views?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blog to aggregate.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blogs
    **/
    _count?: true | BlogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogMaxAggregateInputType
  }

  export type GetBlogAggregateType<T extends BlogAggregateArgs> = {
        [P in keyof T & keyof AggregateBlog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlog[P]>
      : GetScalarType<T[P], AggregateBlog[P]>
  }




  export type BlogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogWhereInput
    orderBy?: BlogOrderByWithAggregationInput | BlogOrderByWithAggregationInput[]
    by: BlogScalarFieldEnum[] | BlogScalarFieldEnum
    having?: BlogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogCountAggregateInputType | true
    _avg?: BlogAvgAggregateInputType
    _sum?: BlogSumAggregateInputType
    _min?: BlogMinAggregateInputType
    _max?: BlogMaxAggregateInputType
  }

  export type BlogGroupByOutputType = {
    id: string
    title: string
    slug: string
    shortDescription: string
    longDescription: string
    image: string
    imagePublicId: string | null
    category: string
    categorySlug: string
    tags: string[]
    location: string | null
    isFeatured: boolean
    authorName: string
    authorImage: string
    authorImagePublicId: string | null
    views: number
    createdAt: Date
    updatedAt: Date
    _count: BlogCountAggregateOutputType | null
    _avg: BlogAvgAggregateOutputType | null
    _sum: BlogSumAggregateOutputType | null
    _min: BlogMinAggregateOutputType | null
    _max: BlogMaxAggregateOutputType | null
  }

  type GetBlogGroupByPayload<T extends BlogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogGroupByOutputType[P]>
            : GetScalarType<T[P], BlogGroupByOutputType[P]>
        }
      >
    >


  export type BlogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    image?: boolean
    imagePublicId?: boolean
    category?: boolean
    categorySlug?: boolean
    tags?: boolean
    location?: boolean
    isFeatured?: boolean
    authorName?: boolean
    authorImage?: boolean
    authorImagePublicId?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blog"]>



  export type BlogSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    image?: boolean
    imagePublicId?: boolean
    category?: boolean
    categorySlug?: boolean
    tags?: boolean
    location?: boolean
    isFeatured?: boolean
    authorName?: boolean
    authorImage?: boolean
    authorImagePublicId?: boolean
    views?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "shortDescription" | "longDescription" | "image" | "imagePublicId" | "category" | "categorySlug" | "tags" | "location" | "isFeatured" | "authorName" | "authorImage" | "authorImagePublicId" | "views" | "createdAt" | "updatedAt", ExtArgs["result"]["blog"]>

  export type $BlogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Blog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      shortDescription: string
      longDescription: string
      image: string
      imagePublicId: string | null
      category: string
      categorySlug: string
      tags: string[]
      location: string | null
      isFeatured: boolean
      authorName: string
      authorImage: string
      authorImagePublicId: string | null
      views: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blog"]>
    composites: {}
  }

  type BlogGetPayload<S extends boolean | null | undefined | BlogDefaultArgs> = $Result.GetResult<Prisma.$BlogPayload, S>

  type BlogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogCountAggregateInputType | true
    }

  export interface BlogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Blog'], meta: { name: 'Blog' } }
    /**
     * Find zero or one Blog that matches the filter.
     * @param {BlogFindUniqueArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogFindUniqueArgs>(args: SelectSubset<T, BlogFindUniqueArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogFindUniqueOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogFindFirstArgs>(args?: SelectSubset<T, BlogFindFirstArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindFirstOrThrowArgs} args - Arguments to find a Blog
     * @example
     * // Get one Blog
     * const blog = await prisma.blog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blog.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogWithIdOnly = await prisma.blog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogFindManyArgs>(args?: SelectSubset<T, BlogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blog.
     * @param {BlogCreateArgs} args - Arguments to create a Blog.
     * @example
     * // Create one Blog
     * const Blog = await prisma.blog.create({
     *   data: {
     *     // ... data to create a Blog
     *   }
     * })
     * 
     */
    create<T extends BlogCreateArgs>(args: SelectSubset<T, BlogCreateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {BlogCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blog = await prisma.blog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogCreateManyArgs>(args?: SelectSubset<T, BlogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Blog.
     * @param {BlogDeleteArgs} args - Arguments to delete one Blog.
     * @example
     * // Delete one Blog
     * const Blog = await prisma.blog.delete({
     *   where: {
     *     // ... filter to delete one Blog
     *   }
     * })
     * 
     */
    delete<T extends BlogDeleteArgs>(args: SelectSubset<T, BlogDeleteArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blog.
     * @param {BlogUpdateArgs} args - Arguments to update one Blog.
     * @example
     * // Update one Blog
     * const blog = await prisma.blog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogUpdateArgs>(args: SelectSubset<T, BlogUpdateArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {BlogDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogDeleteManyArgs>(args?: SelectSubset<T, BlogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blog = await prisma.blog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogUpdateManyArgs>(args: SelectSubset<T, BlogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Blog.
     * @param {BlogUpsertArgs} args - Arguments to update or create a Blog.
     * @example
     * // Update or create a Blog
     * const blog = await prisma.blog.upsert({
     *   create: {
     *     // ... data to create a Blog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blog we want to update
     *   }
     * })
     */
    upsert<T extends BlogUpsertArgs>(args: SelectSubset<T, BlogUpsertArgs<ExtArgs>>): Prisma__BlogClient<$Result.GetResult<Prisma.$BlogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * @param {BlogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const blog = await prisma.blog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BlogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Blog.
     * @param {BlogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const blog = await prisma.blog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BlogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blog.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends BlogCountArgs>(
      args?: Subset<T, BlogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogAggregateArgs>(args: Subset<T, BlogAggregateArgs>): Prisma.PrismaPromise<GetBlogAggregateType<T>>

    /**
     * Group by Blog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogGroupByArgs['orderBy'] }
        : { orderBy?: BlogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Blog model
   */
  readonly fields: BlogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Blog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Blog model
   */
  interface BlogFieldRefs {
    readonly id: FieldRef<"Blog", 'String'>
    readonly title: FieldRef<"Blog", 'String'>
    readonly slug: FieldRef<"Blog", 'String'>
    readonly shortDescription: FieldRef<"Blog", 'String'>
    readonly longDescription: FieldRef<"Blog", 'String'>
    readonly image: FieldRef<"Blog", 'String'>
    readonly imagePublicId: FieldRef<"Blog", 'String'>
    readonly category: FieldRef<"Blog", 'String'>
    readonly categorySlug: FieldRef<"Blog", 'String'>
    readonly tags: FieldRef<"Blog", 'String[]'>
    readonly location: FieldRef<"Blog", 'String'>
    readonly isFeatured: FieldRef<"Blog", 'Boolean'>
    readonly authorName: FieldRef<"Blog", 'String'>
    readonly authorImage: FieldRef<"Blog", 'String'>
    readonly authorImagePublicId: FieldRef<"Blog", 'String'>
    readonly views: FieldRef<"Blog", 'Int'>
    readonly createdAt: FieldRef<"Blog", 'DateTime'>
    readonly updatedAt: FieldRef<"Blog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Blog findUnique
   */
  export type BlogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findUniqueOrThrow
   */
  export type BlogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog findFirst
   */
  export type BlogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findFirstOrThrow
   */
  export type BlogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blog to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blogs.
     */
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog findMany
   */
  export type BlogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter, which Blogs to fetch.
     */
    where?: BlogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blogs to fetch.
     */
    orderBy?: BlogOrderByWithRelationInput | BlogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blogs.
     */
    cursor?: BlogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blogs.
     */
    skip?: number
    distinct?: BlogScalarFieldEnum | BlogScalarFieldEnum[]
  }

  /**
   * Blog create
   */
  export type BlogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data needed to create a Blog.
     */
    data: XOR<BlogCreateInput, BlogUncheckedCreateInput>
  }

  /**
   * Blog createMany
   */
  export type BlogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blogs.
     */
    data: BlogCreateManyInput | BlogCreateManyInput[]
  }

  /**
   * Blog update
   */
  export type BlogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The data needed to update a Blog.
     */
    data: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
    /**
     * Choose, which Blog to update.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog updateMany
   */
  export type BlogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blogs.
     */
    data: XOR<BlogUpdateManyMutationInput, BlogUncheckedUpdateManyInput>
    /**
     * Filter which Blogs to update
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to update.
     */
    limit?: number
  }

  /**
   * Blog upsert
   */
  export type BlogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * The filter to search for the Blog to update in case it exists.
     */
    where: BlogWhereUniqueInput
    /**
     * In case the Blog found by the `where` argument doesn't exist, create a new Blog with this data.
     */
    create: XOR<BlogCreateInput, BlogUncheckedCreateInput>
    /**
     * In case the Blog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogUpdateInput, BlogUncheckedUpdateInput>
  }

  /**
   * Blog delete
   */
  export type BlogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
    /**
     * Filter which Blog to delete.
     */
    where: BlogWhereUniqueInput
  }

  /**
   * Blog deleteMany
   */
  export type BlogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blogs to delete
     */
    where?: BlogWhereInput
    /**
     * Limit how many Blogs to delete.
     */
    limit?: number
  }

  /**
   * Blog findRaw
   */
  export type BlogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Blog aggregateRaw
   */
  export type BlogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Blog without action
   */
  export type BlogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blog
     */
    select?: BlogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Blog
     */
    omit?: BlogOmit<ExtArgs> | null
  }


  /**
   * Model EmailConfiguration
   */

  export type AggregateEmailConfiguration = {
    _count: EmailConfigurationCountAggregateOutputType | null
    _avg: EmailConfigurationAvgAggregateOutputType | null
    _sum: EmailConfigurationSumAggregateOutputType | null
    _min: EmailConfigurationMinAggregateOutputType | null
    _max: EmailConfigurationMaxAggregateOutputType | null
  }

  export type EmailConfigurationAvgAggregateOutputType = {
    emailPort: number | null
  }

  export type EmailConfigurationSumAggregateOutputType = {
    emailPort: number | null
  }

  export type EmailConfigurationMinAggregateOutputType = {
    id: string | null
    emailMailer: string | null
    emailHost: string | null
    emailPort: number | null
    emailUserName: string | null
    emailPassword: string | null
    emailEncryption: string | null
    emailFromName: string | null
    emailAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailConfigurationMaxAggregateOutputType = {
    id: string | null
    emailMailer: string | null
    emailHost: string | null
    emailPort: number | null
    emailUserName: string | null
    emailPassword: string | null
    emailEncryption: string | null
    emailFromName: string | null
    emailAddress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailConfigurationCountAggregateOutputType = {
    id: number
    emailMailer: number
    emailHost: number
    emailPort: number
    emailUserName: number
    emailPassword: number
    emailEncryption: number
    emailFromName: number
    emailAddress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailConfigurationAvgAggregateInputType = {
    emailPort?: true
  }

  export type EmailConfigurationSumAggregateInputType = {
    emailPort?: true
  }

  export type EmailConfigurationMinAggregateInputType = {
    id?: true
    emailMailer?: true
    emailHost?: true
    emailPort?: true
    emailUserName?: true
    emailPassword?: true
    emailEncryption?: true
    emailFromName?: true
    emailAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailConfigurationMaxAggregateInputType = {
    id?: true
    emailMailer?: true
    emailHost?: true
    emailPort?: true
    emailUserName?: true
    emailPassword?: true
    emailEncryption?: true
    emailFromName?: true
    emailAddress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailConfigurationCountAggregateInputType = {
    id?: true
    emailMailer?: true
    emailHost?: true
    emailPort?: true
    emailUserName?: true
    emailPassword?: true
    emailEncryption?: true
    emailFromName?: true
    emailAddress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailConfiguration to aggregate.
     */
    where?: EmailConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigurations to fetch.
     */
    orderBy?: EmailConfigurationOrderByWithRelationInput | EmailConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailConfigurations
    **/
    _count?: true | EmailConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailConfigurationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailConfigurationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailConfigurationMaxAggregateInputType
  }

  export type GetEmailConfigurationAggregateType<T extends EmailConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailConfiguration[P]>
      : GetScalarType<T[P], AggregateEmailConfiguration[P]>
  }




  export type EmailConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailConfigurationWhereInput
    orderBy?: EmailConfigurationOrderByWithAggregationInput | EmailConfigurationOrderByWithAggregationInput[]
    by: EmailConfigurationScalarFieldEnum[] | EmailConfigurationScalarFieldEnum
    having?: EmailConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailConfigurationCountAggregateInputType | true
    _avg?: EmailConfigurationAvgAggregateInputType
    _sum?: EmailConfigurationSumAggregateInputType
    _min?: EmailConfigurationMinAggregateInputType
    _max?: EmailConfigurationMaxAggregateInputType
  }

  export type EmailConfigurationGroupByOutputType = {
    id: string
    emailMailer: string
    emailHost: string
    emailPort: number
    emailUserName: string
    emailPassword: string
    emailEncryption: string
    emailFromName: string
    emailAddress: string
    createdAt: Date
    updatedAt: Date
    _count: EmailConfigurationCountAggregateOutputType | null
    _avg: EmailConfigurationAvgAggregateOutputType | null
    _sum: EmailConfigurationSumAggregateOutputType | null
    _min: EmailConfigurationMinAggregateOutputType | null
    _max: EmailConfigurationMaxAggregateOutputType | null
  }

  type GetEmailConfigurationGroupByPayload<T extends EmailConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type EmailConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    emailMailer?: boolean
    emailHost?: boolean
    emailPort?: boolean
    emailUserName?: boolean
    emailPassword?: boolean
    emailEncryption?: boolean
    emailFromName?: boolean
    emailAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["emailConfiguration"]>



  export type EmailConfigurationSelectScalar = {
    id?: boolean
    emailMailer?: boolean
    emailHost?: boolean
    emailPort?: boolean
    emailUserName?: boolean
    emailPassword?: boolean
    emailEncryption?: boolean
    emailFromName?: boolean
    emailAddress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "emailMailer" | "emailHost" | "emailPort" | "emailUserName" | "emailPassword" | "emailEncryption" | "emailFromName" | "emailAddress" | "createdAt" | "updatedAt", ExtArgs["result"]["emailConfiguration"]>

  export type $EmailConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      emailMailer: string
      emailHost: string
      emailPort: number
      emailUserName: string
      emailPassword: string
      emailEncryption: string
      emailFromName: string
      emailAddress: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailConfiguration"]>
    composites: {}
  }

  type EmailConfigurationGetPayload<S extends boolean | null | undefined | EmailConfigurationDefaultArgs> = $Result.GetResult<Prisma.$EmailConfigurationPayload, S>

  type EmailConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailConfigurationCountAggregateInputType | true
    }

  export interface EmailConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailConfiguration'], meta: { name: 'EmailConfiguration' } }
    /**
     * Find zero or one EmailConfiguration that matches the filter.
     * @param {EmailConfigurationFindUniqueArgs} args - Arguments to find a EmailConfiguration
     * @example
     * // Get one EmailConfiguration
     * const emailConfiguration = await prisma.emailConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailConfigurationFindUniqueArgs>(args: SelectSubset<T, EmailConfigurationFindUniqueArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailConfigurationFindUniqueOrThrowArgs} args - Arguments to find a EmailConfiguration
     * @example
     * // Get one EmailConfiguration
     * const emailConfiguration = await prisma.emailConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationFindFirstArgs} args - Arguments to find a EmailConfiguration
     * @example
     * // Get one EmailConfiguration
     * const emailConfiguration = await prisma.emailConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailConfigurationFindFirstArgs>(args?: SelectSubset<T, EmailConfigurationFindFirstArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationFindFirstOrThrowArgs} args - Arguments to find a EmailConfiguration
     * @example
     * // Get one EmailConfiguration
     * const emailConfiguration = await prisma.emailConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailConfigurations
     * const emailConfigurations = await prisma.emailConfiguration.findMany()
     * 
     * // Get first 10 EmailConfigurations
     * const emailConfigurations = await prisma.emailConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailConfigurationWithIdOnly = await prisma.emailConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailConfigurationFindManyArgs>(args?: SelectSubset<T, EmailConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailConfiguration.
     * @param {EmailConfigurationCreateArgs} args - Arguments to create a EmailConfiguration.
     * @example
     * // Create one EmailConfiguration
     * const EmailConfiguration = await prisma.emailConfiguration.create({
     *   data: {
     *     // ... data to create a EmailConfiguration
     *   }
     * })
     * 
     */
    create<T extends EmailConfigurationCreateArgs>(args: SelectSubset<T, EmailConfigurationCreateArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailConfigurations.
     * @param {EmailConfigurationCreateManyArgs} args - Arguments to create many EmailConfigurations.
     * @example
     * // Create many EmailConfigurations
     * const emailConfiguration = await prisma.emailConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailConfigurationCreateManyArgs>(args?: SelectSubset<T, EmailConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailConfiguration.
     * @param {EmailConfigurationDeleteArgs} args - Arguments to delete one EmailConfiguration.
     * @example
     * // Delete one EmailConfiguration
     * const EmailConfiguration = await prisma.emailConfiguration.delete({
     *   where: {
     *     // ... filter to delete one EmailConfiguration
     *   }
     * })
     * 
     */
    delete<T extends EmailConfigurationDeleteArgs>(args: SelectSubset<T, EmailConfigurationDeleteArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailConfiguration.
     * @param {EmailConfigurationUpdateArgs} args - Arguments to update one EmailConfiguration.
     * @example
     * // Update one EmailConfiguration
     * const emailConfiguration = await prisma.emailConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailConfigurationUpdateArgs>(args: SelectSubset<T, EmailConfigurationUpdateArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailConfigurations.
     * @param {EmailConfigurationDeleteManyArgs} args - Arguments to filter EmailConfigurations to delete.
     * @example
     * // Delete a few EmailConfigurations
     * const { count } = await prisma.emailConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailConfigurationDeleteManyArgs>(args?: SelectSubset<T, EmailConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailConfigurations
     * const emailConfiguration = await prisma.emailConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailConfigurationUpdateManyArgs>(args: SelectSubset<T, EmailConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailConfiguration.
     * @param {EmailConfigurationUpsertArgs} args - Arguments to update or create a EmailConfiguration.
     * @example
     * // Update or create a EmailConfiguration
     * const emailConfiguration = await prisma.emailConfiguration.upsert({
     *   create: {
     *     // ... data to create a EmailConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends EmailConfigurationUpsertArgs>(args: SelectSubset<T, EmailConfigurationUpsertArgs<ExtArgs>>): Prisma__EmailConfigurationClient<$Result.GetResult<Prisma.$EmailConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailConfigurations that matches the filter.
     * @param {EmailConfigurationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const emailConfiguration = await prisma.emailConfiguration.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EmailConfigurationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EmailConfiguration.
     * @param {EmailConfigurationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const emailConfiguration = await prisma.emailConfiguration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EmailConfigurationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of EmailConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationCountArgs} args - Arguments to filter EmailConfigurations to count.
     * @example
     * // Count the number of EmailConfigurations
     * const count = await prisma.emailConfiguration.count({
     *   where: {
     *     // ... the filter for the EmailConfigurations we want to count
     *   }
     * })
    **/
    count<T extends EmailConfigurationCountArgs>(
      args?: Subset<T, EmailConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailConfigurationAggregateArgs>(args: Subset<T, EmailConfigurationAggregateArgs>): Prisma.PrismaPromise<GetEmailConfigurationAggregateType<T>>

    /**
     * Group by EmailConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: EmailConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailConfiguration model
   */
  readonly fields: EmailConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailConfiguration model
   */
  interface EmailConfigurationFieldRefs {
    readonly id: FieldRef<"EmailConfiguration", 'String'>
    readonly emailMailer: FieldRef<"EmailConfiguration", 'String'>
    readonly emailHost: FieldRef<"EmailConfiguration", 'String'>
    readonly emailPort: FieldRef<"EmailConfiguration", 'Int'>
    readonly emailUserName: FieldRef<"EmailConfiguration", 'String'>
    readonly emailPassword: FieldRef<"EmailConfiguration", 'String'>
    readonly emailEncryption: FieldRef<"EmailConfiguration", 'String'>
    readonly emailFromName: FieldRef<"EmailConfiguration", 'String'>
    readonly emailAddress: FieldRef<"EmailConfiguration", 'String'>
    readonly createdAt: FieldRef<"EmailConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailConfiguration findUnique
   */
  export type EmailConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which EmailConfiguration to fetch.
     */
    where: EmailConfigurationWhereUniqueInput
  }

  /**
   * EmailConfiguration findUniqueOrThrow
   */
  export type EmailConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which EmailConfiguration to fetch.
     */
    where: EmailConfigurationWhereUniqueInput
  }

  /**
   * EmailConfiguration findFirst
   */
  export type EmailConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which EmailConfiguration to fetch.
     */
    where?: EmailConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigurations to fetch.
     */
    orderBy?: EmailConfigurationOrderByWithRelationInput | EmailConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailConfigurations.
     */
    cursor?: EmailConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailConfigurations.
     */
    distinct?: EmailConfigurationScalarFieldEnum | EmailConfigurationScalarFieldEnum[]
  }

  /**
   * EmailConfiguration findFirstOrThrow
   */
  export type EmailConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which EmailConfiguration to fetch.
     */
    where?: EmailConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigurations to fetch.
     */
    orderBy?: EmailConfigurationOrderByWithRelationInput | EmailConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailConfigurations.
     */
    cursor?: EmailConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailConfigurations.
     */
    distinct?: EmailConfigurationScalarFieldEnum | EmailConfigurationScalarFieldEnum[]
  }

  /**
   * EmailConfiguration findMany
   */
  export type EmailConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which EmailConfigurations to fetch.
     */
    where?: EmailConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailConfigurations to fetch.
     */
    orderBy?: EmailConfigurationOrderByWithRelationInput | EmailConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailConfigurations.
     */
    cursor?: EmailConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailConfigurations.
     */
    skip?: number
    distinct?: EmailConfigurationScalarFieldEnum | EmailConfigurationScalarFieldEnum[]
  }

  /**
   * EmailConfiguration create
   */
  export type EmailConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a EmailConfiguration.
     */
    data: XOR<EmailConfigurationCreateInput, EmailConfigurationUncheckedCreateInput>
  }

  /**
   * EmailConfiguration createMany
   */
  export type EmailConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailConfigurations.
     */
    data: EmailConfigurationCreateManyInput | EmailConfigurationCreateManyInput[]
  }

  /**
   * EmailConfiguration update
   */
  export type EmailConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a EmailConfiguration.
     */
    data: XOR<EmailConfigurationUpdateInput, EmailConfigurationUncheckedUpdateInput>
    /**
     * Choose, which EmailConfiguration to update.
     */
    where: EmailConfigurationWhereUniqueInput
  }

  /**
   * EmailConfiguration updateMany
   */
  export type EmailConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailConfigurations.
     */
    data: XOR<EmailConfigurationUpdateManyMutationInput, EmailConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which EmailConfigurations to update
     */
    where?: EmailConfigurationWhereInput
    /**
     * Limit how many EmailConfigurations to update.
     */
    limit?: number
  }

  /**
   * EmailConfiguration upsert
   */
  export type EmailConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the EmailConfiguration to update in case it exists.
     */
    where: EmailConfigurationWhereUniqueInput
    /**
     * In case the EmailConfiguration found by the `where` argument doesn't exist, create a new EmailConfiguration with this data.
     */
    create: XOR<EmailConfigurationCreateInput, EmailConfigurationUncheckedCreateInput>
    /**
     * In case the EmailConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailConfigurationUpdateInput, EmailConfigurationUncheckedUpdateInput>
  }

  /**
   * EmailConfiguration delete
   */
  export type EmailConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
    /**
     * Filter which EmailConfiguration to delete.
     */
    where: EmailConfigurationWhereUniqueInput
  }

  /**
   * EmailConfiguration deleteMany
   */
  export type EmailConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailConfigurations to delete
     */
    where?: EmailConfigurationWhereInput
    /**
     * Limit how many EmailConfigurations to delete.
     */
    limit?: number
  }

  /**
   * EmailConfiguration findRaw
   */
  export type EmailConfigurationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EmailConfiguration aggregateRaw
   */
  export type EmailConfigurationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * EmailConfiguration without action
   */
  export type EmailConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailConfiguration
     */
    select?: EmailConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailConfiguration
     */
    omit?: EmailConfigurationOmit<ExtArgs> | null
  }


  /**
   * Model StripeConfiguration
   */

  export type AggregateStripeConfiguration = {
    _count: StripeConfigurationCountAggregateOutputType | null
    _min: StripeConfigurationMinAggregateOutputType | null
    _max: StripeConfigurationMaxAggregateOutputType | null
  }

  export type StripeConfigurationMinAggregateOutputType = {
    id: string | null
    stripeKey: string | null
    stripeSecret: string | null
    stripeMethod: string | null
    stripeWebhookSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeConfigurationMaxAggregateOutputType = {
    id: string | null
    stripeKey: string | null
    stripeSecret: string | null
    stripeMethod: string | null
    stripeWebhookSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeConfigurationCountAggregateOutputType = {
    id: number
    stripeKey: number
    stripeSecret: number
    stripeMethod: number
    stripeWebhookSecret: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeConfigurationMinAggregateInputType = {
    id?: true
    stripeKey?: true
    stripeSecret?: true
    stripeMethod?: true
    stripeWebhookSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeConfigurationMaxAggregateInputType = {
    id?: true
    stripeKey?: true
    stripeSecret?: true
    stripeMethod?: true
    stripeWebhookSecret?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeConfigurationCountAggregateInputType = {
    id?: true
    stripeKey?: true
    stripeSecret?: true
    stripeMethod?: true
    stripeWebhookSecret?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeConfiguration to aggregate.
     */
    where?: StripeConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConfigurations to fetch.
     */
    orderBy?: StripeConfigurationOrderByWithRelationInput | StripeConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeConfigurations
    **/
    _count?: true | StripeConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeConfigurationMaxAggregateInputType
  }

  export type GetStripeConfigurationAggregateType<T extends StripeConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeConfiguration[P]>
      : GetScalarType<T[P], AggregateStripeConfiguration[P]>
  }




  export type StripeConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeConfigurationWhereInput
    orderBy?: StripeConfigurationOrderByWithAggregationInput | StripeConfigurationOrderByWithAggregationInput[]
    by: StripeConfigurationScalarFieldEnum[] | StripeConfigurationScalarFieldEnum
    having?: StripeConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeConfigurationCountAggregateInputType | true
    _min?: StripeConfigurationMinAggregateInputType
    _max?: StripeConfigurationMaxAggregateInputType
  }

  export type StripeConfigurationGroupByOutputType = {
    id: string
    stripeKey: string
    stripeSecret: string
    stripeMethod: string
    stripeWebhookSecret: string
    createdAt: Date
    updatedAt: Date
    _count: StripeConfigurationCountAggregateOutputType | null
    _min: StripeConfigurationMinAggregateOutputType | null
    _max: StripeConfigurationMaxAggregateOutputType | null
  }

  type GetStripeConfigurationGroupByPayload<T extends StripeConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], StripeConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type StripeConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stripeKey?: boolean
    stripeSecret?: boolean
    stripeMethod?: boolean
    stripeWebhookSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["stripeConfiguration"]>



  export type StripeConfigurationSelectScalar = {
    id?: boolean
    stripeKey?: boolean
    stripeSecret?: boolean
    stripeMethod?: boolean
    stripeWebhookSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StripeConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "stripeKey" | "stripeSecret" | "stripeMethod" | "stripeWebhookSecret" | "createdAt" | "updatedAt", ExtArgs["result"]["stripeConfiguration"]>

  export type $StripeConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      stripeKey: string
      stripeSecret: string
      stripeMethod: string
      stripeWebhookSecret: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeConfiguration"]>
    composites: {}
  }

  type StripeConfigurationGetPayload<S extends boolean | null | undefined | StripeConfigurationDefaultArgs> = $Result.GetResult<Prisma.$StripeConfigurationPayload, S>

  type StripeConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StripeConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StripeConfigurationCountAggregateInputType | true
    }

  export interface StripeConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeConfiguration'], meta: { name: 'StripeConfiguration' } }
    /**
     * Find zero or one StripeConfiguration that matches the filter.
     * @param {StripeConfigurationFindUniqueArgs} args - Arguments to find a StripeConfiguration
     * @example
     * // Get one StripeConfiguration
     * const stripeConfiguration = await prisma.stripeConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StripeConfigurationFindUniqueArgs>(args: SelectSubset<T, StripeConfigurationFindUniqueArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StripeConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StripeConfigurationFindUniqueOrThrowArgs} args - Arguments to find a StripeConfiguration
     * @example
     * // Get one StripeConfiguration
     * const stripeConfiguration = await prisma.stripeConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StripeConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, StripeConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StripeConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationFindFirstArgs} args - Arguments to find a StripeConfiguration
     * @example
     * // Get one StripeConfiguration
     * const stripeConfiguration = await prisma.stripeConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StripeConfigurationFindFirstArgs>(args?: SelectSubset<T, StripeConfigurationFindFirstArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StripeConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationFindFirstOrThrowArgs} args - Arguments to find a StripeConfiguration
     * @example
     * // Get one StripeConfiguration
     * const stripeConfiguration = await prisma.stripeConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StripeConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, StripeConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StripeConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeConfigurations
     * const stripeConfigurations = await prisma.stripeConfiguration.findMany()
     * 
     * // Get first 10 StripeConfigurations
     * const stripeConfigurations = await prisma.stripeConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeConfigurationWithIdOnly = await prisma.stripeConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StripeConfigurationFindManyArgs>(args?: SelectSubset<T, StripeConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StripeConfiguration.
     * @param {StripeConfigurationCreateArgs} args - Arguments to create a StripeConfiguration.
     * @example
     * // Create one StripeConfiguration
     * const StripeConfiguration = await prisma.stripeConfiguration.create({
     *   data: {
     *     // ... data to create a StripeConfiguration
     *   }
     * })
     * 
     */
    create<T extends StripeConfigurationCreateArgs>(args: SelectSubset<T, StripeConfigurationCreateArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StripeConfigurations.
     * @param {StripeConfigurationCreateManyArgs} args - Arguments to create many StripeConfigurations.
     * @example
     * // Create many StripeConfigurations
     * const stripeConfiguration = await prisma.stripeConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StripeConfigurationCreateManyArgs>(args?: SelectSubset<T, StripeConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StripeConfiguration.
     * @param {StripeConfigurationDeleteArgs} args - Arguments to delete one StripeConfiguration.
     * @example
     * // Delete one StripeConfiguration
     * const StripeConfiguration = await prisma.stripeConfiguration.delete({
     *   where: {
     *     // ... filter to delete one StripeConfiguration
     *   }
     * })
     * 
     */
    delete<T extends StripeConfigurationDeleteArgs>(args: SelectSubset<T, StripeConfigurationDeleteArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StripeConfiguration.
     * @param {StripeConfigurationUpdateArgs} args - Arguments to update one StripeConfiguration.
     * @example
     * // Update one StripeConfiguration
     * const stripeConfiguration = await prisma.stripeConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StripeConfigurationUpdateArgs>(args: SelectSubset<T, StripeConfigurationUpdateArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StripeConfigurations.
     * @param {StripeConfigurationDeleteManyArgs} args - Arguments to filter StripeConfigurations to delete.
     * @example
     * // Delete a few StripeConfigurations
     * const { count } = await prisma.stripeConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StripeConfigurationDeleteManyArgs>(args?: SelectSubset<T, StripeConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeConfigurations
     * const stripeConfiguration = await prisma.stripeConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StripeConfigurationUpdateManyArgs>(args: SelectSubset<T, StripeConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StripeConfiguration.
     * @param {StripeConfigurationUpsertArgs} args - Arguments to update or create a StripeConfiguration.
     * @example
     * // Update or create a StripeConfiguration
     * const stripeConfiguration = await prisma.stripeConfiguration.upsert({
     *   create: {
     *     // ... data to create a StripeConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends StripeConfigurationUpsertArgs>(args: SelectSubset<T, StripeConfigurationUpsertArgs<ExtArgs>>): Prisma__StripeConfigurationClient<$Result.GetResult<Prisma.$StripeConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StripeConfigurations that matches the filter.
     * @param {StripeConfigurationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const stripeConfiguration = await prisma.stripeConfiguration.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StripeConfigurationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a StripeConfiguration.
     * @param {StripeConfigurationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const stripeConfiguration = await prisma.stripeConfiguration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StripeConfigurationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of StripeConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationCountArgs} args - Arguments to filter StripeConfigurations to count.
     * @example
     * // Count the number of StripeConfigurations
     * const count = await prisma.stripeConfiguration.count({
     *   where: {
     *     // ... the filter for the StripeConfigurations we want to count
     *   }
     * })
    **/
    count<T extends StripeConfigurationCountArgs>(
      args?: Subset<T, StripeConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeConfigurationAggregateArgs>(args: Subset<T, StripeConfigurationAggregateArgs>): Prisma.PrismaPromise<GetStripeConfigurationAggregateType<T>>

    /**
     * Group by StripeConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: StripeConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeConfiguration model
   */
  readonly fields: StripeConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StripeConfiguration model
   */
  interface StripeConfigurationFieldRefs {
    readonly id: FieldRef<"StripeConfiguration", 'String'>
    readonly stripeKey: FieldRef<"StripeConfiguration", 'String'>
    readonly stripeSecret: FieldRef<"StripeConfiguration", 'String'>
    readonly stripeMethod: FieldRef<"StripeConfiguration", 'String'>
    readonly stripeWebhookSecret: FieldRef<"StripeConfiguration", 'String'>
    readonly createdAt: FieldRef<"StripeConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeConfiguration findUnique
   */
  export type StripeConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which StripeConfiguration to fetch.
     */
    where: StripeConfigurationWhereUniqueInput
  }

  /**
   * StripeConfiguration findUniqueOrThrow
   */
  export type StripeConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which StripeConfiguration to fetch.
     */
    where: StripeConfigurationWhereUniqueInput
  }

  /**
   * StripeConfiguration findFirst
   */
  export type StripeConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which StripeConfiguration to fetch.
     */
    where?: StripeConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConfigurations to fetch.
     */
    orderBy?: StripeConfigurationOrderByWithRelationInput | StripeConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeConfigurations.
     */
    cursor?: StripeConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeConfigurations.
     */
    distinct?: StripeConfigurationScalarFieldEnum | StripeConfigurationScalarFieldEnum[]
  }

  /**
   * StripeConfiguration findFirstOrThrow
   */
  export type StripeConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which StripeConfiguration to fetch.
     */
    where?: StripeConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConfigurations to fetch.
     */
    orderBy?: StripeConfigurationOrderByWithRelationInput | StripeConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeConfigurations.
     */
    cursor?: StripeConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeConfigurations.
     */
    distinct?: StripeConfigurationScalarFieldEnum | StripeConfigurationScalarFieldEnum[]
  }

  /**
   * StripeConfiguration findMany
   */
  export type StripeConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which StripeConfigurations to fetch.
     */
    where?: StripeConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeConfigurations to fetch.
     */
    orderBy?: StripeConfigurationOrderByWithRelationInput | StripeConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeConfigurations.
     */
    cursor?: StripeConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeConfigurations.
     */
    skip?: number
    distinct?: StripeConfigurationScalarFieldEnum | StripeConfigurationScalarFieldEnum[]
  }

  /**
   * StripeConfiguration create
   */
  export type StripeConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a StripeConfiguration.
     */
    data: XOR<StripeConfigurationCreateInput, StripeConfigurationUncheckedCreateInput>
  }

  /**
   * StripeConfiguration createMany
   */
  export type StripeConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeConfigurations.
     */
    data: StripeConfigurationCreateManyInput | StripeConfigurationCreateManyInput[]
  }

  /**
   * StripeConfiguration update
   */
  export type StripeConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a StripeConfiguration.
     */
    data: XOR<StripeConfigurationUpdateInput, StripeConfigurationUncheckedUpdateInput>
    /**
     * Choose, which StripeConfiguration to update.
     */
    where: StripeConfigurationWhereUniqueInput
  }

  /**
   * StripeConfiguration updateMany
   */
  export type StripeConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeConfigurations.
     */
    data: XOR<StripeConfigurationUpdateManyMutationInput, StripeConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which StripeConfigurations to update
     */
    where?: StripeConfigurationWhereInput
    /**
     * Limit how many StripeConfigurations to update.
     */
    limit?: number
  }

  /**
   * StripeConfiguration upsert
   */
  export type StripeConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the StripeConfiguration to update in case it exists.
     */
    where: StripeConfigurationWhereUniqueInput
    /**
     * In case the StripeConfiguration found by the `where` argument doesn't exist, create a new StripeConfiguration with this data.
     */
    create: XOR<StripeConfigurationCreateInput, StripeConfigurationUncheckedCreateInput>
    /**
     * In case the StripeConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeConfigurationUpdateInput, StripeConfigurationUncheckedUpdateInput>
  }

  /**
   * StripeConfiguration delete
   */
  export type StripeConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
    /**
     * Filter which StripeConfiguration to delete.
     */
    where: StripeConfigurationWhereUniqueInput
  }

  /**
   * StripeConfiguration deleteMany
   */
  export type StripeConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeConfigurations to delete
     */
    where?: StripeConfigurationWhereInput
    /**
     * Limit how many StripeConfigurations to delete.
     */
    limit?: number
  }

  /**
   * StripeConfiguration findRaw
   */
  export type StripeConfigurationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StripeConfiguration aggregateRaw
   */
  export type StripeConfigurationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StripeConfiguration without action
   */
  export type StripeConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeConfiguration
     */
    select?: StripeConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeConfiguration
     */
    omit?: StripeConfigurationOmit<ExtArgs> | null
  }


  /**
   * Model SellPageBanner
   */

  export type AggregateSellPageBanner = {
    _count: SellPageBannerCountAggregateOutputType | null
    _min: SellPageBannerMinAggregateOutputType | null
    _max: SellPageBannerMaxAggregateOutputType | null
  }

  export type SellPageBannerMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellPageBannerMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellPageBannerCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    imagePublicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellPageBannerMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellPageBannerMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellPageBannerCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellPageBannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellPageBanner to aggregate.
     */
    where?: SellPageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPageBanners to fetch.
     */
    orderBy?: SellPageBannerOrderByWithRelationInput | SellPageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellPageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPageBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellPageBanners
    **/
    _count?: true | SellPageBannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellPageBannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellPageBannerMaxAggregateInputType
  }

  export type GetSellPageBannerAggregateType<T extends SellPageBannerAggregateArgs> = {
        [P in keyof T & keyof AggregateSellPageBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellPageBanner[P]>
      : GetScalarType<T[P], AggregateSellPageBanner[P]>
  }




  export type SellPageBannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellPageBannerWhereInput
    orderBy?: SellPageBannerOrderByWithAggregationInput | SellPageBannerOrderByWithAggregationInput[]
    by: SellPageBannerScalarFieldEnum[] | SellPageBannerScalarFieldEnum
    having?: SellPageBannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellPageBannerCountAggregateInputType | true
    _min?: SellPageBannerMinAggregateInputType
    _max?: SellPageBannerMaxAggregateInputType
  }

  export type SellPageBannerGroupByOutputType = {
    id: string
    title: string
    description: string
    image: string
    imagePublicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SellPageBannerCountAggregateOutputType | null
    _min: SellPageBannerMinAggregateOutputType | null
    _max: SellPageBannerMaxAggregateOutputType | null
  }

  type GetSellPageBannerGroupByPayload<T extends SellPageBannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellPageBannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellPageBannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellPageBannerGroupByOutputType[P]>
            : GetScalarType<T[P], SellPageBannerGroupByOutputType[P]>
        }
      >
    >


  export type SellPageBannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sellPageBanner"]>



  export type SellPageBannerSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellPageBannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "image" | "imagePublicId" | "createdAt" | "updatedAt", ExtArgs["result"]["sellPageBanner"]>

  export type $SellPageBannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellPageBanner"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      image: string
      imagePublicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellPageBanner"]>
    composites: {}
  }

  type SellPageBannerGetPayload<S extends boolean | null | undefined | SellPageBannerDefaultArgs> = $Result.GetResult<Prisma.$SellPageBannerPayload, S>

  type SellPageBannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellPageBannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellPageBannerCountAggregateInputType | true
    }

  export interface SellPageBannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellPageBanner'], meta: { name: 'SellPageBanner' } }
    /**
     * Find zero or one SellPageBanner that matches the filter.
     * @param {SellPageBannerFindUniqueArgs} args - Arguments to find a SellPageBanner
     * @example
     * // Get one SellPageBanner
     * const sellPageBanner = await prisma.sellPageBanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellPageBannerFindUniqueArgs>(args: SelectSubset<T, SellPageBannerFindUniqueArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellPageBanner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellPageBannerFindUniqueOrThrowArgs} args - Arguments to find a SellPageBanner
     * @example
     * // Get one SellPageBanner
     * const sellPageBanner = await prisma.sellPageBanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellPageBannerFindUniqueOrThrowArgs>(args: SelectSubset<T, SellPageBannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellPageBanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerFindFirstArgs} args - Arguments to find a SellPageBanner
     * @example
     * // Get one SellPageBanner
     * const sellPageBanner = await prisma.sellPageBanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellPageBannerFindFirstArgs>(args?: SelectSubset<T, SellPageBannerFindFirstArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellPageBanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerFindFirstOrThrowArgs} args - Arguments to find a SellPageBanner
     * @example
     * // Get one SellPageBanner
     * const sellPageBanner = await prisma.sellPageBanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellPageBannerFindFirstOrThrowArgs>(args?: SelectSubset<T, SellPageBannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellPageBanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellPageBanners
     * const sellPageBanners = await prisma.sellPageBanner.findMany()
     * 
     * // Get first 10 SellPageBanners
     * const sellPageBanners = await prisma.sellPageBanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellPageBannerWithIdOnly = await prisma.sellPageBanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellPageBannerFindManyArgs>(args?: SelectSubset<T, SellPageBannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellPageBanner.
     * @param {SellPageBannerCreateArgs} args - Arguments to create a SellPageBanner.
     * @example
     * // Create one SellPageBanner
     * const SellPageBanner = await prisma.sellPageBanner.create({
     *   data: {
     *     // ... data to create a SellPageBanner
     *   }
     * })
     * 
     */
    create<T extends SellPageBannerCreateArgs>(args: SelectSubset<T, SellPageBannerCreateArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellPageBanners.
     * @param {SellPageBannerCreateManyArgs} args - Arguments to create many SellPageBanners.
     * @example
     * // Create many SellPageBanners
     * const sellPageBanner = await prisma.sellPageBanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellPageBannerCreateManyArgs>(args?: SelectSubset<T, SellPageBannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellPageBanner.
     * @param {SellPageBannerDeleteArgs} args - Arguments to delete one SellPageBanner.
     * @example
     * // Delete one SellPageBanner
     * const SellPageBanner = await prisma.sellPageBanner.delete({
     *   where: {
     *     // ... filter to delete one SellPageBanner
     *   }
     * })
     * 
     */
    delete<T extends SellPageBannerDeleteArgs>(args: SelectSubset<T, SellPageBannerDeleteArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellPageBanner.
     * @param {SellPageBannerUpdateArgs} args - Arguments to update one SellPageBanner.
     * @example
     * // Update one SellPageBanner
     * const sellPageBanner = await prisma.sellPageBanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellPageBannerUpdateArgs>(args: SelectSubset<T, SellPageBannerUpdateArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellPageBanners.
     * @param {SellPageBannerDeleteManyArgs} args - Arguments to filter SellPageBanners to delete.
     * @example
     * // Delete a few SellPageBanners
     * const { count } = await prisma.sellPageBanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellPageBannerDeleteManyArgs>(args?: SelectSubset<T, SellPageBannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellPageBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellPageBanners
     * const sellPageBanner = await prisma.sellPageBanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellPageBannerUpdateManyArgs>(args: SelectSubset<T, SellPageBannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellPageBanner.
     * @param {SellPageBannerUpsertArgs} args - Arguments to update or create a SellPageBanner.
     * @example
     * // Update or create a SellPageBanner
     * const sellPageBanner = await prisma.sellPageBanner.upsert({
     *   create: {
     *     // ... data to create a SellPageBanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellPageBanner we want to update
     *   }
     * })
     */
    upsert<T extends SellPageBannerUpsertArgs>(args: SelectSubset<T, SellPageBannerUpsertArgs<ExtArgs>>): Prisma__SellPageBannerClient<$Result.GetResult<Prisma.$SellPageBannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellPageBanners that matches the filter.
     * @param {SellPageBannerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sellPageBanner = await prisma.sellPageBanner.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SellPageBannerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SellPageBanner.
     * @param {SellPageBannerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sellPageBanner = await prisma.sellPageBanner.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SellPageBannerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SellPageBanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerCountArgs} args - Arguments to filter SellPageBanners to count.
     * @example
     * // Count the number of SellPageBanners
     * const count = await prisma.sellPageBanner.count({
     *   where: {
     *     // ... the filter for the SellPageBanners we want to count
     *   }
     * })
    **/
    count<T extends SellPageBannerCountArgs>(
      args?: Subset<T, SellPageBannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellPageBannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellPageBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellPageBannerAggregateArgs>(args: Subset<T, SellPageBannerAggregateArgs>): Prisma.PrismaPromise<GetSellPageBannerAggregateType<T>>

    /**
     * Group by SellPageBanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellPageBannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellPageBannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellPageBannerGroupByArgs['orderBy'] }
        : { orderBy?: SellPageBannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellPageBannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellPageBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellPageBanner model
   */
  readonly fields: SellPageBannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellPageBanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellPageBannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellPageBanner model
   */
  interface SellPageBannerFieldRefs {
    readonly id: FieldRef<"SellPageBanner", 'String'>
    readonly title: FieldRef<"SellPageBanner", 'String'>
    readonly description: FieldRef<"SellPageBanner", 'String'>
    readonly image: FieldRef<"SellPageBanner", 'String'>
    readonly imagePublicId: FieldRef<"SellPageBanner", 'String'>
    readonly createdAt: FieldRef<"SellPageBanner", 'DateTime'>
    readonly updatedAt: FieldRef<"SellPageBanner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellPageBanner findUnique
   */
  export type SellPageBannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * Filter, which SellPageBanner to fetch.
     */
    where: SellPageBannerWhereUniqueInput
  }

  /**
   * SellPageBanner findUniqueOrThrow
   */
  export type SellPageBannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * Filter, which SellPageBanner to fetch.
     */
    where: SellPageBannerWhereUniqueInput
  }

  /**
   * SellPageBanner findFirst
   */
  export type SellPageBannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * Filter, which SellPageBanner to fetch.
     */
    where?: SellPageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPageBanners to fetch.
     */
    orderBy?: SellPageBannerOrderByWithRelationInput | SellPageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellPageBanners.
     */
    cursor?: SellPageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPageBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellPageBanners.
     */
    distinct?: SellPageBannerScalarFieldEnum | SellPageBannerScalarFieldEnum[]
  }

  /**
   * SellPageBanner findFirstOrThrow
   */
  export type SellPageBannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * Filter, which SellPageBanner to fetch.
     */
    where?: SellPageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPageBanners to fetch.
     */
    orderBy?: SellPageBannerOrderByWithRelationInput | SellPageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellPageBanners.
     */
    cursor?: SellPageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPageBanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellPageBanners.
     */
    distinct?: SellPageBannerScalarFieldEnum | SellPageBannerScalarFieldEnum[]
  }

  /**
   * SellPageBanner findMany
   */
  export type SellPageBannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * Filter, which SellPageBanners to fetch.
     */
    where?: SellPageBannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellPageBanners to fetch.
     */
    orderBy?: SellPageBannerOrderByWithRelationInput | SellPageBannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellPageBanners.
     */
    cursor?: SellPageBannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellPageBanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellPageBanners.
     */
    skip?: number
    distinct?: SellPageBannerScalarFieldEnum | SellPageBannerScalarFieldEnum[]
  }

  /**
   * SellPageBanner create
   */
  export type SellPageBannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * The data needed to create a SellPageBanner.
     */
    data: XOR<SellPageBannerCreateInput, SellPageBannerUncheckedCreateInput>
  }

  /**
   * SellPageBanner createMany
   */
  export type SellPageBannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellPageBanners.
     */
    data: SellPageBannerCreateManyInput | SellPageBannerCreateManyInput[]
  }

  /**
   * SellPageBanner update
   */
  export type SellPageBannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * The data needed to update a SellPageBanner.
     */
    data: XOR<SellPageBannerUpdateInput, SellPageBannerUncheckedUpdateInput>
    /**
     * Choose, which SellPageBanner to update.
     */
    where: SellPageBannerWhereUniqueInput
  }

  /**
   * SellPageBanner updateMany
   */
  export type SellPageBannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellPageBanners.
     */
    data: XOR<SellPageBannerUpdateManyMutationInput, SellPageBannerUncheckedUpdateManyInput>
    /**
     * Filter which SellPageBanners to update
     */
    where?: SellPageBannerWhereInput
    /**
     * Limit how many SellPageBanners to update.
     */
    limit?: number
  }

  /**
   * SellPageBanner upsert
   */
  export type SellPageBannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * The filter to search for the SellPageBanner to update in case it exists.
     */
    where: SellPageBannerWhereUniqueInput
    /**
     * In case the SellPageBanner found by the `where` argument doesn't exist, create a new SellPageBanner with this data.
     */
    create: XOR<SellPageBannerCreateInput, SellPageBannerUncheckedCreateInput>
    /**
     * In case the SellPageBanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellPageBannerUpdateInput, SellPageBannerUncheckedUpdateInput>
  }

  /**
   * SellPageBanner delete
   */
  export type SellPageBannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
    /**
     * Filter which SellPageBanner to delete.
     */
    where: SellPageBannerWhereUniqueInput
  }

  /**
   * SellPageBanner deleteMany
   */
  export type SellPageBannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellPageBanners to delete
     */
    where?: SellPageBannerWhereInput
    /**
     * Limit how many SellPageBanners to delete.
     */
    limit?: number
  }

  /**
   * SellPageBanner findRaw
   */
  export type SellPageBannerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellPageBanner aggregateRaw
   */
  export type SellPageBannerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellPageBanner without action
   */
  export type SellPageBannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellPageBanner
     */
    select?: SellPageBannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellPageBanner
     */
    omit?: SellPageBannerOmit<ExtArgs> | null
  }


  /**
   * Model SellTypes
   */

  export type AggregateSellTypes = {
    _count: SellTypesCountAggregateOutputType | null
    _min: SellTypesMinAggregateOutputType | null
    _max: SellTypesMaxAggregateOutputType | null
  }

  export type SellTypesMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellTypesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellTypesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    items: number
    image: number
    imagePublicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellTypesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellTypesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellTypesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    items?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellTypes to aggregate.
     */
    where?: SellTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellTypes to fetch.
     */
    orderBy?: SellTypesOrderByWithRelationInput | SellTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellTypes
    **/
    _count?: true | SellTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellTypesMaxAggregateInputType
  }

  export type GetSellTypesAggregateType<T extends SellTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateSellTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellTypes[P]>
      : GetScalarType<T[P], AggregateSellTypes[P]>
  }




  export type SellTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellTypesWhereInput
    orderBy?: SellTypesOrderByWithAggregationInput | SellTypesOrderByWithAggregationInput[]
    by: SellTypesScalarFieldEnum[] | SellTypesScalarFieldEnum
    having?: SellTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellTypesCountAggregateInputType | true
    _min?: SellTypesMinAggregateInputType
    _max?: SellTypesMaxAggregateInputType
  }

  export type SellTypesGroupByOutputType = {
    id: string
    title: string
    description: string
    items: JsonValue | null
    image: string
    imagePublicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SellTypesCountAggregateOutputType | null
    _min: SellTypesMinAggregateOutputType | null
    _max: SellTypesMaxAggregateOutputType | null
  }

  type GetSellTypesGroupByPayload<T extends SellTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellTypesGroupByOutputType[P]>
            : GetScalarType<T[P], SellTypesGroupByOutputType[P]>
        }
      >
    >


  export type SellTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    items?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sellTypes"]>



  export type SellTypesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    items?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "items" | "image" | "imagePublicId" | "createdAt" | "updatedAt", ExtArgs["result"]["sellTypes"]>

  export type $SellTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellTypes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      items: Prisma.JsonValue | null
      image: string
      imagePublicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellTypes"]>
    composites: {}
  }

  type SellTypesGetPayload<S extends boolean | null | undefined | SellTypesDefaultArgs> = $Result.GetResult<Prisma.$SellTypesPayload, S>

  type SellTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellTypesCountAggregateInputType | true
    }

  export interface SellTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellTypes'], meta: { name: 'SellTypes' } }
    /**
     * Find zero or one SellTypes that matches the filter.
     * @param {SellTypesFindUniqueArgs} args - Arguments to find a SellTypes
     * @example
     * // Get one SellTypes
     * const sellTypes = await prisma.sellTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellTypesFindUniqueArgs>(args: SelectSubset<T, SellTypesFindUniqueArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellTypesFindUniqueOrThrowArgs} args - Arguments to find a SellTypes
     * @example
     * // Get one SellTypes
     * const sellTypes = await prisma.sellTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, SellTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesFindFirstArgs} args - Arguments to find a SellTypes
     * @example
     * // Get one SellTypes
     * const sellTypes = await prisma.sellTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellTypesFindFirstArgs>(args?: SelectSubset<T, SellTypesFindFirstArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesFindFirstOrThrowArgs} args - Arguments to find a SellTypes
     * @example
     * // Get one SellTypes
     * const sellTypes = await prisma.sellTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, SellTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellTypes
     * const sellTypes = await prisma.sellTypes.findMany()
     * 
     * // Get first 10 SellTypes
     * const sellTypes = await prisma.sellTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellTypesWithIdOnly = await prisma.sellTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellTypesFindManyArgs>(args?: SelectSubset<T, SellTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellTypes.
     * @param {SellTypesCreateArgs} args - Arguments to create a SellTypes.
     * @example
     * // Create one SellTypes
     * const SellTypes = await prisma.sellTypes.create({
     *   data: {
     *     // ... data to create a SellTypes
     *   }
     * })
     * 
     */
    create<T extends SellTypesCreateArgs>(args: SelectSubset<T, SellTypesCreateArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellTypes.
     * @param {SellTypesCreateManyArgs} args - Arguments to create many SellTypes.
     * @example
     * // Create many SellTypes
     * const sellTypes = await prisma.sellTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellTypesCreateManyArgs>(args?: SelectSubset<T, SellTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellTypes.
     * @param {SellTypesDeleteArgs} args - Arguments to delete one SellTypes.
     * @example
     * // Delete one SellTypes
     * const SellTypes = await prisma.sellTypes.delete({
     *   where: {
     *     // ... filter to delete one SellTypes
     *   }
     * })
     * 
     */
    delete<T extends SellTypesDeleteArgs>(args: SelectSubset<T, SellTypesDeleteArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellTypes.
     * @param {SellTypesUpdateArgs} args - Arguments to update one SellTypes.
     * @example
     * // Update one SellTypes
     * const sellTypes = await prisma.sellTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellTypesUpdateArgs>(args: SelectSubset<T, SellTypesUpdateArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellTypes.
     * @param {SellTypesDeleteManyArgs} args - Arguments to filter SellTypes to delete.
     * @example
     * // Delete a few SellTypes
     * const { count } = await prisma.sellTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellTypesDeleteManyArgs>(args?: SelectSubset<T, SellTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellTypes
     * const sellTypes = await prisma.sellTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellTypesUpdateManyArgs>(args: SelectSubset<T, SellTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellTypes.
     * @param {SellTypesUpsertArgs} args - Arguments to update or create a SellTypes.
     * @example
     * // Update or create a SellTypes
     * const sellTypes = await prisma.sellTypes.upsert({
     *   create: {
     *     // ... data to create a SellTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellTypes we want to update
     *   }
     * })
     */
    upsert<T extends SellTypesUpsertArgs>(args: SelectSubset<T, SellTypesUpsertArgs<ExtArgs>>): Prisma__SellTypesClient<$Result.GetResult<Prisma.$SellTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellTypes that matches the filter.
     * @param {SellTypesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sellTypes = await prisma.sellTypes.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SellTypesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SellTypes.
     * @param {SellTypesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sellTypes = await prisma.sellTypes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SellTypesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SellTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesCountArgs} args - Arguments to filter SellTypes to count.
     * @example
     * // Count the number of SellTypes
     * const count = await prisma.sellTypes.count({
     *   where: {
     *     // ... the filter for the SellTypes we want to count
     *   }
     * })
    **/
    count<T extends SellTypesCountArgs>(
      args?: Subset<T, SellTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellTypesAggregateArgs>(args: Subset<T, SellTypesAggregateArgs>): Prisma.PrismaPromise<GetSellTypesAggregateType<T>>

    /**
     * Group by SellTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellTypesGroupByArgs['orderBy'] }
        : { orderBy?: SellTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellTypes model
   */
  readonly fields: SellTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellTypes model
   */
  interface SellTypesFieldRefs {
    readonly id: FieldRef<"SellTypes", 'String'>
    readonly title: FieldRef<"SellTypes", 'String'>
    readonly description: FieldRef<"SellTypes", 'String'>
    readonly items: FieldRef<"SellTypes", 'Json'>
    readonly image: FieldRef<"SellTypes", 'String'>
    readonly imagePublicId: FieldRef<"SellTypes", 'String'>
    readonly createdAt: FieldRef<"SellTypes", 'DateTime'>
    readonly updatedAt: FieldRef<"SellTypes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellTypes findUnique
   */
  export type SellTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * Filter, which SellTypes to fetch.
     */
    where: SellTypesWhereUniqueInput
  }

  /**
   * SellTypes findUniqueOrThrow
   */
  export type SellTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * Filter, which SellTypes to fetch.
     */
    where: SellTypesWhereUniqueInput
  }

  /**
   * SellTypes findFirst
   */
  export type SellTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * Filter, which SellTypes to fetch.
     */
    where?: SellTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellTypes to fetch.
     */
    orderBy?: SellTypesOrderByWithRelationInput | SellTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellTypes.
     */
    cursor?: SellTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellTypes.
     */
    distinct?: SellTypesScalarFieldEnum | SellTypesScalarFieldEnum[]
  }

  /**
   * SellTypes findFirstOrThrow
   */
  export type SellTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * Filter, which SellTypes to fetch.
     */
    where?: SellTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellTypes to fetch.
     */
    orderBy?: SellTypesOrderByWithRelationInput | SellTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellTypes.
     */
    cursor?: SellTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellTypes.
     */
    distinct?: SellTypesScalarFieldEnum | SellTypesScalarFieldEnum[]
  }

  /**
   * SellTypes findMany
   */
  export type SellTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * Filter, which SellTypes to fetch.
     */
    where?: SellTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellTypes to fetch.
     */
    orderBy?: SellTypesOrderByWithRelationInput | SellTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellTypes.
     */
    cursor?: SellTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellTypes.
     */
    skip?: number
    distinct?: SellTypesScalarFieldEnum | SellTypesScalarFieldEnum[]
  }

  /**
   * SellTypes create
   */
  export type SellTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * The data needed to create a SellTypes.
     */
    data: XOR<SellTypesCreateInput, SellTypesUncheckedCreateInput>
  }

  /**
   * SellTypes createMany
   */
  export type SellTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellTypes.
     */
    data: SellTypesCreateManyInput | SellTypesCreateManyInput[]
  }

  /**
   * SellTypes update
   */
  export type SellTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * The data needed to update a SellTypes.
     */
    data: XOR<SellTypesUpdateInput, SellTypesUncheckedUpdateInput>
    /**
     * Choose, which SellTypes to update.
     */
    where: SellTypesWhereUniqueInput
  }

  /**
   * SellTypes updateMany
   */
  export type SellTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellTypes.
     */
    data: XOR<SellTypesUpdateManyMutationInput, SellTypesUncheckedUpdateManyInput>
    /**
     * Filter which SellTypes to update
     */
    where?: SellTypesWhereInput
    /**
     * Limit how many SellTypes to update.
     */
    limit?: number
  }

  /**
   * SellTypes upsert
   */
  export type SellTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * The filter to search for the SellTypes to update in case it exists.
     */
    where: SellTypesWhereUniqueInput
    /**
     * In case the SellTypes found by the `where` argument doesn't exist, create a new SellTypes with this data.
     */
    create: XOR<SellTypesCreateInput, SellTypesUncheckedCreateInput>
    /**
     * In case the SellTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellTypesUpdateInput, SellTypesUncheckedUpdateInput>
  }

  /**
   * SellTypes delete
   */
  export type SellTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
    /**
     * Filter which SellTypes to delete.
     */
    where: SellTypesWhereUniqueInput
  }

  /**
   * SellTypes deleteMany
   */
  export type SellTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellTypes to delete
     */
    where?: SellTypesWhereInput
    /**
     * Limit how many SellTypes to delete.
     */
    limit?: number
  }

  /**
   * SellTypes findRaw
   */
  export type SellTypesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellTypes aggregateRaw
   */
  export type SellTypesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellTypes without action
   */
  export type SellTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellTypes
     */
    select?: SellTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellTypes
     */
    omit?: SellTypesOmit<ExtArgs> | null
  }


  /**
   * Model SellerResources
   */

  export type AggregateSellerResources = {
    _count: SellerResourcesCountAggregateOutputType | null
    _min: SellerResourcesMinAggregateOutputType | null
    _max: SellerResourcesMaxAggregateOutputType | null
  }

  export type SellerResourcesMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellerResourcesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SellerResourcesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    imagePublicId: number
    items: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SellerResourcesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellerResourcesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SellerResourcesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    imagePublicId?: true
    items?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SellerResourcesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerResources to aggregate.
     */
    where?: SellerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerResources to fetch.
     */
    orderBy?: SellerResourcesOrderByWithRelationInput | SellerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SellerResources
    **/
    _count?: true | SellerResourcesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerResourcesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerResourcesMaxAggregateInputType
  }

  export type GetSellerResourcesAggregateType<T extends SellerResourcesAggregateArgs> = {
        [P in keyof T & keyof AggregateSellerResources]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSellerResources[P]>
      : GetScalarType<T[P], AggregateSellerResources[P]>
  }




  export type SellerResourcesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerResourcesWhereInput
    orderBy?: SellerResourcesOrderByWithAggregationInput | SellerResourcesOrderByWithAggregationInput[]
    by: SellerResourcesScalarFieldEnum[] | SellerResourcesScalarFieldEnum
    having?: SellerResourcesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerResourcesCountAggregateInputType | true
    _min?: SellerResourcesMinAggregateInputType
    _max?: SellerResourcesMaxAggregateInputType
  }

  export type SellerResourcesGroupByOutputType = {
    id: string
    title: string
    description: string | null
    image: string | null
    imagePublicId: string | null
    items: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SellerResourcesCountAggregateOutputType | null
    _min: SellerResourcesMinAggregateOutputType | null
    _max: SellerResourcesMaxAggregateOutputType | null
  }

  type GetSellerResourcesGroupByPayload<T extends SellerResourcesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerResourcesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerResourcesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerResourcesGroupByOutputType[P]>
            : GetScalarType<T[P], SellerResourcesGroupByOutputType[P]>
        }
      >
    >


  export type SellerResourcesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    imagePublicId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["sellerResources"]>



  export type SellerResourcesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    imagePublicId?: boolean
    items?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SellerResourcesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "image" | "imagePublicId" | "items" | "createdAt" | "updatedAt", ExtArgs["result"]["sellerResources"]>

  export type $SellerResourcesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SellerResources"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      image: string | null
      imagePublicId: string | null
      items: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sellerResources"]>
    composites: {}
  }

  type SellerResourcesGetPayload<S extends boolean | null | undefined | SellerResourcesDefaultArgs> = $Result.GetResult<Prisma.$SellerResourcesPayload, S>

  type SellerResourcesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerResourcesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerResourcesCountAggregateInputType | true
    }

  export interface SellerResourcesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SellerResources'], meta: { name: 'SellerResources' } }
    /**
     * Find zero or one SellerResources that matches the filter.
     * @param {SellerResourcesFindUniqueArgs} args - Arguments to find a SellerResources
     * @example
     * // Get one SellerResources
     * const sellerResources = await prisma.sellerResources.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerResourcesFindUniqueArgs>(args: SelectSubset<T, SellerResourcesFindUniqueArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SellerResources that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerResourcesFindUniqueOrThrowArgs} args - Arguments to find a SellerResources
     * @example
     * // Get one SellerResources
     * const sellerResources = await prisma.sellerResources.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerResourcesFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerResourcesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesFindFirstArgs} args - Arguments to find a SellerResources
     * @example
     * // Get one SellerResources
     * const sellerResources = await prisma.sellerResources.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerResourcesFindFirstArgs>(args?: SelectSubset<T, SellerResourcesFindFirstArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SellerResources that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesFindFirstOrThrowArgs} args - Arguments to find a SellerResources
     * @example
     * // Get one SellerResources
     * const sellerResources = await prisma.sellerResources.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerResourcesFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerResourcesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SellerResources
     * const sellerResources = await prisma.sellerResources.findMany()
     * 
     * // Get first 10 SellerResources
     * const sellerResources = await prisma.sellerResources.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerResourcesWithIdOnly = await prisma.sellerResources.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerResourcesFindManyArgs>(args?: SelectSubset<T, SellerResourcesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SellerResources.
     * @param {SellerResourcesCreateArgs} args - Arguments to create a SellerResources.
     * @example
     * // Create one SellerResources
     * const SellerResources = await prisma.sellerResources.create({
     *   data: {
     *     // ... data to create a SellerResources
     *   }
     * })
     * 
     */
    create<T extends SellerResourcesCreateArgs>(args: SelectSubset<T, SellerResourcesCreateArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SellerResources.
     * @param {SellerResourcesCreateManyArgs} args - Arguments to create many SellerResources.
     * @example
     * // Create many SellerResources
     * const sellerResources = await prisma.sellerResources.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerResourcesCreateManyArgs>(args?: SelectSubset<T, SellerResourcesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SellerResources.
     * @param {SellerResourcesDeleteArgs} args - Arguments to delete one SellerResources.
     * @example
     * // Delete one SellerResources
     * const SellerResources = await prisma.sellerResources.delete({
     *   where: {
     *     // ... filter to delete one SellerResources
     *   }
     * })
     * 
     */
    delete<T extends SellerResourcesDeleteArgs>(args: SelectSubset<T, SellerResourcesDeleteArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SellerResources.
     * @param {SellerResourcesUpdateArgs} args - Arguments to update one SellerResources.
     * @example
     * // Update one SellerResources
     * const sellerResources = await prisma.sellerResources.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerResourcesUpdateArgs>(args: SelectSubset<T, SellerResourcesUpdateArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SellerResources.
     * @param {SellerResourcesDeleteManyArgs} args - Arguments to filter SellerResources to delete.
     * @example
     * // Delete a few SellerResources
     * const { count } = await prisma.sellerResources.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerResourcesDeleteManyArgs>(args?: SelectSubset<T, SellerResourcesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SellerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SellerResources
     * const sellerResources = await prisma.sellerResources.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerResourcesUpdateManyArgs>(args: SelectSubset<T, SellerResourcesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SellerResources.
     * @param {SellerResourcesUpsertArgs} args - Arguments to update or create a SellerResources.
     * @example
     * // Update or create a SellerResources
     * const sellerResources = await prisma.sellerResources.upsert({
     *   create: {
     *     // ... data to create a SellerResources
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SellerResources we want to update
     *   }
     * })
     */
    upsert<T extends SellerResourcesUpsertArgs>(args: SelectSubset<T, SellerResourcesUpsertArgs<ExtArgs>>): Prisma__SellerResourcesClient<$Result.GetResult<Prisma.$SellerResourcesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SellerResources that matches the filter.
     * @param {SellerResourcesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sellerResources = await prisma.sellerResources.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SellerResourcesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SellerResources.
     * @param {SellerResourcesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sellerResources = await prisma.sellerResources.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SellerResourcesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SellerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesCountArgs} args - Arguments to filter SellerResources to count.
     * @example
     * // Count the number of SellerResources
     * const count = await prisma.sellerResources.count({
     *   where: {
     *     // ... the filter for the SellerResources we want to count
     *   }
     * })
    **/
    count<T extends SellerResourcesCountArgs>(
      args?: Subset<T, SellerResourcesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerResourcesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SellerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerResourcesAggregateArgs>(args: Subset<T, SellerResourcesAggregateArgs>): Prisma.PrismaPromise<GetSellerResourcesAggregateType<T>>

    /**
     * Group by SellerResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerResourcesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerResourcesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerResourcesGroupByArgs['orderBy'] }
        : { orderBy?: SellerResourcesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerResourcesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerResourcesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SellerResources model
   */
  readonly fields: SellerResourcesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SellerResources.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerResourcesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SellerResources model
   */
  interface SellerResourcesFieldRefs {
    readonly id: FieldRef<"SellerResources", 'String'>
    readonly title: FieldRef<"SellerResources", 'String'>
    readonly description: FieldRef<"SellerResources", 'String'>
    readonly image: FieldRef<"SellerResources", 'String'>
    readonly imagePublicId: FieldRef<"SellerResources", 'String'>
    readonly items: FieldRef<"SellerResources", 'Json'>
    readonly createdAt: FieldRef<"SellerResources", 'DateTime'>
    readonly updatedAt: FieldRef<"SellerResources", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SellerResources findUnique
   */
  export type SellerResourcesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * Filter, which SellerResources to fetch.
     */
    where: SellerResourcesWhereUniqueInput
  }

  /**
   * SellerResources findUniqueOrThrow
   */
  export type SellerResourcesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * Filter, which SellerResources to fetch.
     */
    where: SellerResourcesWhereUniqueInput
  }

  /**
   * SellerResources findFirst
   */
  export type SellerResourcesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * Filter, which SellerResources to fetch.
     */
    where?: SellerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerResources to fetch.
     */
    orderBy?: SellerResourcesOrderByWithRelationInput | SellerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerResources.
     */
    cursor?: SellerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerResources.
     */
    distinct?: SellerResourcesScalarFieldEnum | SellerResourcesScalarFieldEnum[]
  }

  /**
   * SellerResources findFirstOrThrow
   */
  export type SellerResourcesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * Filter, which SellerResources to fetch.
     */
    where?: SellerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerResources to fetch.
     */
    orderBy?: SellerResourcesOrderByWithRelationInput | SellerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SellerResources.
     */
    cursor?: SellerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SellerResources.
     */
    distinct?: SellerResourcesScalarFieldEnum | SellerResourcesScalarFieldEnum[]
  }

  /**
   * SellerResources findMany
   */
  export type SellerResourcesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * Filter, which SellerResources to fetch.
     */
    where?: SellerResourcesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SellerResources to fetch.
     */
    orderBy?: SellerResourcesOrderByWithRelationInput | SellerResourcesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SellerResources.
     */
    cursor?: SellerResourcesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SellerResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SellerResources.
     */
    skip?: number
    distinct?: SellerResourcesScalarFieldEnum | SellerResourcesScalarFieldEnum[]
  }

  /**
   * SellerResources create
   */
  export type SellerResourcesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * The data needed to create a SellerResources.
     */
    data: XOR<SellerResourcesCreateInput, SellerResourcesUncheckedCreateInput>
  }

  /**
   * SellerResources createMany
   */
  export type SellerResourcesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SellerResources.
     */
    data: SellerResourcesCreateManyInput | SellerResourcesCreateManyInput[]
  }

  /**
   * SellerResources update
   */
  export type SellerResourcesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * The data needed to update a SellerResources.
     */
    data: XOR<SellerResourcesUpdateInput, SellerResourcesUncheckedUpdateInput>
    /**
     * Choose, which SellerResources to update.
     */
    where: SellerResourcesWhereUniqueInput
  }

  /**
   * SellerResources updateMany
   */
  export type SellerResourcesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SellerResources.
     */
    data: XOR<SellerResourcesUpdateManyMutationInput, SellerResourcesUncheckedUpdateManyInput>
    /**
     * Filter which SellerResources to update
     */
    where?: SellerResourcesWhereInput
    /**
     * Limit how many SellerResources to update.
     */
    limit?: number
  }

  /**
   * SellerResources upsert
   */
  export type SellerResourcesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * The filter to search for the SellerResources to update in case it exists.
     */
    where: SellerResourcesWhereUniqueInput
    /**
     * In case the SellerResources found by the `where` argument doesn't exist, create a new SellerResources with this data.
     */
    create: XOR<SellerResourcesCreateInput, SellerResourcesUncheckedCreateInput>
    /**
     * In case the SellerResources was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerResourcesUpdateInput, SellerResourcesUncheckedUpdateInput>
  }

  /**
   * SellerResources delete
   */
  export type SellerResourcesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
    /**
     * Filter which SellerResources to delete.
     */
    where: SellerResourcesWhereUniqueInput
  }

  /**
   * SellerResources deleteMany
   */
  export type SellerResourcesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SellerResources to delete
     */
    where?: SellerResourcesWhereInput
    /**
     * Limit how many SellerResources to delete.
     */
    limit?: number
  }

  /**
   * SellerResources findRaw
   */
  export type SellerResourcesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellerResources aggregateRaw
   */
  export type SellerResourcesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SellerResources without action
   */
  export type SellerResourcesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerResources
     */
    select?: SellerResourcesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SellerResources
     */
    omit?: SellerResourcesOmit<ExtArgs> | null
  }


  /**
   * Model DevelopmentPlatform
   */

  export type AggregateDevelopmentPlatform = {
    _count: DevelopmentPlatformCountAggregateOutputType | null
    _min: DevelopmentPlatformMinAggregateOutputType | null
    _max: DevelopmentPlatformMaxAggregateOutputType | null
  }

  export type DevelopmentPlatformMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    iosLink: string | null
    androidLink: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DevelopmentPlatformMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    iosLink: string | null
    androidLink: string | null
    image: string | null
    imagePublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DevelopmentPlatformCountAggregateOutputType = {
    id: number
    title: number
    description: number
    iosLink: number
    androidLink: number
    image: number
    imagePublicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DevelopmentPlatformMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    iosLink?: true
    androidLink?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DevelopmentPlatformMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    iosLink?: true
    androidLink?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DevelopmentPlatformCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    iosLink?: true
    androidLink?: true
    image?: true
    imagePublicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DevelopmentPlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevelopmentPlatform to aggregate.
     */
    where?: DevelopmentPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPlatforms to fetch.
     */
    orderBy?: DevelopmentPlatformOrderByWithRelationInput | DevelopmentPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DevelopmentPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DevelopmentPlatforms
    **/
    _count?: true | DevelopmentPlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DevelopmentPlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DevelopmentPlatformMaxAggregateInputType
  }

  export type GetDevelopmentPlatformAggregateType<T extends DevelopmentPlatformAggregateArgs> = {
        [P in keyof T & keyof AggregateDevelopmentPlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevelopmentPlatform[P]>
      : GetScalarType<T[P], AggregateDevelopmentPlatform[P]>
  }




  export type DevelopmentPlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DevelopmentPlatformWhereInput
    orderBy?: DevelopmentPlatformOrderByWithAggregationInput | DevelopmentPlatformOrderByWithAggregationInput[]
    by: DevelopmentPlatformScalarFieldEnum[] | DevelopmentPlatformScalarFieldEnum
    having?: DevelopmentPlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DevelopmentPlatformCountAggregateInputType | true
    _min?: DevelopmentPlatformMinAggregateInputType
    _max?: DevelopmentPlatformMaxAggregateInputType
  }

  export type DevelopmentPlatformGroupByOutputType = {
    id: string
    title: string
    description: string
    iosLink: string
    androidLink: string
    image: string
    imagePublicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DevelopmentPlatformCountAggregateOutputType | null
    _min: DevelopmentPlatformMinAggregateOutputType | null
    _max: DevelopmentPlatformMaxAggregateOutputType | null
  }

  type GetDevelopmentPlatformGroupByPayload<T extends DevelopmentPlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DevelopmentPlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DevelopmentPlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DevelopmentPlatformGroupByOutputType[P]>
            : GetScalarType<T[P], DevelopmentPlatformGroupByOutputType[P]>
        }
      >
    >


  export type DevelopmentPlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    iosLink?: boolean
    androidLink?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["developmentPlatform"]>



  export type DevelopmentPlatformSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    iosLink?: boolean
    androidLink?: boolean
    image?: boolean
    imagePublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DevelopmentPlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "iosLink" | "androidLink" | "image" | "imagePublicId" | "createdAt" | "updatedAt", ExtArgs["result"]["developmentPlatform"]>

  export type $DevelopmentPlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DevelopmentPlatform"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      iosLink: string
      androidLink: string
      image: string
      imagePublicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["developmentPlatform"]>
    composites: {}
  }

  type DevelopmentPlatformGetPayload<S extends boolean | null | undefined | DevelopmentPlatformDefaultArgs> = $Result.GetResult<Prisma.$DevelopmentPlatformPayload, S>

  type DevelopmentPlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DevelopmentPlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DevelopmentPlatformCountAggregateInputType | true
    }

  export interface DevelopmentPlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DevelopmentPlatform'], meta: { name: 'DevelopmentPlatform' } }
    /**
     * Find zero or one DevelopmentPlatform that matches the filter.
     * @param {DevelopmentPlatformFindUniqueArgs} args - Arguments to find a DevelopmentPlatform
     * @example
     * // Get one DevelopmentPlatform
     * const developmentPlatform = await prisma.developmentPlatform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DevelopmentPlatformFindUniqueArgs>(args: SelectSubset<T, DevelopmentPlatformFindUniqueArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DevelopmentPlatform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DevelopmentPlatformFindUniqueOrThrowArgs} args - Arguments to find a DevelopmentPlatform
     * @example
     * // Get one DevelopmentPlatform
     * const developmentPlatform = await prisma.developmentPlatform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DevelopmentPlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, DevelopmentPlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevelopmentPlatform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformFindFirstArgs} args - Arguments to find a DevelopmentPlatform
     * @example
     * // Get one DevelopmentPlatform
     * const developmentPlatform = await prisma.developmentPlatform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DevelopmentPlatformFindFirstArgs>(args?: SelectSubset<T, DevelopmentPlatformFindFirstArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DevelopmentPlatform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformFindFirstOrThrowArgs} args - Arguments to find a DevelopmentPlatform
     * @example
     * // Get one DevelopmentPlatform
     * const developmentPlatform = await prisma.developmentPlatform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DevelopmentPlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, DevelopmentPlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DevelopmentPlatforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DevelopmentPlatforms
     * const developmentPlatforms = await prisma.developmentPlatform.findMany()
     * 
     * // Get first 10 DevelopmentPlatforms
     * const developmentPlatforms = await prisma.developmentPlatform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const developmentPlatformWithIdOnly = await prisma.developmentPlatform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DevelopmentPlatformFindManyArgs>(args?: SelectSubset<T, DevelopmentPlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DevelopmentPlatform.
     * @param {DevelopmentPlatformCreateArgs} args - Arguments to create a DevelopmentPlatform.
     * @example
     * // Create one DevelopmentPlatform
     * const DevelopmentPlatform = await prisma.developmentPlatform.create({
     *   data: {
     *     // ... data to create a DevelopmentPlatform
     *   }
     * })
     * 
     */
    create<T extends DevelopmentPlatformCreateArgs>(args: SelectSubset<T, DevelopmentPlatformCreateArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DevelopmentPlatforms.
     * @param {DevelopmentPlatformCreateManyArgs} args - Arguments to create many DevelopmentPlatforms.
     * @example
     * // Create many DevelopmentPlatforms
     * const developmentPlatform = await prisma.developmentPlatform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DevelopmentPlatformCreateManyArgs>(args?: SelectSubset<T, DevelopmentPlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DevelopmentPlatform.
     * @param {DevelopmentPlatformDeleteArgs} args - Arguments to delete one DevelopmentPlatform.
     * @example
     * // Delete one DevelopmentPlatform
     * const DevelopmentPlatform = await prisma.developmentPlatform.delete({
     *   where: {
     *     // ... filter to delete one DevelopmentPlatform
     *   }
     * })
     * 
     */
    delete<T extends DevelopmentPlatformDeleteArgs>(args: SelectSubset<T, DevelopmentPlatformDeleteArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DevelopmentPlatform.
     * @param {DevelopmentPlatformUpdateArgs} args - Arguments to update one DevelopmentPlatform.
     * @example
     * // Update one DevelopmentPlatform
     * const developmentPlatform = await prisma.developmentPlatform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DevelopmentPlatformUpdateArgs>(args: SelectSubset<T, DevelopmentPlatformUpdateArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DevelopmentPlatforms.
     * @param {DevelopmentPlatformDeleteManyArgs} args - Arguments to filter DevelopmentPlatforms to delete.
     * @example
     * // Delete a few DevelopmentPlatforms
     * const { count } = await prisma.developmentPlatform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DevelopmentPlatformDeleteManyArgs>(args?: SelectSubset<T, DevelopmentPlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DevelopmentPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DevelopmentPlatforms
     * const developmentPlatform = await prisma.developmentPlatform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DevelopmentPlatformUpdateManyArgs>(args: SelectSubset<T, DevelopmentPlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DevelopmentPlatform.
     * @param {DevelopmentPlatformUpsertArgs} args - Arguments to update or create a DevelopmentPlatform.
     * @example
     * // Update or create a DevelopmentPlatform
     * const developmentPlatform = await prisma.developmentPlatform.upsert({
     *   create: {
     *     // ... data to create a DevelopmentPlatform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DevelopmentPlatform we want to update
     *   }
     * })
     */
    upsert<T extends DevelopmentPlatformUpsertArgs>(args: SelectSubset<T, DevelopmentPlatformUpsertArgs<ExtArgs>>): Prisma__DevelopmentPlatformClient<$Result.GetResult<Prisma.$DevelopmentPlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DevelopmentPlatforms that matches the filter.
     * @param {DevelopmentPlatformFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const developmentPlatform = await prisma.developmentPlatform.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: DevelopmentPlatformFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DevelopmentPlatform.
     * @param {DevelopmentPlatformAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const developmentPlatform = await prisma.developmentPlatform.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DevelopmentPlatformAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DevelopmentPlatforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformCountArgs} args - Arguments to filter DevelopmentPlatforms to count.
     * @example
     * // Count the number of DevelopmentPlatforms
     * const count = await prisma.developmentPlatform.count({
     *   where: {
     *     // ... the filter for the DevelopmentPlatforms we want to count
     *   }
     * })
    **/
    count<T extends DevelopmentPlatformCountArgs>(
      args?: Subset<T, DevelopmentPlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DevelopmentPlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DevelopmentPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DevelopmentPlatformAggregateArgs>(args: Subset<T, DevelopmentPlatformAggregateArgs>): Prisma.PrismaPromise<GetDevelopmentPlatformAggregateType<T>>

    /**
     * Group by DevelopmentPlatform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DevelopmentPlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DevelopmentPlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DevelopmentPlatformGroupByArgs['orderBy'] }
        : { orderBy?: DevelopmentPlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DevelopmentPlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDevelopmentPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DevelopmentPlatform model
   */
  readonly fields: DevelopmentPlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DevelopmentPlatform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DevelopmentPlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DevelopmentPlatform model
   */
  interface DevelopmentPlatformFieldRefs {
    readonly id: FieldRef<"DevelopmentPlatform", 'String'>
    readonly title: FieldRef<"DevelopmentPlatform", 'String'>
    readonly description: FieldRef<"DevelopmentPlatform", 'String'>
    readonly iosLink: FieldRef<"DevelopmentPlatform", 'String'>
    readonly androidLink: FieldRef<"DevelopmentPlatform", 'String'>
    readonly image: FieldRef<"DevelopmentPlatform", 'String'>
    readonly imagePublicId: FieldRef<"DevelopmentPlatform", 'String'>
    readonly createdAt: FieldRef<"DevelopmentPlatform", 'DateTime'>
    readonly updatedAt: FieldRef<"DevelopmentPlatform", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DevelopmentPlatform findUnique
   */
  export type DevelopmentPlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * Filter, which DevelopmentPlatform to fetch.
     */
    where: DevelopmentPlatformWhereUniqueInput
  }

  /**
   * DevelopmentPlatform findUniqueOrThrow
   */
  export type DevelopmentPlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * Filter, which DevelopmentPlatform to fetch.
     */
    where: DevelopmentPlatformWhereUniqueInput
  }

  /**
   * DevelopmentPlatform findFirst
   */
  export type DevelopmentPlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * Filter, which DevelopmentPlatform to fetch.
     */
    where?: DevelopmentPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPlatforms to fetch.
     */
    orderBy?: DevelopmentPlatformOrderByWithRelationInput | DevelopmentPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevelopmentPlatforms.
     */
    cursor?: DevelopmentPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevelopmentPlatforms.
     */
    distinct?: DevelopmentPlatformScalarFieldEnum | DevelopmentPlatformScalarFieldEnum[]
  }

  /**
   * DevelopmentPlatform findFirstOrThrow
   */
  export type DevelopmentPlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * Filter, which DevelopmentPlatform to fetch.
     */
    where?: DevelopmentPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPlatforms to fetch.
     */
    orderBy?: DevelopmentPlatformOrderByWithRelationInput | DevelopmentPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DevelopmentPlatforms.
     */
    cursor?: DevelopmentPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPlatforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DevelopmentPlatforms.
     */
    distinct?: DevelopmentPlatformScalarFieldEnum | DevelopmentPlatformScalarFieldEnum[]
  }

  /**
   * DevelopmentPlatform findMany
   */
  export type DevelopmentPlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * Filter, which DevelopmentPlatforms to fetch.
     */
    where?: DevelopmentPlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DevelopmentPlatforms to fetch.
     */
    orderBy?: DevelopmentPlatformOrderByWithRelationInput | DevelopmentPlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DevelopmentPlatforms.
     */
    cursor?: DevelopmentPlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DevelopmentPlatforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DevelopmentPlatforms.
     */
    skip?: number
    distinct?: DevelopmentPlatformScalarFieldEnum | DevelopmentPlatformScalarFieldEnum[]
  }

  /**
   * DevelopmentPlatform create
   */
  export type DevelopmentPlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * The data needed to create a DevelopmentPlatform.
     */
    data: XOR<DevelopmentPlatformCreateInput, DevelopmentPlatformUncheckedCreateInput>
  }

  /**
   * DevelopmentPlatform createMany
   */
  export type DevelopmentPlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DevelopmentPlatforms.
     */
    data: DevelopmentPlatformCreateManyInput | DevelopmentPlatformCreateManyInput[]
  }

  /**
   * DevelopmentPlatform update
   */
  export type DevelopmentPlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * The data needed to update a DevelopmentPlatform.
     */
    data: XOR<DevelopmentPlatformUpdateInput, DevelopmentPlatformUncheckedUpdateInput>
    /**
     * Choose, which DevelopmentPlatform to update.
     */
    where: DevelopmentPlatformWhereUniqueInput
  }

  /**
   * DevelopmentPlatform updateMany
   */
  export type DevelopmentPlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DevelopmentPlatforms.
     */
    data: XOR<DevelopmentPlatformUpdateManyMutationInput, DevelopmentPlatformUncheckedUpdateManyInput>
    /**
     * Filter which DevelopmentPlatforms to update
     */
    where?: DevelopmentPlatformWhereInput
    /**
     * Limit how many DevelopmentPlatforms to update.
     */
    limit?: number
  }

  /**
   * DevelopmentPlatform upsert
   */
  export type DevelopmentPlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * The filter to search for the DevelopmentPlatform to update in case it exists.
     */
    where: DevelopmentPlatformWhereUniqueInput
    /**
     * In case the DevelopmentPlatform found by the `where` argument doesn't exist, create a new DevelopmentPlatform with this data.
     */
    create: XOR<DevelopmentPlatformCreateInput, DevelopmentPlatformUncheckedCreateInput>
    /**
     * In case the DevelopmentPlatform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DevelopmentPlatformUpdateInput, DevelopmentPlatformUncheckedUpdateInput>
  }

  /**
   * DevelopmentPlatform delete
   */
  export type DevelopmentPlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
    /**
     * Filter which DevelopmentPlatform to delete.
     */
    where: DevelopmentPlatformWhereUniqueInput
  }

  /**
   * DevelopmentPlatform deleteMany
   */
  export type DevelopmentPlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DevelopmentPlatforms to delete
     */
    where?: DevelopmentPlatformWhereInput
    /**
     * Limit how many DevelopmentPlatforms to delete.
     */
    limit?: number
  }

  /**
   * DevelopmentPlatform findRaw
   */
  export type DevelopmentPlatformFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DevelopmentPlatform aggregateRaw
   */
  export type DevelopmentPlatformAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DevelopmentPlatform without action
   */
  export type DevelopmentPlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DevelopmentPlatform
     */
    select?: DevelopmentPlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DevelopmentPlatform
     */
    omit?: DevelopmentPlatformOmit<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    price: number | null
    views: number | null
    bedrooms: number | null
    bathrooms: number | null
    size: number | null
    lotSize: number | null
    yearBuilt: number | null
    hoaFees: number | null
    deposit: number | null
  }

  export type PropertySumAggregateOutputType = {
    price: number | null
    views: number | null
    bedrooms: number | null
    bathrooms: number | null
    size: number | null
    lotSize: number | null
    yearBuilt: number | null
    hoaFees: number | null
    deposit: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    price: number | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    latitude: string | null
    longitude: string | null
    neighborhood: string | null
    views: number | null
    type: $Enums.PropertyType | null
    property: $Enums.PropertyCategory | null
    bedrooms: number | null
    bathrooms: number | null
    size: number | null
    lotSize: number | null
    yearBuilt: number | null
    hoaFees: number | null
    leaseLength: string | null
    furnished: boolean | null
    deposit: number | null
    moveInDate: Date | null
    garage: boolean | null
    basement: boolean | null
    fireplace: boolean | null
    pool: boolean | null
    pet: string | null
    utilities: string | null
    income: string | null
    school: string | null
    bus: string | null
    restaurant: string | null
    description: string | null
    listingStatus: $Enums.ListingStatus | null
    listingType: string | null
    userId: string | null
    userName: string | null
    userAvatar: string | null
    userEmail: string | null
    status: $Enums.PropertyStatus | null
    flagged: boolean | null
    flagReason: string | null
    flagStatus: string | null
    flaggedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    price: number | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    latitude: string | null
    longitude: string | null
    neighborhood: string | null
    views: number | null
    type: $Enums.PropertyType | null
    property: $Enums.PropertyCategory | null
    bedrooms: number | null
    bathrooms: number | null
    size: number | null
    lotSize: number | null
    yearBuilt: number | null
    hoaFees: number | null
    leaseLength: string | null
    furnished: boolean | null
    deposit: number | null
    moveInDate: Date | null
    garage: boolean | null
    basement: boolean | null
    fireplace: boolean | null
    pool: boolean | null
    pet: string | null
    utilities: string | null
    income: string | null
    school: string | null
    bus: string | null
    restaurant: string | null
    description: string | null
    listingStatus: $Enums.ListingStatus | null
    listingType: string | null
    userId: string | null
    userName: string | null
    userAvatar: string | null
    userEmail: string | null
    status: $Enums.PropertyStatus | null
    flagged: boolean | null
    flagReason: string | null
    flagStatus: string | null
    flaggedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    price: number
    address: number
    city: number
    state: number
    zip: number
    latitude: number
    longitude: number
    neighborhood: number
    views: number
    type: number
    property: number
    bedrooms: number
    bathrooms: number
    size: number
    lotSize: number
    yearBuilt: number
    hoaFees: number
    leaseLength: number
    furnished: number
    deposit: number
    moveInDate: number
    amenities: number
    garage: number
    basement: number
    fireplace: number
    pool: number
    pet: number
    utilities: number
    income: number
    school: number
    bus: number
    restaurant: number
    images: number
    description: number
    listingStatus: number
    listingType: number
    userId: number
    userName: number
    userAvatar: number
    userEmail: number
    status: number
    flagged: number
    reportedBy: number
    flagReason: number
    flagStatus: number
    flaggedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    price?: true
    views?: true
    bedrooms?: true
    bathrooms?: true
    size?: true
    lotSize?: true
    yearBuilt?: true
    hoaFees?: true
    deposit?: true
  }

  export type PropertySumAggregateInputType = {
    price?: true
    views?: true
    bedrooms?: true
    bathrooms?: true
    size?: true
    lotSize?: true
    yearBuilt?: true
    hoaFees?: true
    deposit?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    price?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    latitude?: true
    longitude?: true
    neighborhood?: true
    views?: true
    type?: true
    property?: true
    bedrooms?: true
    bathrooms?: true
    size?: true
    lotSize?: true
    yearBuilt?: true
    hoaFees?: true
    leaseLength?: true
    furnished?: true
    deposit?: true
    moveInDate?: true
    garage?: true
    basement?: true
    fireplace?: true
    pool?: true
    pet?: true
    utilities?: true
    income?: true
    school?: true
    bus?: true
    restaurant?: true
    description?: true
    listingStatus?: true
    listingType?: true
    userId?: true
    userName?: true
    userAvatar?: true
    userEmail?: true
    status?: true
    flagged?: true
    flagReason?: true
    flagStatus?: true
    flaggedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    price?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    latitude?: true
    longitude?: true
    neighborhood?: true
    views?: true
    type?: true
    property?: true
    bedrooms?: true
    bathrooms?: true
    size?: true
    lotSize?: true
    yearBuilt?: true
    hoaFees?: true
    leaseLength?: true
    furnished?: true
    deposit?: true
    moveInDate?: true
    garage?: true
    basement?: true
    fireplace?: true
    pool?: true
    pet?: true
    utilities?: true
    income?: true
    school?: true
    bus?: true
    restaurant?: true
    description?: true
    listingStatus?: true
    listingType?: true
    userId?: true
    userName?: true
    userAvatar?: true
    userEmail?: true
    status?: true
    flagged?: true
    flagReason?: true
    flagStatus?: true
    flaggedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    price?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    latitude?: true
    longitude?: true
    neighborhood?: true
    views?: true
    type?: true
    property?: true
    bedrooms?: true
    bathrooms?: true
    size?: true
    lotSize?: true
    yearBuilt?: true
    hoaFees?: true
    leaseLength?: true
    furnished?: true
    deposit?: true
    moveInDate?: true
    amenities?: true
    garage?: true
    basement?: true
    fireplace?: true
    pool?: true
    pet?: true
    utilities?: true
    income?: true
    school?: true
    bus?: true
    restaurant?: true
    images?: true
    description?: true
    listingStatus?: true
    listingType?: true
    userId?: true
    userName?: true
    userAvatar?: true
    userEmail?: true
    status?: true
    flagged?: true
    reportedBy?: true
    flagReason?: true
    flagStatus?: true
    flaggedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    title: string
    slug: string
    price: number
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    latitude: string | null
    longitude: string | null
    neighborhood: string | null
    views: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms: number | null
    bathrooms: number | null
    size: number | null
    lotSize: number | null
    yearBuilt: number | null
    hoaFees: number | null
    leaseLength: string | null
    furnished: boolean | null
    deposit: number | null
    moveInDate: Date | null
    amenities: string[]
    garage: boolean | null
    basement: boolean | null
    fireplace: boolean | null
    pool: boolean | null
    pet: string | null
    utilities: string | null
    income: string | null
    school: string | null
    bus: string | null
    restaurant: string | null
    images: JsonValue | null
    description: string
    listingStatus: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName: string | null
    userAvatar: string | null
    userEmail: string | null
    status: $Enums.PropertyStatus
    flagged: boolean
    reportedBy: string[]
    flagReason: string | null
    flagStatus: string | null
    flaggedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    price?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    latitude?: boolean
    longitude?: boolean
    neighborhood?: boolean
    views?: boolean
    type?: boolean
    property?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    size?: boolean
    lotSize?: boolean
    yearBuilt?: boolean
    hoaFees?: boolean
    leaseLength?: boolean
    furnished?: boolean
    deposit?: boolean
    moveInDate?: boolean
    amenities?: boolean
    garage?: boolean
    basement?: boolean
    fireplace?: boolean
    pool?: boolean
    pet?: boolean
    utilities?: boolean
    income?: boolean
    school?: boolean
    bus?: boolean
    restaurant?: boolean
    images?: boolean
    description?: boolean
    listingStatus?: boolean
    listingType?: boolean
    userId?: boolean
    userName?: boolean
    userAvatar?: boolean
    userEmail?: boolean
    status?: boolean
    flagged?: boolean
    reportedBy?: boolean
    flagReason?: boolean
    flagStatus?: boolean
    flaggedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Bookmark?: boolean | Property$BookmarkArgs<ExtArgs>
    PropertyView?: boolean | Property$PropertyViewArgs<ExtArgs>
    PropertyTourRequest?: boolean | Property$PropertyTourRequestArgs<ExtArgs>
    PropertyContactUserRequest?: boolean | Property$PropertyContactUserRequestArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>



  export type PropertySelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    price?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    latitude?: boolean
    longitude?: boolean
    neighborhood?: boolean
    views?: boolean
    type?: boolean
    property?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    size?: boolean
    lotSize?: boolean
    yearBuilt?: boolean
    hoaFees?: boolean
    leaseLength?: boolean
    furnished?: boolean
    deposit?: boolean
    moveInDate?: boolean
    amenities?: boolean
    garage?: boolean
    basement?: boolean
    fireplace?: boolean
    pool?: boolean
    pet?: boolean
    utilities?: boolean
    income?: boolean
    school?: boolean
    bus?: boolean
    restaurant?: boolean
    images?: boolean
    description?: boolean
    listingStatus?: boolean
    listingType?: boolean
    userId?: boolean
    userName?: boolean
    userAvatar?: boolean
    userEmail?: boolean
    status?: boolean
    flagged?: boolean
    reportedBy?: boolean
    flagReason?: boolean
    flagStatus?: boolean
    flaggedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "price" | "address" | "city" | "state" | "zip" | "latitude" | "longitude" | "neighborhood" | "views" | "type" | "property" | "bedrooms" | "bathrooms" | "size" | "lotSize" | "yearBuilt" | "hoaFees" | "leaseLength" | "furnished" | "deposit" | "moveInDate" | "amenities" | "garage" | "basement" | "fireplace" | "pool" | "pet" | "utilities" | "income" | "school" | "bus" | "restaurant" | "images" | "description" | "listingStatus" | "listingType" | "userId" | "userName" | "userAvatar" | "userEmail" | "status" | "flagged" | "reportedBy" | "flagReason" | "flagStatus" | "flaggedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Bookmark?: boolean | Property$BookmarkArgs<ExtArgs>
    PropertyView?: boolean | Property$PropertyViewArgs<ExtArgs>
    PropertyTourRequest?: boolean | Property$PropertyTourRequestArgs<ExtArgs>
    PropertyContactUserRequest?: boolean | Property$PropertyContactUserRequestArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Bookmark: Prisma.$BookmarkPayload<ExtArgs>[]
      PropertyView: Prisma.$PropertyViewPayload<ExtArgs>[]
      PropertyTourRequest: Prisma.$PropertyTourRequestPayload<ExtArgs>[]
      PropertyContactUserRequest: Prisma.$PropertyContactUserRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      price: number
      address: string | null
      city: string | null
      state: string | null
      zip: string | null
      latitude: string | null
      longitude: string | null
      neighborhood: string | null
      views: number
      type: $Enums.PropertyType
      property: $Enums.PropertyCategory
      bedrooms: number | null
      bathrooms: number | null
      size: number | null
      lotSize: number | null
      yearBuilt: number | null
      hoaFees: number | null
      leaseLength: string | null
      furnished: boolean | null
      deposit: number | null
      moveInDate: Date | null
      amenities: string[]
      garage: boolean | null
      basement: boolean | null
      fireplace: boolean | null
      pool: boolean | null
      pet: string | null
      utilities: string | null
      income: string | null
      school: string | null
      bus: string | null
      restaurant: string | null
      images: Prisma.JsonValue | null
      description: string
      listingStatus: $Enums.ListingStatus | null
      listingType: string
      userId: string
      userName: string | null
      userAvatar: string | null
      userEmail: string | null
      status: $Enums.PropertyStatus
      flagged: boolean
      reportedBy: string[]
      flagReason: string | null
      flagStatus: string | null
      flaggedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * @param {PropertyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const property = await prisma.property.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PropertyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Property.
     * @param {PropertyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const property = await prisma.property.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PropertyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Bookmark<T extends Property$BookmarkArgs<ExtArgs> = {}>(args?: Subset<T, Property$BookmarkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyView<T extends Property$PropertyViewArgs<ExtArgs> = {}>(args?: Subset<T, Property$PropertyViewArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyTourRequest<T extends Property$PropertyTourRequestArgs<ExtArgs> = {}>(args?: Subset<T, Property$PropertyTourRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PropertyContactUserRequest<T extends Property$PropertyContactUserRequestArgs<ExtArgs> = {}>(args?: Subset<T, Property$PropertyContactUserRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly title: FieldRef<"Property", 'String'>
    readonly slug: FieldRef<"Property", 'String'>
    readonly price: FieldRef<"Property", 'Float'>
    readonly address: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly state: FieldRef<"Property", 'String'>
    readonly zip: FieldRef<"Property", 'String'>
    readonly latitude: FieldRef<"Property", 'String'>
    readonly longitude: FieldRef<"Property", 'String'>
    readonly neighborhood: FieldRef<"Property", 'String'>
    readonly views: FieldRef<"Property", 'Int'>
    readonly type: FieldRef<"Property", 'PropertyType'>
    readonly property: FieldRef<"Property", 'PropertyCategory'>
    readonly bedrooms: FieldRef<"Property", 'Int'>
    readonly bathrooms: FieldRef<"Property", 'Int'>
    readonly size: FieldRef<"Property", 'Int'>
    readonly lotSize: FieldRef<"Property", 'Float'>
    readonly yearBuilt: FieldRef<"Property", 'Int'>
    readonly hoaFees: FieldRef<"Property", 'Int'>
    readonly leaseLength: FieldRef<"Property", 'String'>
    readonly furnished: FieldRef<"Property", 'Boolean'>
    readonly deposit: FieldRef<"Property", 'Float'>
    readonly moveInDate: FieldRef<"Property", 'DateTime'>
    readonly amenities: FieldRef<"Property", 'String[]'>
    readonly garage: FieldRef<"Property", 'Boolean'>
    readonly basement: FieldRef<"Property", 'Boolean'>
    readonly fireplace: FieldRef<"Property", 'Boolean'>
    readonly pool: FieldRef<"Property", 'Boolean'>
    readonly pet: FieldRef<"Property", 'String'>
    readonly utilities: FieldRef<"Property", 'String'>
    readonly income: FieldRef<"Property", 'String'>
    readonly school: FieldRef<"Property", 'String'>
    readonly bus: FieldRef<"Property", 'String'>
    readonly restaurant: FieldRef<"Property", 'String'>
    readonly images: FieldRef<"Property", 'Json'>
    readonly description: FieldRef<"Property", 'String'>
    readonly listingStatus: FieldRef<"Property", 'ListingStatus'>
    readonly listingType: FieldRef<"Property", 'String'>
    readonly userId: FieldRef<"Property", 'String'>
    readonly userName: FieldRef<"Property", 'String'>
    readonly userAvatar: FieldRef<"Property", 'String'>
    readonly userEmail: FieldRef<"Property", 'String'>
    readonly status: FieldRef<"Property", 'PropertyStatus'>
    readonly flagged: FieldRef<"Property", 'Boolean'>
    readonly reportedBy: FieldRef<"Property", 'String[]'>
    readonly flagReason: FieldRef<"Property", 'String'>
    readonly flagStatus: FieldRef<"Property", 'String'>
    readonly flaggedAt: FieldRef<"Property", 'DateTime'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property findRaw
   */
  export type PropertyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Property aggregateRaw
   */
  export type PropertyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Property.Bookmark
   */
  export type Property$BookmarkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Property.PropertyView
   */
  export type Property$PropertyViewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    cursor?: PropertyViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * Property.PropertyTourRequest
   */
  export type Property$PropertyTourRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    where?: PropertyTourRequestWhereInput
    orderBy?: PropertyTourRequestOrderByWithRelationInput | PropertyTourRequestOrderByWithRelationInput[]
    cursor?: PropertyTourRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyTourRequestScalarFieldEnum | PropertyTourRequestScalarFieldEnum[]
  }

  /**
   * Property.PropertyContactUserRequest
   */
  export type Property$PropertyContactUserRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    where?: PropertyContactUserRequestWhereInput
    orderBy?: PropertyContactUserRequestOrderByWithRelationInput | PropertyContactUserRequestOrderByWithRelationInput[]
    cursor?: PropertyContactUserRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyContactUserRequestScalarFieldEnum | PropertyContactUserRequestScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Bookmark
   */

  export type AggregateBookmark = {
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  export type BookmarkMinAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type BookmarkMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type BookmarkCountAggregateOutputType = {
    id: number
    userId: number
    propertyId: number
    createdAt: number
    _all: number
  }


  export type BookmarkMinAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    createdAt?: true
  }

  export type BookmarkMaxAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    createdAt?: true
  }

  export type BookmarkCountAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmark to aggregate.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookmarks
    **/
    _count?: true | BookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkMaxAggregateInputType
  }

  export type GetBookmarkAggregateType<T extends BookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmark[P]>
      : GetScalarType<T[P], AggregateBookmark[P]>
  }




  export type BookmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithAggregationInput | BookmarkOrderByWithAggregationInput[]
    by: BookmarkScalarFieldEnum[] | BookmarkScalarFieldEnum
    having?: BookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkCountAggregateInputType | true
    _min?: BookmarkMinAggregateInputType
    _max?: BookmarkMaxAggregateInputType
  }

  export type BookmarkGroupByOutputType = {
    id: string
    userId: string
    propertyId: string
    createdAt: Date
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  type GetBookmarkGroupByPayload<T extends BookmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>



  export type BookmarkSelectScalar = {
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
  }

  export type BookmarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "propertyId" | "createdAt", ExtArgs["result"]["bookmark"]>
  export type BookmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $BookmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookmark"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      propertyId: string
      createdAt: Date
    }, ExtArgs["result"]["bookmark"]>
    composites: {}
  }

  type BookmarkGetPayload<S extends boolean | null | undefined | BookmarkDefaultArgs> = $Result.GetResult<Prisma.$BookmarkPayload, S>

  type BookmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarkCountAggregateInputType | true
    }

  export interface BookmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookmark'], meta: { name: 'Bookmark' } }
    /**
     * Find zero or one Bookmark that matches the filter.
     * @param {BookmarkFindUniqueArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkFindUniqueArgs>(args: SelectSubset<T, BookmarkFindUniqueArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookmark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarkFindUniqueOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkFindFirstArgs>(args?: SelectSubset<T, BookmarkFindFirstArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookmarks
     * const bookmarks = await prisma.bookmark.findMany()
     * 
     * // Get first 10 Bookmarks
     * const bookmarks = await prisma.bookmark.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookmarkWithIdOnly = await prisma.bookmark.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookmarkFindManyArgs>(args?: SelectSubset<T, BookmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookmark.
     * @param {BookmarkCreateArgs} args - Arguments to create a Bookmark.
     * @example
     * // Create one Bookmark
     * const Bookmark = await prisma.bookmark.create({
     *   data: {
     *     // ... data to create a Bookmark
     *   }
     * })
     * 
     */
    create<T extends BookmarkCreateArgs>(args: SelectSubset<T, BookmarkCreateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookmarks.
     * @param {BookmarkCreateManyArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkCreateManyArgs>(args?: SelectSubset<T, BookmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bookmark.
     * @param {BookmarkDeleteArgs} args - Arguments to delete one Bookmark.
     * @example
     * // Delete one Bookmark
     * const Bookmark = await prisma.bookmark.delete({
     *   where: {
     *     // ... filter to delete one Bookmark
     *   }
     * })
     * 
     */
    delete<T extends BookmarkDeleteArgs>(args: SelectSubset<T, BookmarkDeleteArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookmark.
     * @param {BookmarkUpdateArgs} args - Arguments to update one Bookmark.
     * @example
     * // Update one Bookmark
     * const bookmark = await prisma.bookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkUpdateArgs>(args: SelectSubset<T, BookmarkUpdateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookmarks.
     * @param {BookmarkDeleteManyArgs} args - Arguments to filter Bookmarks to delete.
     * @example
     * // Delete a few Bookmarks
     * const { count } = await prisma.bookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkDeleteManyArgs>(args?: SelectSubset<T, BookmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkUpdateManyArgs>(args: SelectSubset<T, BookmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookmark.
     * @param {BookmarkUpsertArgs} args - Arguments to update or create a Bookmark.
     * @example
     * // Update or create a Bookmark
     * const bookmark = await prisma.bookmark.upsert({
     *   create: {
     *     // ... data to create a Bookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookmark we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkUpsertArgs>(args: SelectSubset<T, BookmarkUpsertArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * @param {BookmarkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bookmark = await prisma.bookmark.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BookmarkFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Bookmark.
     * @param {BookmarkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bookmark = await prisma.bookmark.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BookmarkAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCountArgs} args - Arguments to filter Bookmarks to count.
     * @example
     * // Count the number of Bookmarks
     * const count = await prisma.bookmark.count({
     *   where: {
     *     // ... the filter for the Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends BookmarkCountArgs>(
      args?: Subset<T, BookmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkAggregateArgs>(args: Subset<T, BookmarkAggregateArgs>): Prisma.PrismaPromise<GetBookmarkAggregateType<T>>

    /**
     * Group by Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookmark model
   */
  readonly fields: BookmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookmark model
   */
  interface BookmarkFieldRefs {
    readonly id: FieldRef<"Bookmark", 'String'>
    readonly userId: FieldRef<"Bookmark", 'String'>
    readonly propertyId: FieldRef<"Bookmark", 'String'>
    readonly createdAt: FieldRef<"Bookmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookmark findUnique
   */
  export type BookmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findUniqueOrThrow
   */
  export type BookmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findFirst
   */
  export type BookmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findFirstOrThrow
   */
  export type BookmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findMany
   */
  export type BookmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark create
   */
  export type BookmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookmark.
     */
    data: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
  }

  /**
   * Bookmark createMany
   */
  export type BookmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
  }

  /**
   * Bookmark update
   */
  export type BookmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookmark.
     */
    data: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
    /**
     * Choose, which Bookmark to update.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark updateMany
   */
  export type BookmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
  }

  /**
   * Bookmark upsert
   */
  export type BookmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookmark to update in case it exists.
     */
    where: BookmarkWhereUniqueInput
    /**
     * In case the Bookmark found by the `where` argument doesn't exist, create a new Bookmark with this data.
     */
    create: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
    /**
     * In case the Bookmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
  }

  /**
   * Bookmark delete
   */
  export type BookmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter which Bookmark to delete.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark deleteMany
   */
  export type BookmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to delete
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to delete.
     */
    limit?: number
  }

  /**
   * Bookmark findRaw
   */
  export type BookmarkFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Bookmark aggregateRaw
   */
  export type BookmarkAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Bookmark without action
   */
  export type BookmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
  }


  /**
   * Model PropertyView
   */

  export type AggregatePropertyView = {
    _count: PropertyViewCountAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  export type PropertyViewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    viewedAt: Date | null
  }

  export type PropertyViewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    viewedAt: Date | null
  }

  export type PropertyViewCountAggregateOutputType = {
    id: number
    userId: number
    propertyId: number
    viewedAt: number
    _all: number
  }


  export type PropertyViewMinAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    viewedAt?: true
  }

  export type PropertyViewMaxAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    viewedAt?: true
  }

  export type PropertyViewCountAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    viewedAt?: true
    _all?: true
  }

  export type PropertyViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyView to aggregate.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyViews
    **/
    _count?: true | PropertyViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyViewMaxAggregateInputType
  }

  export type GetPropertyViewAggregateType<T extends PropertyViewAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyView[P]>
      : GetScalarType<T[P], AggregatePropertyView[P]>
  }




  export type PropertyViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyViewWhereInput
    orderBy?: PropertyViewOrderByWithAggregationInput | PropertyViewOrderByWithAggregationInput[]
    by: PropertyViewScalarFieldEnum[] | PropertyViewScalarFieldEnum
    having?: PropertyViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyViewCountAggregateInputType | true
    _min?: PropertyViewMinAggregateInputType
    _max?: PropertyViewMaxAggregateInputType
  }

  export type PropertyViewGroupByOutputType = {
    id: string
    userId: string
    propertyId: string
    viewedAt: Date
    _count: PropertyViewCountAggregateOutputType | null
    _min: PropertyViewMinAggregateOutputType | null
    _max: PropertyViewMaxAggregateOutputType | null
  }

  type GetPropertyViewGroupByPayload<T extends PropertyViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyViewGroupByOutputType[P]>
        }
      >
    >


  export type PropertyViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    viewedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyView"]>



  export type PropertyViewSelectScalar = {
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    viewedAt?: boolean
  }

  export type PropertyViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "propertyId" | "viewedAt", ExtArgs["result"]["propertyView"]>
  export type PropertyViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyView"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      propertyId: string
      viewedAt: Date
    }, ExtArgs["result"]["propertyView"]>
    composites: {}
  }

  type PropertyViewGetPayload<S extends boolean | null | undefined | PropertyViewDefaultArgs> = $Result.GetResult<Prisma.$PropertyViewPayload, S>

  type PropertyViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyViewCountAggregateInputType | true
    }

  export interface PropertyViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyView'], meta: { name: 'PropertyView' } }
    /**
     * Find zero or one PropertyView that matches the filter.
     * @param {PropertyViewFindUniqueArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyViewFindUniqueArgs>(args: SelectSubset<T, PropertyViewFindUniqueArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyViewFindUniqueOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyViewFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyViewFindFirstArgs>(args?: SelectSubset<T, PropertyViewFindFirstArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindFirstOrThrowArgs} args - Arguments to find a PropertyView
     * @example
     * // Get one PropertyView
     * const propertyView = await prisma.propertyView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyViewFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyViews
     * const propertyViews = await prisma.propertyView.findMany()
     * 
     * // Get first 10 PropertyViews
     * const propertyViews = await prisma.propertyView.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyViewWithIdOnly = await prisma.propertyView.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyViewFindManyArgs>(args?: SelectSubset<T, PropertyViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyView.
     * @param {PropertyViewCreateArgs} args - Arguments to create a PropertyView.
     * @example
     * // Create one PropertyView
     * const PropertyView = await prisma.propertyView.create({
     *   data: {
     *     // ... data to create a PropertyView
     *   }
     * })
     * 
     */
    create<T extends PropertyViewCreateArgs>(args: SelectSubset<T, PropertyViewCreateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyViews.
     * @param {PropertyViewCreateManyArgs} args - Arguments to create many PropertyViews.
     * @example
     * // Create many PropertyViews
     * const propertyView = await prisma.propertyView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyViewCreateManyArgs>(args?: SelectSubset<T, PropertyViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyView.
     * @param {PropertyViewDeleteArgs} args - Arguments to delete one PropertyView.
     * @example
     * // Delete one PropertyView
     * const PropertyView = await prisma.propertyView.delete({
     *   where: {
     *     // ... filter to delete one PropertyView
     *   }
     * })
     * 
     */
    delete<T extends PropertyViewDeleteArgs>(args: SelectSubset<T, PropertyViewDeleteArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyView.
     * @param {PropertyViewUpdateArgs} args - Arguments to update one PropertyView.
     * @example
     * // Update one PropertyView
     * const propertyView = await prisma.propertyView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyViewUpdateArgs>(args: SelectSubset<T, PropertyViewUpdateArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyViews.
     * @param {PropertyViewDeleteManyArgs} args - Arguments to filter PropertyViews to delete.
     * @example
     * // Delete a few PropertyViews
     * const { count } = await prisma.propertyView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyViewDeleteManyArgs>(args?: SelectSubset<T, PropertyViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyViews
     * const propertyView = await prisma.propertyView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyViewUpdateManyArgs>(args: SelectSubset<T, PropertyViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyView.
     * @param {PropertyViewUpsertArgs} args - Arguments to update or create a PropertyView.
     * @example
     * // Update or create a PropertyView
     * const propertyView = await prisma.propertyView.upsert({
     *   create: {
     *     // ... data to create a PropertyView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyView we want to update
     *   }
     * })
     */
    upsert<T extends PropertyViewUpsertArgs>(args: SelectSubset<T, PropertyViewUpsertArgs<ExtArgs>>): Prisma__PropertyViewClient<$Result.GetResult<Prisma.$PropertyViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyViews that matches the filter.
     * @param {PropertyViewFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const propertyView = await prisma.propertyView.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PropertyViewFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PropertyView.
     * @param {PropertyViewAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const propertyView = await prisma.propertyView.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PropertyViewAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PropertyViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewCountArgs} args - Arguments to filter PropertyViews to count.
     * @example
     * // Count the number of PropertyViews
     * const count = await prisma.propertyView.count({
     *   where: {
     *     // ... the filter for the PropertyViews we want to count
     *   }
     * })
    **/
    count<T extends PropertyViewCountArgs>(
      args?: Subset<T, PropertyViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyViewAggregateArgs>(args: Subset<T, PropertyViewAggregateArgs>): Prisma.PrismaPromise<GetPropertyViewAggregateType<T>>

    /**
     * Group by PropertyView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyViewGroupByArgs['orderBy'] }
        : { orderBy?: PropertyViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyView model
   */
  readonly fields: PropertyViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyView model
   */
  interface PropertyViewFieldRefs {
    readonly id: FieldRef<"PropertyView", 'String'>
    readonly userId: FieldRef<"PropertyView", 'String'>
    readonly propertyId: FieldRef<"PropertyView", 'String'>
    readonly viewedAt: FieldRef<"PropertyView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyView findUnique
   */
  export type PropertyViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView findUniqueOrThrow
   */
  export type PropertyViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView findFirst
   */
  export type PropertyViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView findFirstOrThrow
   */
  export type PropertyViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyView to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyViews.
     */
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView findMany
   */
  export type PropertyViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter, which PropertyViews to fetch.
     */
    where?: PropertyViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyViews to fetch.
     */
    orderBy?: PropertyViewOrderByWithRelationInput | PropertyViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyViews.
     */
    cursor?: PropertyViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyViews.
     */
    skip?: number
    distinct?: PropertyViewScalarFieldEnum | PropertyViewScalarFieldEnum[]
  }

  /**
   * PropertyView create
   */
  export type PropertyViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyView.
     */
    data: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
  }

  /**
   * PropertyView createMany
   */
  export type PropertyViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyViews.
     */
    data: PropertyViewCreateManyInput | PropertyViewCreateManyInput[]
  }

  /**
   * PropertyView update
   */
  export type PropertyViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyView.
     */
    data: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
    /**
     * Choose, which PropertyView to update.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView updateMany
   */
  export type PropertyViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyViews.
     */
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyInput>
    /**
     * Filter which PropertyViews to update
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to update.
     */
    limit?: number
  }

  /**
   * PropertyView upsert
   */
  export type PropertyViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyView to update in case it exists.
     */
    where: PropertyViewWhereUniqueInput
    /**
     * In case the PropertyView found by the `where` argument doesn't exist, create a new PropertyView with this data.
     */
    create: XOR<PropertyViewCreateInput, PropertyViewUncheckedCreateInput>
    /**
     * In case the PropertyView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyViewUpdateInput, PropertyViewUncheckedUpdateInput>
  }

  /**
   * PropertyView delete
   */
  export type PropertyViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
    /**
     * Filter which PropertyView to delete.
     */
    where: PropertyViewWhereUniqueInput
  }

  /**
   * PropertyView deleteMany
   */
  export type PropertyViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyViews to delete
     */
    where?: PropertyViewWhereInput
    /**
     * Limit how many PropertyViews to delete.
     */
    limit?: number
  }

  /**
   * PropertyView findRaw
   */
  export type PropertyViewFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PropertyView aggregateRaw
   */
  export type PropertyViewAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PropertyView without action
   */
  export type PropertyViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyView
     */
    select?: PropertyViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyView
     */
    omit?: PropertyViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyViewInclude<ExtArgs> | null
  }


  /**
   * Model PropertyTourRequest
   */

  export type AggregatePropertyTourRequest = {
    _count: PropertyTourRequestCountAggregateOutputType | null
    _min: PropertyTourRequestMinAggregateOutputType | null
    _max: PropertyTourRequestMaxAggregateOutputType | null
  }

  export type PropertyTourRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    name: string | null
    email: string | null
    phone: string | null
    message: string | null
    createdAt: Date | null
  }

  export type PropertyTourRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    name: string | null
    email: string | null
    phone: string | null
    message: string | null
    createdAt: Date | null
  }

  export type PropertyTourRequestCountAggregateOutputType = {
    id: number
    userId: number
    propertyId: number
    name: number
    email: number
    phone: number
    message: number
    tourTimes: number
    createdAt: number
    _all: number
  }


  export type PropertyTourRequestMinAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    name?: true
    email?: true
    phone?: true
    message?: true
    createdAt?: true
  }

  export type PropertyTourRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    name?: true
    email?: true
    phone?: true
    message?: true
    createdAt?: true
  }

  export type PropertyTourRequestCountAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    name?: true
    email?: true
    phone?: true
    message?: true
    tourTimes?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyTourRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTourRequest to aggregate.
     */
    where?: PropertyTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTourRequests to fetch.
     */
    orderBy?: PropertyTourRequestOrderByWithRelationInput | PropertyTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyTourRequests
    **/
    _count?: true | PropertyTourRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyTourRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyTourRequestMaxAggregateInputType
  }

  export type GetPropertyTourRequestAggregateType<T extends PropertyTourRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyTourRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyTourRequest[P]>
      : GetScalarType<T[P], AggregatePropertyTourRequest[P]>
  }




  export type PropertyTourRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyTourRequestWhereInput
    orderBy?: PropertyTourRequestOrderByWithAggregationInput | PropertyTourRequestOrderByWithAggregationInput[]
    by: PropertyTourRequestScalarFieldEnum[] | PropertyTourRequestScalarFieldEnum
    having?: PropertyTourRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyTourRequestCountAggregateInputType | true
    _min?: PropertyTourRequestMinAggregateInputType
    _max?: PropertyTourRequestMaxAggregateInputType
  }

  export type PropertyTourRequestGroupByOutputType = {
    id: string
    userId: string
    propertyId: string
    name: string
    email: string
    phone: string
    message: string | null
    tourTimes: JsonValue
    createdAt: Date
    _count: PropertyTourRequestCountAggregateOutputType | null
    _min: PropertyTourRequestMinAggregateOutputType | null
    _max: PropertyTourRequestMaxAggregateOutputType | null
  }

  type GetPropertyTourRequestGroupByPayload<T extends PropertyTourRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyTourRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyTourRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyTourRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyTourRequestGroupByOutputType[P]>
        }
      >
    >


  export type PropertyTourRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    tourTimes?: boolean
    createdAt?: boolean
    user?: boolean | PropertyTourRequest$userArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyTourRequest"]>



  export type PropertyTourRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    tourTimes?: boolean
    createdAt?: boolean
  }

  export type PropertyTourRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "propertyId" | "name" | "email" | "phone" | "message" | "tourTimes" | "createdAt", ExtArgs["result"]["propertyTourRequest"]>
  export type PropertyTourRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PropertyTourRequest$userArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyTourRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyTourRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      propertyId: string
      name: string
      email: string
      phone: string
      message: string | null
      tourTimes: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["propertyTourRequest"]>
    composites: {}
  }

  type PropertyTourRequestGetPayload<S extends boolean | null | undefined | PropertyTourRequestDefaultArgs> = $Result.GetResult<Prisma.$PropertyTourRequestPayload, S>

  type PropertyTourRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyTourRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyTourRequestCountAggregateInputType | true
    }

  export interface PropertyTourRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyTourRequest'], meta: { name: 'PropertyTourRequest' } }
    /**
     * Find zero or one PropertyTourRequest that matches the filter.
     * @param {PropertyTourRequestFindUniqueArgs} args - Arguments to find a PropertyTourRequest
     * @example
     * // Get one PropertyTourRequest
     * const propertyTourRequest = await prisma.propertyTourRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyTourRequestFindUniqueArgs>(args: SelectSubset<T, PropertyTourRequestFindUniqueArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyTourRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyTourRequestFindUniqueOrThrowArgs} args - Arguments to find a PropertyTourRequest
     * @example
     * // Get one PropertyTourRequest
     * const propertyTourRequest = await prisma.propertyTourRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyTourRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyTourRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyTourRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestFindFirstArgs} args - Arguments to find a PropertyTourRequest
     * @example
     * // Get one PropertyTourRequest
     * const propertyTourRequest = await prisma.propertyTourRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyTourRequestFindFirstArgs>(args?: SelectSubset<T, PropertyTourRequestFindFirstArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyTourRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestFindFirstOrThrowArgs} args - Arguments to find a PropertyTourRequest
     * @example
     * // Get one PropertyTourRequest
     * const propertyTourRequest = await prisma.propertyTourRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyTourRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyTourRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyTourRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyTourRequests
     * const propertyTourRequests = await prisma.propertyTourRequest.findMany()
     * 
     * // Get first 10 PropertyTourRequests
     * const propertyTourRequests = await prisma.propertyTourRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyTourRequestWithIdOnly = await prisma.propertyTourRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyTourRequestFindManyArgs>(args?: SelectSubset<T, PropertyTourRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyTourRequest.
     * @param {PropertyTourRequestCreateArgs} args - Arguments to create a PropertyTourRequest.
     * @example
     * // Create one PropertyTourRequest
     * const PropertyTourRequest = await prisma.propertyTourRequest.create({
     *   data: {
     *     // ... data to create a PropertyTourRequest
     *   }
     * })
     * 
     */
    create<T extends PropertyTourRequestCreateArgs>(args: SelectSubset<T, PropertyTourRequestCreateArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyTourRequests.
     * @param {PropertyTourRequestCreateManyArgs} args - Arguments to create many PropertyTourRequests.
     * @example
     * // Create many PropertyTourRequests
     * const propertyTourRequest = await prisma.propertyTourRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyTourRequestCreateManyArgs>(args?: SelectSubset<T, PropertyTourRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyTourRequest.
     * @param {PropertyTourRequestDeleteArgs} args - Arguments to delete one PropertyTourRequest.
     * @example
     * // Delete one PropertyTourRequest
     * const PropertyTourRequest = await prisma.propertyTourRequest.delete({
     *   where: {
     *     // ... filter to delete one PropertyTourRequest
     *   }
     * })
     * 
     */
    delete<T extends PropertyTourRequestDeleteArgs>(args: SelectSubset<T, PropertyTourRequestDeleteArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyTourRequest.
     * @param {PropertyTourRequestUpdateArgs} args - Arguments to update one PropertyTourRequest.
     * @example
     * // Update one PropertyTourRequest
     * const propertyTourRequest = await prisma.propertyTourRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyTourRequestUpdateArgs>(args: SelectSubset<T, PropertyTourRequestUpdateArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyTourRequests.
     * @param {PropertyTourRequestDeleteManyArgs} args - Arguments to filter PropertyTourRequests to delete.
     * @example
     * // Delete a few PropertyTourRequests
     * const { count } = await prisma.propertyTourRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyTourRequestDeleteManyArgs>(args?: SelectSubset<T, PropertyTourRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyTourRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyTourRequests
     * const propertyTourRequest = await prisma.propertyTourRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyTourRequestUpdateManyArgs>(args: SelectSubset<T, PropertyTourRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyTourRequest.
     * @param {PropertyTourRequestUpsertArgs} args - Arguments to update or create a PropertyTourRequest.
     * @example
     * // Update or create a PropertyTourRequest
     * const propertyTourRequest = await prisma.propertyTourRequest.upsert({
     *   create: {
     *     // ... data to create a PropertyTourRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyTourRequest we want to update
     *   }
     * })
     */
    upsert<T extends PropertyTourRequestUpsertArgs>(args: SelectSubset<T, PropertyTourRequestUpsertArgs<ExtArgs>>): Prisma__PropertyTourRequestClient<$Result.GetResult<Prisma.$PropertyTourRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyTourRequests that matches the filter.
     * @param {PropertyTourRequestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const propertyTourRequest = await prisma.propertyTourRequest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PropertyTourRequestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PropertyTourRequest.
     * @param {PropertyTourRequestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const propertyTourRequest = await prisma.propertyTourRequest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PropertyTourRequestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PropertyTourRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestCountArgs} args - Arguments to filter PropertyTourRequests to count.
     * @example
     * // Count the number of PropertyTourRequests
     * const count = await prisma.propertyTourRequest.count({
     *   where: {
     *     // ... the filter for the PropertyTourRequests we want to count
     *   }
     * })
    **/
    count<T extends PropertyTourRequestCountArgs>(
      args?: Subset<T, PropertyTourRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyTourRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyTourRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyTourRequestAggregateArgs>(args: Subset<T, PropertyTourRequestAggregateArgs>): Prisma.PrismaPromise<GetPropertyTourRequestAggregateType<T>>

    /**
     * Group by PropertyTourRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyTourRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyTourRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyTourRequestGroupByArgs['orderBy'] }
        : { orderBy?: PropertyTourRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyTourRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyTourRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyTourRequest model
   */
  readonly fields: PropertyTourRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyTourRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyTourRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PropertyTourRequest$userArgs<ExtArgs> = {}>(args?: Subset<T, PropertyTourRequest$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyTourRequest model
   */
  interface PropertyTourRequestFieldRefs {
    readonly id: FieldRef<"PropertyTourRequest", 'String'>
    readonly userId: FieldRef<"PropertyTourRequest", 'String'>
    readonly propertyId: FieldRef<"PropertyTourRequest", 'String'>
    readonly name: FieldRef<"PropertyTourRequest", 'String'>
    readonly email: FieldRef<"PropertyTourRequest", 'String'>
    readonly phone: FieldRef<"PropertyTourRequest", 'String'>
    readonly message: FieldRef<"PropertyTourRequest", 'String'>
    readonly tourTimes: FieldRef<"PropertyTourRequest", 'Json'>
    readonly createdAt: FieldRef<"PropertyTourRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyTourRequest findUnique
   */
  export type PropertyTourRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTourRequest to fetch.
     */
    where: PropertyTourRequestWhereUniqueInput
  }

  /**
   * PropertyTourRequest findUniqueOrThrow
   */
  export type PropertyTourRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTourRequest to fetch.
     */
    where: PropertyTourRequestWhereUniqueInput
  }

  /**
   * PropertyTourRequest findFirst
   */
  export type PropertyTourRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTourRequest to fetch.
     */
    where?: PropertyTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTourRequests to fetch.
     */
    orderBy?: PropertyTourRequestOrderByWithRelationInput | PropertyTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTourRequests.
     */
    cursor?: PropertyTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTourRequests.
     */
    distinct?: PropertyTourRequestScalarFieldEnum | PropertyTourRequestScalarFieldEnum[]
  }

  /**
   * PropertyTourRequest findFirstOrThrow
   */
  export type PropertyTourRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTourRequest to fetch.
     */
    where?: PropertyTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTourRequests to fetch.
     */
    orderBy?: PropertyTourRequestOrderByWithRelationInput | PropertyTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyTourRequests.
     */
    cursor?: PropertyTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTourRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyTourRequests.
     */
    distinct?: PropertyTourRequestScalarFieldEnum | PropertyTourRequestScalarFieldEnum[]
  }

  /**
   * PropertyTourRequest findMany
   */
  export type PropertyTourRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyTourRequests to fetch.
     */
    where?: PropertyTourRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyTourRequests to fetch.
     */
    orderBy?: PropertyTourRequestOrderByWithRelationInput | PropertyTourRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyTourRequests.
     */
    cursor?: PropertyTourRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyTourRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyTourRequests.
     */
    skip?: number
    distinct?: PropertyTourRequestScalarFieldEnum | PropertyTourRequestScalarFieldEnum[]
  }

  /**
   * PropertyTourRequest create
   */
  export type PropertyTourRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyTourRequest.
     */
    data: XOR<PropertyTourRequestCreateInput, PropertyTourRequestUncheckedCreateInput>
  }

  /**
   * PropertyTourRequest createMany
   */
  export type PropertyTourRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyTourRequests.
     */
    data: PropertyTourRequestCreateManyInput | PropertyTourRequestCreateManyInput[]
  }

  /**
   * PropertyTourRequest update
   */
  export type PropertyTourRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyTourRequest.
     */
    data: XOR<PropertyTourRequestUpdateInput, PropertyTourRequestUncheckedUpdateInput>
    /**
     * Choose, which PropertyTourRequest to update.
     */
    where: PropertyTourRequestWhereUniqueInput
  }

  /**
   * PropertyTourRequest updateMany
   */
  export type PropertyTourRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyTourRequests.
     */
    data: XOR<PropertyTourRequestUpdateManyMutationInput, PropertyTourRequestUncheckedUpdateManyInput>
    /**
     * Filter which PropertyTourRequests to update
     */
    where?: PropertyTourRequestWhereInput
    /**
     * Limit how many PropertyTourRequests to update.
     */
    limit?: number
  }

  /**
   * PropertyTourRequest upsert
   */
  export type PropertyTourRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyTourRequest to update in case it exists.
     */
    where: PropertyTourRequestWhereUniqueInput
    /**
     * In case the PropertyTourRequest found by the `where` argument doesn't exist, create a new PropertyTourRequest with this data.
     */
    create: XOR<PropertyTourRequestCreateInput, PropertyTourRequestUncheckedCreateInput>
    /**
     * In case the PropertyTourRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyTourRequestUpdateInput, PropertyTourRequestUncheckedUpdateInput>
  }

  /**
   * PropertyTourRequest delete
   */
  export type PropertyTourRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
    /**
     * Filter which PropertyTourRequest to delete.
     */
    where: PropertyTourRequestWhereUniqueInput
  }

  /**
   * PropertyTourRequest deleteMany
   */
  export type PropertyTourRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyTourRequests to delete
     */
    where?: PropertyTourRequestWhereInput
    /**
     * Limit how many PropertyTourRequests to delete.
     */
    limit?: number
  }

  /**
   * PropertyTourRequest findRaw
   */
  export type PropertyTourRequestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PropertyTourRequest aggregateRaw
   */
  export type PropertyTourRequestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PropertyTourRequest.user
   */
  export type PropertyTourRequest$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PropertyTourRequest without action
   */
  export type PropertyTourRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyTourRequest
     */
    select?: PropertyTourRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyTourRequest
     */
    omit?: PropertyTourRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyTourRequestInclude<ExtArgs> | null
  }


  /**
   * Model PropertyContactUserRequest
   */

  export type AggregatePropertyContactUserRequest = {
    _count: PropertyContactUserRequestCountAggregateOutputType | null
    _min: PropertyContactUserRequestMinAggregateOutputType | null
    _max: PropertyContactUserRequestMaxAggregateOutputType | null
  }

  export type PropertyContactUserRequestMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    message: string | null
    userId: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyContactUserRequestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    message: string | null
    userId: string | null
    propertyId: string | null
    createdAt: Date | null
  }

  export type PropertyContactUserRequestCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    message: number
    userId: number
    propertyId: number
    createdAt: number
    _all: number
  }


  export type PropertyContactUserRequestMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    message?: true
    userId?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyContactUserRequestMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    message?: true
    userId?: true
    propertyId?: true
    createdAt?: true
  }

  export type PropertyContactUserRequestCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    message?: true
    userId?: true
    propertyId?: true
    createdAt?: true
    _all?: true
  }

  export type PropertyContactUserRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyContactUserRequest to aggregate.
     */
    where?: PropertyContactUserRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContactUserRequests to fetch.
     */
    orderBy?: PropertyContactUserRequestOrderByWithRelationInput | PropertyContactUserRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyContactUserRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContactUserRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContactUserRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyContactUserRequests
    **/
    _count?: true | PropertyContactUserRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyContactUserRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyContactUserRequestMaxAggregateInputType
  }

  export type GetPropertyContactUserRequestAggregateType<T extends PropertyContactUserRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyContactUserRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyContactUserRequest[P]>
      : GetScalarType<T[P], AggregatePropertyContactUserRequest[P]>
  }




  export type PropertyContactUserRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyContactUserRequestWhereInput
    orderBy?: PropertyContactUserRequestOrderByWithAggregationInput | PropertyContactUserRequestOrderByWithAggregationInput[]
    by: PropertyContactUserRequestScalarFieldEnum[] | PropertyContactUserRequestScalarFieldEnum
    having?: PropertyContactUserRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyContactUserRequestCountAggregateInputType | true
    _min?: PropertyContactUserRequestMinAggregateInputType
    _max?: PropertyContactUserRequestMaxAggregateInputType
  }

  export type PropertyContactUserRequestGroupByOutputType = {
    id: string
    name: string
    phone: string
    email: string
    message: string
    userId: string
    propertyId: string
    createdAt: Date
    _count: PropertyContactUserRequestCountAggregateOutputType | null
    _min: PropertyContactUserRequestMinAggregateOutputType | null
    _max: PropertyContactUserRequestMaxAggregateOutputType | null
  }

  type GetPropertyContactUserRequestGroupByPayload<T extends PropertyContactUserRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyContactUserRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyContactUserRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyContactUserRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyContactUserRequestGroupByOutputType[P]>
        }
      >
    >


  export type PropertyContactUserRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    message?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
    user?: boolean | PropertyContactUserRequest$userArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyContactUserRequest"]>



  export type PropertyContactUserRequestSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    message?: boolean
    userId?: boolean
    propertyId?: boolean
    createdAt?: boolean
  }

  export type PropertyContactUserRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "message" | "userId" | "propertyId" | "createdAt", ExtArgs["result"]["propertyContactUserRequest"]>
  export type PropertyContactUserRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | PropertyContactUserRequest$userArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyContactUserRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyContactUserRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string
      email: string
      message: string
      userId: string
      propertyId: string
      createdAt: Date
    }, ExtArgs["result"]["propertyContactUserRequest"]>
    composites: {}
  }

  type PropertyContactUserRequestGetPayload<S extends boolean | null | undefined | PropertyContactUserRequestDefaultArgs> = $Result.GetResult<Prisma.$PropertyContactUserRequestPayload, S>

  type PropertyContactUserRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyContactUserRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyContactUserRequestCountAggregateInputType | true
    }

  export interface PropertyContactUserRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyContactUserRequest'], meta: { name: 'PropertyContactUserRequest' } }
    /**
     * Find zero or one PropertyContactUserRequest that matches the filter.
     * @param {PropertyContactUserRequestFindUniqueArgs} args - Arguments to find a PropertyContactUserRequest
     * @example
     * // Get one PropertyContactUserRequest
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyContactUserRequestFindUniqueArgs>(args: SelectSubset<T, PropertyContactUserRequestFindUniqueArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyContactUserRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyContactUserRequestFindUniqueOrThrowArgs} args - Arguments to find a PropertyContactUserRequest
     * @example
     * // Get one PropertyContactUserRequest
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyContactUserRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyContactUserRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyContactUserRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestFindFirstArgs} args - Arguments to find a PropertyContactUserRequest
     * @example
     * // Get one PropertyContactUserRequest
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyContactUserRequestFindFirstArgs>(args?: SelectSubset<T, PropertyContactUserRequestFindFirstArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyContactUserRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestFindFirstOrThrowArgs} args - Arguments to find a PropertyContactUserRequest
     * @example
     * // Get one PropertyContactUserRequest
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyContactUserRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyContactUserRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyContactUserRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyContactUserRequests
     * const propertyContactUserRequests = await prisma.propertyContactUserRequest.findMany()
     * 
     * // Get first 10 PropertyContactUserRequests
     * const propertyContactUserRequests = await prisma.propertyContactUserRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyContactUserRequestWithIdOnly = await prisma.propertyContactUserRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyContactUserRequestFindManyArgs>(args?: SelectSubset<T, PropertyContactUserRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyContactUserRequest.
     * @param {PropertyContactUserRequestCreateArgs} args - Arguments to create a PropertyContactUserRequest.
     * @example
     * // Create one PropertyContactUserRequest
     * const PropertyContactUserRequest = await prisma.propertyContactUserRequest.create({
     *   data: {
     *     // ... data to create a PropertyContactUserRequest
     *   }
     * })
     * 
     */
    create<T extends PropertyContactUserRequestCreateArgs>(args: SelectSubset<T, PropertyContactUserRequestCreateArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyContactUserRequests.
     * @param {PropertyContactUserRequestCreateManyArgs} args - Arguments to create many PropertyContactUserRequests.
     * @example
     * // Create many PropertyContactUserRequests
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyContactUserRequestCreateManyArgs>(args?: SelectSubset<T, PropertyContactUserRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PropertyContactUserRequest.
     * @param {PropertyContactUserRequestDeleteArgs} args - Arguments to delete one PropertyContactUserRequest.
     * @example
     * // Delete one PropertyContactUserRequest
     * const PropertyContactUserRequest = await prisma.propertyContactUserRequest.delete({
     *   where: {
     *     // ... filter to delete one PropertyContactUserRequest
     *   }
     * })
     * 
     */
    delete<T extends PropertyContactUserRequestDeleteArgs>(args: SelectSubset<T, PropertyContactUserRequestDeleteArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyContactUserRequest.
     * @param {PropertyContactUserRequestUpdateArgs} args - Arguments to update one PropertyContactUserRequest.
     * @example
     * // Update one PropertyContactUserRequest
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyContactUserRequestUpdateArgs>(args: SelectSubset<T, PropertyContactUserRequestUpdateArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyContactUserRequests.
     * @param {PropertyContactUserRequestDeleteManyArgs} args - Arguments to filter PropertyContactUserRequests to delete.
     * @example
     * // Delete a few PropertyContactUserRequests
     * const { count } = await prisma.propertyContactUserRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyContactUserRequestDeleteManyArgs>(args?: SelectSubset<T, PropertyContactUserRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyContactUserRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyContactUserRequests
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyContactUserRequestUpdateManyArgs>(args: SelectSubset<T, PropertyContactUserRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PropertyContactUserRequest.
     * @param {PropertyContactUserRequestUpsertArgs} args - Arguments to update or create a PropertyContactUserRequest.
     * @example
     * // Update or create a PropertyContactUserRequest
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.upsert({
     *   create: {
     *     // ... data to create a PropertyContactUserRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyContactUserRequest we want to update
     *   }
     * })
     */
    upsert<T extends PropertyContactUserRequestUpsertArgs>(args: SelectSubset<T, PropertyContactUserRequestUpsertArgs<ExtArgs>>): Prisma__PropertyContactUserRequestClient<$Result.GetResult<Prisma.$PropertyContactUserRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyContactUserRequests that matches the filter.
     * @param {PropertyContactUserRequestFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PropertyContactUserRequestFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PropertyContactUserRequest.
     * @param {PropertyContactUserRequestAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const propertyContactUserRequest = await prisma.propertyContactUserRequest.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PropertyContactUserRequestAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PropertyContactUserRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestCountArgs} args - Arguments to filter PropertyContactUserRequests to count.
     * @example
     * // Count the number of PropertyContactUserRequests
     * const count = await prisma.propertyContactUserRequest.count({
     *   where: {
     *     // ... the filter for the PropertyContactUserRequests we want to count
     *   }
     * })
    **/
    count<T extends PropertyContactUserRequestCountArgs>(
      args?: Subset<T, PropertyContactUserRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyContactUserRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyContactUserRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyContactUserRequestAggregateArgs>(args: Subset<T, PropertyContactUserRequestAggregateArgs>): Prisma.PrismaPromise<GetPropertyContactUserRequestAggregateType<T>>

    /**
     * Group by PropertyContactUserRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyContactUserRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyContactUserRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyContactUserRequestGroupByArgs['orderBy'] }
        : { orderBy?: PropertyContactUserRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyContactUserRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyContactUserRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyContactUserRequest model
   */
  readonly fields: PropertyContactUserRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyContactUserRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyContactUserRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends PropertyContactUserRequest$userArgs<ExtArgs> = {}>(args?: Subset<T, PropertyContactUserRequest$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyContactUserRequest model
   */
  interface PropertyContactUserRequestFieldRefs {
    readonly id: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly name: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly phone: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly email: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly message: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly userId: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly propertyId: FieldRef<"PropertyContactUserRequest", 'String'>
    readonly createdAt: FieldRef<"PropertyContactUserRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyContactUserRequest findUnique
   */
  export type PropertyContactUserRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContactUserRequest to fetch.
     */
    where: PropertyContactUserRequestWhereUniqueInput
  }

  /**
   * PropertyContactUserRequest findUniqueOrThrow
   */
  export type PropertyContactUserRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContactUserRequest to fetch.
     */
    where: PropertyContactUserRequestWhereUniqueInput
  }

  /**
   * PropertyContactUserRequest findFirst
   */
  export type PropertyContactUserRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContactUserRequest to fetch.
     */
    where?: PropertyContactUserRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContactUserRequests to fetch.
     */
    orderBy?: PropertyContactUserRequestOrderByWithRelationInput | PropertyContactUserRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyContactUserRequests.
     */
    cursor?: PropertyContactUserRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContactUserRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContactUserRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyContactUserRequests.
     */
    distinct?: PropertyContactUserRequestScalarFieldEnum | PropertyContactUserRequestScalarFieldEnum[]
  }

  /**
   * PropertyContactUserRequest findFirstOrThrow
   */
  export type PropertyContactUserRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContactUserRequest to fetch.
     */
    where?: PropertyContactUserRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContactUserRequests to fetch.
     */
    orderBy?: PropertyContactUserRequestOrderByWithRelationInput | PropertyContactUserRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyContactUserRequests.
     */
    cursor?: PropertyContactUserRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContactUserRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContactUserRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyContactUserRequests.
     */
    distinct?: PropertyContactUserRequestScalarFieldEnum | PropertyContactUserRequestScalarFieldEnum[]
  }

  /**
   * PropertyContactUserRequest findMany
   */
  export type PropertyContactUserRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * Filter, which PropertyContactUserRequests to fetch.
     */
    where?: PropertyContactUserRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyContactUserRequests to fetch.
     */
    orderBy?: PropertyContactUserRequestOrderByWithRelationInput | PropertyContactUserRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyContactUserRequests.
     */
    cursor?: PropertyContactUserRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyContactUserRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyContactUserRequests.
     */
    skip?: number
    distinct?: PropertyContactUserRequestScalarFieldEnum | PropertyContactUserRequestScalarFieldEnum[]
  }

  /**
   * PropertyContactUserRequest create
   */
  export type PropertyContactUserRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyContactUserRequest.
     */
    data: XOR<PropertyContactUserRequestCreateInput, PropertyContactUserRequestUncheckedCreateInput>
  }

  /**
   * PropertyContactUserRequest createMany
   */
  export type PropertyContactUserRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyContactUserRequests.
     */
    data: PropertyContactUserRequestCreateManyInput | PropertyContactUserRequestCreateManyInput[]
  }

  /**
   * PropertyContactUserRequest update
   */
  export type PropertyContactUserRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyContactUserRequest.
     */
    data: XOR<PropertyContactUserRequestUpdateInput, PropertyContactUserRequestUncheckedUpdateInput>
    /**
     * Choose, which PropertyContactUserRequest to update.
     */
    where: PropertyContactUserRequestWhereUniqueInput
  }

  /**
   * PropertyContactUserRequest updateMany
   */
  export type PropertyContactUserRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyContactUserRequests.
     */
    data: XOR<PropertyContactUserRequestUpdateManyMutationInput, PropertyContactUserRequestUncheckedUpdateManyInput>
    /**
     * Filter which PropertyContactUserRequests to update
     */
    where?: PropertyContactUserRequestWhereInput
    /**
     * Limit how many PropertyContactUserRequests to update.
     */
    limit?: number
  }

  /**
   * PropertyContactUserRequest upsert
   */
  export type PropertyContactUserRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyContactUserRequest to update in case it exists.
     */
    where: PropertyContactUserRequestWhereUniqueInput
    /**
     * In case the PropertyContactUserRequest found by the `where` argument doesn't exist, create a new PropertyContactUserRequest with this data.
     */
    create: XOR<PropertyContactUserRequestCreateInput, PropertyContactUserRequestUncheckedCreateInput>
    /**
     * In case the PropertyContactUserRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyContactUserRequestUpdateInput, PropertyContactUserRequestUncheckedUpdateInput>
  }

  /**
   * PropertyContactUserRequest delete
   */
  export type PropertyContactUserRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
    /**
     * Filter which PropertyContactUserRequest to delete.
     */
    where: PropertyContactUserRequestWhereUniqueInput
  }

  /**
   * PropertyContactUserRequest deleteMany
   */
  export type PropertyContactUserRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyContactUserRequests to delete
     */
    where?: PropertyContactUserRequestWhereInput
    /**
     * Limit how many PropertyContactUserRequests to delete.
     */
    limit?: number
  }

  /**
   * PropertyContactUserRequest findRaw
   */
  export type PropertyContactUserRequestFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PropertyContactUserRequest aggregateRaw
   */
  export type PropertyContactUserRequestAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PropertyContactUserRequest.user
   */
  export type PropertyContactUserRequest$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PropertyContactUserRequest without action
   */
  export type PropertyContactUserRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyContactUserRequest
     */
    select?: PropertyContactUserRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyContactUserRequest
     */
    omit?: PropertyContactUserRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyContactUserRequestInclude<ExtArgs> | null
  }


  /**
   * Model ContactUser
   */

  export type AggregateContactUser = {
    _count: ContactUserCountAggregateOutputType | null
    _min: ContactUserMinAggregateOutputType | null
    _max: ContactUserMaxAggregateOutputType | null
  }

  export type ContactUserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ContactUserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ContactUserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    createdAt: number
    _all: number
  }


  export type ContactUserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
  }

  export type ContactUserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
  }

  export type ContactUserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ContactUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUser to aggregate.
     */
    where?: ContactUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactUsers to fetch.
     */
    orderBy?: ContactUserOrderByWithRelationInput | ContactUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactUsers
    **/
    _count?: true | ContactUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUserMaxAggregateInputType
  }

  export type GetContactUserAggregateType<T extends ContactUserAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUser[P]>
      : GetScalarType<T[P], AggregateContactUser[P]>
  }




  export type ContactUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactUserWhereInput
    orderBy?: ContactUserOrderByWithAggregationInput | ContactUserOrderByWithAggregationInput[]
    by: ContactUserScalarFieldEnum[] | ContactUserScalarFieldEnum
    having?: ContactUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUserCountAggregateInputType | true
    _min?: ContactUserMinAggregateInputType
    _max?: ContactUserMaxAggregateInputType
  }

  export type ContactUserGroupByOutputType = {
    id: string
    name: string
    email: string
    subject: string
    message: string
    createdAt: Date
    _count: ContactUserCountAggregateOutputType | null
    _min: ContactUserMinAggregateOutputType | null
    _max: ContactUserMaxAggregateOutputType | null
  }

  type GetContactUserGroupByPayload<T extends ContactUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUserGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUserGroupByOutputType[P]>
        }
      >
    >


  export type ContactUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactUser"]>



  export type ContactUserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ContactUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "createdAt", ExtArgs["result"]["contactUser"]>

  export type $ContactUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      subject: string
      message: string
      createdAt: Date
    }, ExtArgs["result"]["contactUser"]>
    composites: {}
  }

  type ContactUserGetPayload<S extends boolean | null | undefined | ContactUserDefaultArgs> = $Result.GetResult<Prisma.$ContactUserPayload, S>

  type ContactUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactUserCountAggregateInputType | true
    }

  export interface ContactUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactUser'], meta: { name: 'ContactUser' } }
    /**
     * Find zero or one ContactUser that matches the filter.
     * @param {ContactUserFindUniqueArgs} args - Arguments to find a ContactUser
     * @example
     * // Get one ContactUser
     * const contactUser = await prisma.contactUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactUserFindUniqueArgs>(args: SelectSubset<T, ContactUserFindUniqueArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactUserFindUniqueOrThrowArgs} args - Arguments to find a ContactUser
     * @example
     * // Get one ContactUser
     * const contactUser = await prisma.contactUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserFindFirstArgs} args - Arguments to find a ContactUser
     * @example
     * // Get one ContactUser
     * const contactUser = await prisma.contactUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactUserFindFirstArgs>(args?: SelectSubset<T, ContactUserFindFirstArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserFindFirstOrThrowArgs} args - Arguments to find a ContactUser
     * @example
     * // Get one ContactUser
     * const contactUser = await prisma.contactUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactUsers
     * const contactUsers = await prisma.contactUser.findMany()
     * 
     * // Get first 10 ContactUsers
     * const contactUsers = await prisma.contactUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUserWithIdOnly = await prisma.contactUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactUserFindManyArgs>(args?: SelectSubset<T, ContactUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactUser.
     * @param {ContactUserCreateArgs} args - Arguments to create a ContactUser.
     * @example
     * // Create one ContactUser
     * const ContactUser = await prisma.contactUser.create({
     *   data: {
     *     // ... data to create a ContactUser
     *   }
     * })
     * 
     */
    create<T extends ContactUserCreateArgs>(args: SelectSubset<T, ContactUserCreateArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactUsers.
     * @param {ContactUserCreateManyArgs} args - Arguments to create many ContactUsers.
     * @example
     * // Create many ContactUsers
     * const contactUser = await prisma.contactUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactUserCreateManyArgs>(args?: SelectSubset<T, ContactUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUser.
     * @param {ContactUserDeleteArgs} args - Arguments to delete one ContactUser.
     * @example
     * // Delete one ContactUser
     * const ContactUser = await prisma.contactUser.delete({
     *   where: {
     *     // ... filter to delete one ContactUser
     *   }
     * })
     * 
     */
    delete<T extends ContactUserDeleteArgs>(args: SelectSubset<T, ContactUserDeleteArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactUser.
     * @param {ContactUserUpdateArgs} args - Arguments to update one ContactUser.
     * @example
     * // Update one ContactUser
     * const contactUser = await prisma.contactUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUserUpdateArgs>(args: SelectSubset<T, ContactUserUpdateArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactUsers.
     * @param {ContactUserDeleteManyArgs} args - Arguments to filter ContactUsers to delete.
     * @example
     * // Delete a few ContactUsers
     * const { count } = await prisma.contactUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactUserDeleteManyArgs>(args?: SelectSubset<T, ContactUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactUsers
     * const contactUser = await prisma.contactUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUserUpdateManyArgs>(args: SelectSubset<T, ContactUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUser.
     * @param {ContactUserUpsertArgs} args - Arguments to update or create a ContactUser.
     * @example
     * // Update or create a ContactUser
     * const contactUser = await prisma.contactUser.upsert({
     *   create: {
     *     // ... data to create a ContactUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUser we want to update
     *   }
     * })
     */
    upsert<T extends ContactUserUpsertArgs>(args: SelectSubset<T, ContactUserUpsertArgs<ExtArgs>>): Prisma__ContactUserClient<$Result.GetResult<Prisma.$ContactUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactUsers that matches the filter.
     * @param {ContactUserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contactUser = await prisma.contactUser.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContactUserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContactUser.
     * @param {ContactUserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contactUser = await prisma.contactUser.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContactUserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContactUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserCountArgs} args - Arguments to filter ContactUsers to count.
     * @example
     * // Count the number of ContactUsers
     * const count = await prisma.contactUser.count({
     *   where: {
     *     // ... the filter for the ContactUsers we want to count
     *   }
     * })
    **/
    count<T extends ContactUserCountArgs>(
      args?: Subset<T, ContactUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUserAggregateArgs>(args: Subset<T, ContactUserAggregateArgs>): Prisma.PrismaPromise<GetContactUserAggregateType<T>>

    /**
     * Group by ContactUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactUserGroupByArgs['orderBy'] }
        : { orderBy?: ContactUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactUser model
   */
  readonly fields: ContactUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactUser model
   */
  interface ContactUserFieldRefs {
    readonly id: FieldRef<"ContactUser", 'String'>
    readonly name: FieldRef<"ContactUser", 'String'>
    readonly email: FieldRef<"ContactUser", 'String'>
    readonly subject: FieldRef<"ContactUser", 'String'>
    readonly message: FieldRef<"ContactUser", 'String'>
    readonly createdAt: FieldRef<"ContactUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactUser findUnique
   */
  export type ContactUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * Filter, which ContactUser to fetch.
     */
    where: ContactUserWhereUniqueInput
  }

  /**
   * ContactUser findUniqueOrThrow
   */
  export type ContactUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * Filter, which ContactUser to fetch.
     */
    where: ContactUserWhereUniqueInput
  }

  /**
   * ContactUser findFirst
   */
  export type ContactUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * Filter, which ContactUser to fetch.
     */
    where?: ContactUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactUsers to fetch.
     */
    orderBy?: ContactUserOrderByWithRelationInput | ContactUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactUsers.
     */
    cursor?: ContactUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactUsers.
     */
    distinct?: ContactUserScalarFieldEnum | ContactUserScalarFieldEnum[]
  }

  /**
   * ContactUser findFirstOrThrow
   */
  export type ContactUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * Filter, which ContactUser to fetch.
     */
    where?: ContactUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactUsers to fetch.
     */
    orderBy?: ContactUserOrderByWithRelationInput | ContactUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactUsers.
     */
    cursor?: ContactUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactUsers.
     */
    distinct?: ContactUserScalarFieldEnum | ContactUserScalarFieldEnum[]
  }

  /**
   * ContactUser findMany
   */
  export type ContactUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * Filter, which ContactUsers to fetch.
     */
    where?: ContactUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactUsers to fetch.
     */
    orderBy?: ContactUserOrderByWithRelationInput | ContactUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactUsers.
     */
    cursor?: ContactUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactUsers.
     */
    skip?: number
    distinct?: ContactUserScalarFieldEnum | ContactUserScalarFieldEnum[]
  }

  /**
   * ContactUser create
   */
  export type ContactUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactUser.
     */
    data: XOR<ContactUserCreateInput, ContactUserUncheckedCreateInput>
  }

  /**
   * ContactUser createMany
   */
  export type ContactUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactUsers.
     */
    data: ContactUserCreateManyInput | ContactUserCreateManyInput[]
  }

  /**
   * ContactUser update
   */
  export type ContactUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactUser.
     */
    data: XOR<ContactUserUpdateInput, ContactUserUncheckedUpdateInput>
    /**
     * Choose, which ContactUser to update.
     */
    where: ContactUserWhereUniqueInput
  }

  /**
   * ContactUser updateMany
   */
  export type ContactUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactUsers.
     */
    data: XOR<ContactUserUpdateManyMutationInput, ContactUserUncheckedUpdateManyInput>
    /**
     * Filter which ContactUsers to update
     */
    where?: ContactUserWhereInput
    /**
     * Limit how many ContactUsers to update.
     */
    limit?: number
  }

  /**
   * ContactUser upsert
   */
  export type ContactUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactUser to update in case it exists.
     */
    where: ContactUserWhereUniqueInput
    /**
     * In case the ContactUser found by the `where` argument doesn't exist, create a new ContactUser with this data.
     */
    create: XOR<ContactUserCreateInput, ContactUserUncheckedCreateInput>
    /**
     * In case the ContactUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUserUpdateInput, ContactUserUncheckedUpdateInput>
  }

  /**
   * ContactUser delete
   */
  export type ContactUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
    /**
     * Filter which ContactUser to delete.
     */
    where: ContactUserWhereUniqueInput
  }

  /**
   * ContactUser deleteMany
   */
  export type ContactUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactUsers to delete
     */
    where?: ContactUserWhereInput
    /**
     * Limit how many ContactUsers to delete.
     */
    limit?: number
  }

  /**
   * ContactUser findRaw
   */
  export type ContactUserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactUser aggregateRaw
   */
  export type ContactUserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactUser without action
   */
  export type ContactUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactUser
     */
    select?: ContactUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactUser
     */
    omit?: ContactUserOmit<ExtArgs> | null
  }


  /**
   * Model GetEstimate
   */

  export type AggregateGetEstimate = {
    _count: GetEstimateCountAggregateOutputType | null
    _min: GetEstimateMinAggregateOutputType | null
    _max: GetEstimateMaxAggregateOutputType | null
  }

  export type GetEstimateMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
  }

  export type GetEstimateMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
  }

  export type GetEstimateCountAggregateOutputType = {
    id: number
    email: number
    createdAt: number
    _all: number
  }


  export type GetEstimateMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
  }

  export type GetEstimateMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
  }

  export type GetEstimateCountAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    _all?: true
  }

  export type GetEstimateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GetEstimate to aggregate.
     */
    where?: GetEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetEstimates to fetch.
     */
    orderBy?: GetEstimateOrderByWithRelationInput | GetEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GetEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GetEstimates
    **/
    _count?: true | GetEstimateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GetEstimateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GetEstimateMaxAggregateInputType
  }

  export type GetGetEstimateAggregateType<T extends GetEstimateAggregateArgs> = {
        [P in keyof T & keyof AggregateGetEstimate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGetEstimate[P]>
      : GetScalarType<T[P], AggregateGetEstimate[P]>
  }




  export type GetEstimateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GetEstimateWhereInput
    orderBy?: GetEstimateOrderByWithAggregationInput | GetEstimateOrderByWithAggregationInput[]
    by: GetEstimateScalarFieldEnum[] | GetEstimateScalarFieldEnum
    having?: GetEstimateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GetEstimateCountAggregateInputType | true
    _min?: GetEstimateMinAggregateInputType
    _max?: GetEstimateMaxAggregateInputType
  }

  export type GetEstimateGroupByOutputType = {
    id: string
    email: string
    createdAt: Date
    _count: GetEstimateCountAggregateOutputType | null
    _min: GetEstimateMinAggregateOutputType | null
    _max: GetEstimateMaxAggregateOutputType | null
  }

  type GetGetEstimateGroupByPayload<T extends GetEstimateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GetEstimateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GetEstimateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GetEstimateGroupByOutputType[P]>
            : GetScalarType<T[P], GetEstimateGroupByOutputType[P]>
        }
      >
    >


  export type GetEstimateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["getEstimate"]>



  export type GetEstimateSelectScalar = {
    id?: boolean
    email?: boolean
    createdAt?: boolean
  }

  export type GetEstimateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "createdAt", ExtArgs["result"]["getEstimate"]>

  export type $GetEstimatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GetEstimate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      createdAt: Date
    }, ExtArgs["result"]["getEstimate"]>
    composites: {}
  }

  type GetEstimateGetPayload<S extends boolean | null | undefined | GetEstimateDefaultArgs> = $Result.GetResult<Prisma.$GetEstimatePayload, S>

  type GetEstimateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GetEstimateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GetEstimateCountAggregateInputType | true
    }

  export interface GetEstimateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GetEstimate'], meta: { name: 'GetEstimate' } }
    /**
     * Find zero or one GetEstimate that matches the filter.
     * @param {GetEstimateFindUniqueArgs} args - Arguments to find a GetEstimate
     * @example
     * // Get one GetEstimate
     * const getEstimate = await prisma.getEstimate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GetEstimateFindUniqueArgs>(args: SelectSubset<T, GetEstimateFindUniqueArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GetEstimate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GetEstimateFindUniqueOrThrowArgs} args - Arguments to find a GetEstimate
     * @example
     * // Get one GetEstimate
     * const getEstimate = await prisma.getEstimate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GetEstimateFindUniqueOrThrowArgs>(args: SelectSubset<T, GetEstimateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GetEstimate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateFindFirstArgs} args - Arguments to find a GetEstimate
     * @example
     * // Get one GetEstimate
     * const getEstimate = await prisma.getEstimate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GetEstimateFindFirstArgs>(args?: SelectSubset<T, GetEstimateFindFirstArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GetEstimate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateFindFirstOrThrowArgs} args - Arguments to find a GetEstimate
     * @example
     * // Get one GetEstimate
     * const getEstimate = await prisma.getEstimate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GetEstimateFindFirstOrThrowArgs>(args?: SelectSubset<T, GetEstimateFindFirstOrThrowArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GetEstimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GetEstimates
     * const getEstimates = await prisma.getEstimate.findMany()
     * 
     * // Get first 10 GetEstimates
     * const getEstimates = await prisma.getEstimate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const getEstimateWithIdOnly = await prisma.getEstimate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GetEstimateFindManyArgs>(args?: SelectSubset<T, GetEstimateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GetEstimate.
     * @param {GetEstimateCreateArgs} args - Arguments to create a GetEstimate.
     * @example
     * // Create one GetEstimate
     * const GetEstimate = await prisma.getEstimate.create({
     *   data: {
     *     // ... data to create a GetEstimate
     *   }
     * })
     * 
     */
    create<T extends GetEstimateCreateArgs>(args: SelectSubset<T, GetEstimateCreateArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GetEstimates.
     * @param {GetEstimateCreateManyArgs} args - Arguments to create many GetEstimates.
     * @example
     * // Create many GetEstimates
     * const getEstimate = await prisma.getEstimate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GetEstimateCreateManyArgs>(args?: SelectSubset<T, GetEstimateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GetEstimate.
     * @param {GetEstimateDeleteArgs} args - Arguments to delete one GetEstimate.
     * @example
     * // Delete one GetEstimate
     * const GetEstimate = await prisma.getEstimate.delete({
     *   where: {
     *     // ... filter to delete one GetEstimate
     *   }
     * })
     * 
     */
    delete<T extends GetEstimateDeleteArgs>(args: SelectSubset<T, GetEstimateDeleteArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GetEstimate.
     * @param {GetEstimateUpdateArgs} args - Arguments to update one GetEstimate.
     * @example
     * // Update one GetEstimate
     * const getEstimate = await prisma.getEstimate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GetEstimateUpdateArgs>(args: SelectSubset<T, GetEstimateUpdateArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GetEstimates.
     * @param {GetEstimateDeleteManyArgs} args - Arguments to filter GetEstimates to delete.
     * @example
     * // Delete a few GetEstimates
     * const { count } = await prisma.getEstimate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GetEstimateDeleteManyArgs>(args?: SelectSubset<T, GetEstimateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GetEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GetEstimates
     * const getEstimate = await prisma.getEstimate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GetEstimateUpdateManyArgs>(args: SelectSubset<T, GetEstimateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GetEstimate.
     * @param {GetEstimateUpsertArgs} args - Arguments to update or create a GetEstimate.
     * @example
     * // Update or create a GetEstimate
     * const getEstimate = await prisma.getEstimate.upsert({
     *   create: {
     *     // ... data to create a GetEstimate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GetEstimate we want to update
     *   }
     * })
     */
    upsert<T extends GetEstimateUpsertArgs>(args: SelectSubset<T, GetEstimateUpsertArgs<ExtArgs>>): Prisma__GetEstimateClient<$Result.GetResult<Prisma.$GetEstimatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GetEstimates that matches the filter.
     * @param {GetEstimateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const getEstimate = await prisma.getEstimate.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GetEstimateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GetEstimate.
     * @param {GetEstimateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const getEstimate = await prisma.getEstimate.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GetEstimateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GetEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateCountArgs} args - Arguments to filter GetEstimates to count.
     * @example
     * // Count the number of GetEstimates
     * const count = await prisma.getEstimate.count({
     *   where: {
     *     // ... the filter for the GetEstimates we want to count
     *   }
     * })
    **/
    count<T extends GetEstimateCountArgs>(
      args?: Subset<T, GetEstimateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GetEstimateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GetEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GetEstimateAggregateArgs>(args: Subset<T, GetEstimateAggregateArgs>): Prisma.PrismaPromise<GetGetEstimateAggregateType<T>>

    /**
     * Group by GetEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GetEstimateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GetEstimateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GetEstimateGroupByArgs['orderBy'] }
        : { orderBy?: GetEstimateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GetEstimateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGetEstimateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GetEstimate model
   */
  readonly fields: GetEstimateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GetEstimate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GetEstimateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GetEstimate model
   */
  interface GetEstimateFieldRefs {
    readonly id: FieldRef<"GetEstimate", 'String'>
    readonly email: FieldRef<"GetEstimate", 'String'>
    readonly createdAt: FieldRef<"GetEstimate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GetEstimate findUnique
   */
  export type GetEstimateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * Filter, which GetEstimate to fetch.
     */
    where: GetEstimateWhereUniqueInput
  }

  /**
   * GetEstimate findUniqueOrThrow
   */
  export type GetEstimateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * Filter, which GetEstimate to fetch.
     */
    where: GetEstimateWhereUniqueInput
  }

  /**
   * GetEstimate findFirst
   */
  export type GetEstimateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * Filter, which GetEstimate to fetch.
     */
    where?: GetEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetEstimates to fetch.
     */
    orderBy?: GetEstimateOrderByWithRelationInput | GetEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GetEstimates.
     */
    cursor?: GetEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GetEstimates.
     */
    distinct?: GetEstimateScalarFieldEnum | GetEstimateScalarFieldEnum[]
  }

  /**
   * GetEstimate findFirstOrThrow
   */
  export type GetEstimateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * Filter, which GetEstimate to fetch.
     */
    where?: GetEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetEstimates to fetch.
     */
    orderBy?: GetEstimateOrderByWithRelationInput | GetEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GetEstimates.
     */
    cursor?: GetEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GetEstimates.
     */
    distinct?: GetEstimateScalarFieldEnum | GetEstimateScalarFieldEnum[]
  }

  /**
   * GetEstimate findMany
   */
  export type GetEstimateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * Filter, which GetEstimates to fetch.
     */
    where?: GetEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GetEstimates to fetch.
     */
    orderBy?: GetEstimateOrderByWithRelationInput | GetEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GetEstimates.
     */
    cursor?: GetEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GetEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GetEstimates.
     */
    skip?: number
    distinct?: GetEstimateScalarFieldEnum | GetEstimateScalarFieldEnum[]
  }

  /**
   * GetEstimate create
   */
  export type GetEstimateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * The data needed to create a GetEstimate.
     */
    data: XOR<GetEstimateCreateInput, GetEstimateUncheckedCreateInput>
  }

  /**
   * GetEstimate createMany
   */
  export type GetEstimateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GetEstimates.
     */
    data: GetEstimateCreateManyInput | GetEstimateCreateManyInput[]
  }

  /**
   * GetEstimate update
   */
  export type GetEstimateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * The data needed to update a GetEstimate.
     */
    data: XOR<GetEstimateUpdateInput, GetEstimateUncheckedUpdateInput>
    /**
     * Choose, which GetEstimate to update.
     */
    where: GetEstimateWhereUniqueInput
  }

  /**
   * GetEstimate updateMany
   */
  export type GetEstimateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GetEstimates.
     */
    data: XOR<GetEstimateUpdateManyMutationInput, GetEstimateUncheckedUpdateManyInput>
    /**
     * Filter which GetEstimates to update
     */
    where?: GetEstimateWhereInput
    /**
     * Limit how many GetEstimates to update.
     */
    limit?: number
  }

  /**
   * GetEstimate upsert
   */
  export type GetEstimateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * The filter to search for the GetEstimate to update in case it exists.
     */
    where: GetEstimateWhereUniqueInput
    /**
     * In case the GetEstimate found by the `where` argument doesn't exist, create a new GetEstimate with this data.
     */
    create: XOR<GetEstimateCreateInput, GetEstimateUncheckedCreateInput>
    /**
     * In case the GetEstimate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GetEstimateUpdateInput, GetEstimateUncheckedUpdateInput>
  }

  /**
   * GetEstimate delete
   */
  export type GetEstimateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
    /**
     * Filter which GetEstimate to delete.
     */
    where: GetEstimateWhereUniqueInput
  }

  /**
   * GetEstimate deleteMany
   */
  export type GetEstimateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GetEstimates to delete
     */
    where?: GetEstimateWhereInput
    /**
     * Limit how many GetEstimates to delete.
     */
    limit?: number
  }

  /**
   * GetEstimate findRaw
   */
  export type GetEstimateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GetEstimate aggregateRaw
   */
  export type GetEstimateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GetEstimate without action
   */
  export type GetEstimateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GetEstimate
     */
    select?: GetEstimateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GetEstimate
     */
    omit?: GetEstimateOmit<ExtArgs> | null
  }


  /**
   * Model Faqs
   */

  export type AggregateFaqs = {
    _count: FaqsCountAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  export type FaqsMinAggregateOutputType = {
    id: string | null
    question: string | null
    slug: string | null
    answer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaqsMaxAggregateOutputType = {
    id: string | null
    question: string | null
    slug: string | null
    answer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FaqsCountAggregateOutputType = {
    id: number
    question: number
    slug: number
    answer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FaqsMinAggregateInputType = {
    id?: true
    question?: true
    slug?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaqsMaxAggregateInputType = {
    id?: true
    question?: true
    slug?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FaqsCountAggregateInputType = {
    id?: true
    question?: true
    slug?: true
    answer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FaqsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faqs to aggregate.
     */
    where?: FaqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqsOrderByWithRelationInput | FaqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FaqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Faqs
    **/
    _count?: true | FaqsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FaqsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FaqsMaxAggregateInputType
  }

  export type GetFaqsAggregateType<T extends FaqsAggregateArgs> = {
        [P in keyof T & keyof AggregateFaqs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaqs[P]>
      : GetScalarType<T[P], AggregateFaqs[P]>
  }




  export type FaqsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FaqsWhereInput
    orderBy?: FaqsOrderByWithAggregationInput | FaqsOrderByWithAggregationInput[]
    by: FaqsScalarFieldEnum[] | FaqsScalarFieldEnum
    having?: FaqsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FaqsCountAggregateInputType | true
    _min?: FaqsMinAggregateInputType
    _max?: FaqsMaxAggregateInputType
  }

  export type FaqsGroupByOutputType = {
    id: string
    question: string
    slug: string
    answer: string
    createdAt: Date
    updatedAt: Date
    _count: FaqsCountAggregateOutputType | null
    _min: FaqsMinAggregateOutputType | null
    _max: FaqsMaxAggregateOutputType | null
  }

  type GetFaqsGroupByPayload<T extends FaqsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FaqsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FaqsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FaqsGroupByOutputType[P]>
            : GetScalarType<T[P], FaqsGroupByOutputType[P]>
        }
      >
    >


  export type FaqsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    slug?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["faqs"]>



  export type FaqsSelectScalar = {
    id?: boolean
    question?: boolean
    slug?: boolean
    answer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FaqsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question" | "slug" | "answer" | "createdAt" | "updatedAt", ExtArgs["result"]["faqs"]>

  export type $FaqsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Faqs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      question: string
      slug: string
      answer: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["faqs"]>
    composites: {}
  }

  type FaqsGetPayload<S extends boolean | null | undefined | FaqsDefaultArgs> = $Result.GetResult<Prisma.$FaqsPayload, S>

  type FaqsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FaqsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FaqsCountAggregateInputType | true
    }

  export interface FaqsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Faqs'], meta: { name: 'Faqs' } }
    /**
     * Find zero or one Faqs that matches the filter.
     * @param {FaqsFindUniqueArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FaqsFindUniqueArgs>(args: SelectSubset<T, FaqsFindUniqueArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Faqs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FaqsFindUniqueOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FaqsFindUniqueOrThrowArgs>(args: SelectSubset<T, FaqsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsFindFirstArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FaqsFindFirstArgs>(args?: SelectSubset<T, FaqsFindFirstArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Faqs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsFindFirstOrThrowArgs} args - Arguments to find a Faqs
     * @example
     * // Get one Faqs
     * const faqs = await prisma.faqs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FaqsFindFirstOrThrowArgs>(args?: SelectSubset<T, FaqsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faqs
     * const faqs = await prisma.faqs.findMany()
     * 
     * // Get first 10 Faqs
     * const faqs = await prisma.faqs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faqsWithIdOnly = await prisma.faqs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FaqsFindManyArgs>(args?: SelectSubset<T, FaqsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Faqs.
     * @param {FaqsCreateArgs} args - Arguments to create a Faqs.
     * @example
     * // Create one Faqs
     * const Faqs = await prisma.faqs.create({
     *   data: {
     *     // ... data to create a Faqs
     *   }
     * })
     * 
     */
    create<T extends FaqsCreateArgs>(args: SelectSubset<T, FaqsCreateArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Faqs.
     * @param {FaqsCreateManyArgs} args - Arguments to create many Faqs.
     * @example
     * // Create many Faqs
     * const faqs = await prisma.faqs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FaqsCreateManyArgs>(args?: SelectSubset<T, FaqsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Faqs.
     * @param {FaqsDeleteArgs} args - Arguments to delete one Faqs.
     * @example
     * // Delete one Faqs
     * const Faqs = await prisma.faqs.delete({
     *   where: {
     *     // ... filter to delete one Faqs
     *   }
     * })
     * 
     */
    delete<T extends FaqsDeleteArgs>(args: SelectSubset<T, FaqsDeleteArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Faqs.
     * @param {FaqsUpdateArgs} args - Arguments to update one Faqs.
     * @example
     * // Update one Faqs
     * const faqs = await prisma.faqs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FaqsUpdateArgs>(args: SelectSubset<T, FaqsUpdateArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Faqs.
     * @param {FaqsDeleteManyArgs} args - Arguments to filter Faqs to delete.
     * @example
     * // Delete a few Faqs
     * const { count } = await prisma.faqs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FaqsDeleteManyArgs>(args?: SelectSubset<T, FaqsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faqs
     * const faqs = await prisma.faqs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FaqsUpdateManyArgs>(args: SelectSubset<T, FaqsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faqs.
     * @param {FaqsUpsertArgs} args - Arguments to update or create a Faqs.
     * @example
     * // Update or create a Faqs
     * const faqs = await prisma.faqs.upsert({
     *   create: {
     *     // ... data to create a Faqs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faqs we want to update
     *   }
     * })
     */
    upsert<T extends FaqsUpsertArgs>(args: SelectSubset<T, FaqsUpsertArgs<ExtArgs>>): Prisma__FaqsClient<$Result.GetResult<Prisma.$FaqsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Faqs that matches the filter.
     * @param {FaqsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const faqs = await prisma.faqs.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FaqsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Faqs.
     * @param {FaqsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const faqs = await prisma.faqs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FaqsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsCountArgs} args - Arguments to filter Faqs to count.
     * @example
     * // Count the number of Faqs
     * const count = await prisma.faqs.count({
     *   where: {
     *     // ... the filter for the Faqs we want to count
     *   }
     * })
    **/
    count<T extends FaqsCountArgs>(
      args?: Subset<T, FaqsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FaqsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FaqsAggregateArgs>(args: Subset<T, FaqsAggregateArgs>): Prisma.PrismaPromise<GetFaqsAggregateType<T>>

    /**
     * Group by Faqs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FaqsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FaqsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FaqsGroupByArgs['orderBy'] }
        : { orderBy?: FaqsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FaqsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaqsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Faqs model
   */
  readonly fields: FaqsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Faqs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FaqsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Faqs model
   */
  interface FaqsFieldRefs {
    readonly id: FieldRef<"Faqs", 'String'>
    readonly question: FieldRef<"Faqs", 'String'>
    readonly slug: FieldRef<"Faqs", 'String'>
    readonly answer: FieldRef<"Faqs", 'String'>
    readonly createdAt: FieldRef<"Faqs", 'DateTime'>
    readonly updatedAt: FieldRef<"Faqs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Faqs findUnique
   */
  export type FaqsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where: FaqsWhereUniqueInput
  }

  /**
   * Faqs findUniqueOrThrow
   */
  export type FaqsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where: FaqsWhereUniqueInput
  }

  /**
   * Faqs findFirst
   */
  export type FaqsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where?: FaqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqsOrderByWithRelationInput | FaqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     */
    cursor?: FaqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * Faqs findFirstOrThrow
   */
  export type FaqsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where?: FaqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqsOrderByWithRelationInput | FaqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Faqs.
     */
    cursor?: FaqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Faqs.
     */
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * Faqs findMany
   */
  export type FaqsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * Filter, which Faqs to fetch.
     */
    where?: FaqsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Faqs to fetch.
     */
    orderBy?: FaqsOrderByWithRelationInput | FaqsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Faqs.
     */
    cursor?: FaqsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Faqs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Faqs.
     */
    skip?: number
    distinct?: FaqsScalarFieldEnum | FaqsScalarFieldEnum[]
  }

  /**
   * Faqs create
   */
  export type FaqsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * The data needed to create a Faqs.
     */
    data: XOR<FaqsCreateInput, FaqsUncheckedCreateInput>
  }

  /**
   * Faqs createMany
   */
  export type FaqsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Faqs.
     */
    data: FaqsCreateManyInput | FaqsCreateManyInput[]
  }

  /**
   * Faqs update
   */
  export type FaqsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * The data needed to update a Faqs.
     */
    data: XOR<FaqsUpdateInput, FaqsUncheckedUpdateInput>
    /**
     * Choose, which Faqs to update.
     */
    where: FaqsWhereUniqueInput
  }

  /**
   * Faqs updateMany
   */
  export type FaqsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Faqs.
     */
    data: XOR<FaqsUpdateManyMutationInput, FaqsUncheckedUpdateManyInput>
    /**
     * Filter which Faqs to update
     */
    where?: FaqsWhereInput
    /**
     * Limit how many Faqs to update.
     */
    limit?: number
  }

  /**
   * Faqs upsert
   */
  export type FaqsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * The filter to search for the Faqs to update in case it exists.
     */
    where: FaqsWhereUniqueInput
    /**
     * In case the Faqs found by the `where` argument doesn't exist, create a new Faqs with this data.
     */
    create: XOR<FaqsCreateInput, FaqsUncheckedCreateInput>
    /**
     * In case the Faqs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FaqsUpdateInput, FaqsUncheckedUpdateInput>
  }

  /**
   * Faqs delete
   */
  export type FaqsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
    /**
     * Filter which Faqs to delete.
     */
    where: FaqsWhereUniqueInput
  }

  /**
   * Faqs deleteMany
   */
  export type FaqsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Faqs to delete
     */
    where?: FaqsWhereInput
    /**
     * Limit how many Faqs to delete.
     */
    limit?: number
  }

  /**
   * Faqs findRaw
   */
  export type FaqsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Faqs aggregateRaw
   */
  export type FaqsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Faqs without action
   */
  export type FaqsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Faqs
     */
    select?: FaqsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Faqs
     */
    omit?: FaqsOmit<ExtArgs> | null
  }


  /**
   * Model ContactInformation
   */

  export type AggregateContactInformation = {
    _count: ContactInformationCountAggregateOutputType | null
    _min: ContactInformationMinAggregateOutputType | null
    _max: ContactInformationMaxAggregateOutputType | null
  }

  export type ContactInformationMinAggregateOutputType = {
    id: string | null
    email: string | null
    email2: string | null
    phone: string | null
    phone2: string | null
    address: string | null
    address2: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInformationMaxAggregateOutputType = {
    id: string | null
    email: string | null
    email2: string | null
    phone: string | null
    phone2: string | null
    address: string | null
    address2: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactInformationCountAggregateOutputType = {
    id: number
    email: number
    email2: number
    phone: number
    phone2: number
    address: number
    address2: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactInformationMinAggregateInputType = {
    id?: true
    email?: true
    email2?: true
    phone?: true
    phone2?: true
    address?: true
    address2?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInformationMaxAggregateInputType = {
    id?: true
    email?: true
    email2?: true
    phone?: true
    phone2?: true
    address?: true
    address2?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactInformationCountAggregateInputType = {
    id?: true
    email?: true
    email2?: true
    phone?: true
    phone2?: true
    address?: true
    address2?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactInformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInformation to aggregate.
     */
    where?: ContactInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInformations to fetch.
     */
    orderBy?: ContactInformationOrderByWithRelationInput | ContactInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactInformations
    **/
    _count?: true | ContactInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactInformationMaxAggregateInputType
  }

  export type GetContactInformationAggregateType<T extends ContactInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateContactInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactInformation[P]>
      : GetScalarType<T[P], AggregateContactInformation[P]>
  }




  export type ContactInformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactInformationWhereInput
    orderBy?: ContactInformationOrderByWithAggregationInput | ContactInformationOrderByWithAggregationInput[]
    by: ContactInformationScalarFieldEnum[] | ContactInformationScalarFieldEnum
    having?: ContactInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactInformationCountAggregateInputType | true
    _min?: ContactInformationMinAggregateInputType
    _max?: ContactInformationMaxAggregateInputType
  }

  export type ContactInformationGroupByOutputType = {
    id: string
    email: string
    email2: string | null
    phone: string
    phone2: string | null
    address: string
    address2: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactInformationCountAggregateOutputType | null
    _min: ContactInformationMinAggregateOutputType | null
    _max: ContactInformationMaxAggregateOutputType | null
  }

  type GetContactInformationGroupByPayload<T extends ContactInformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactInformationGroupByOutputType[P]>
            : GetScalarType<T[P], ContactInformationGroupByOutputType[P]>
        }
      >
    >


  export type ContactInformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    email2?: boolean
    phone?: boolean
    phone2?: boolean
    address?: boolean
    address2?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contactInformation"]>



  export type ContactInformationSelectScalar = {
    id?: boolean
    email?: boolean
    email2?: boolean
    phone?: boolean
    phone2?: boolean
    address?: boolean
    address2?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactInformationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "email2" | "phone" | "phone2" | "address" | "address2" | "createdAt" | "updatedAt", ExtArgs["result"]["contactInformation"]>

  export type $ContactInformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactInformation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      email2: string | null
      phone: string
      phone2: string | null
      address: string
      address2: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contactInformation"]>
    composites: {}
  }

  type ContactInformationGetPayload<S extends boolean | null | undefined | ContactInformationDefaultArgs> = $Result.GetResult<Prisma.$ContactInformationPayload, S>

  type ContactInformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactInformationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactInformationCountAggregateInputType | true
    }

  export interface ContactInformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactInformation'], meta: { name: 'ContactInformation' } }
    /**
     * Find zero or one ContactInformation that matches the filter.
     * @param {ContactInformationFindUniqueArgs} args - Arguments to find a ContactInformation
     * @example
     * // Get one ContactInformation
     * const contactInformation = await prisma.contactInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactInformationFindUniqueArgs>(args: SelectSubset<T, ContactInformationFindUniqueArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactInformation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactInformationFindUniqueOrThrowArgs} args - Arguments to find a ContactInformation
     * @example
     * // Get one ContactInformation
     * const contactInformation = await prisma.contactInformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactInformationFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactInformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationFindFirstArgs} args - Arguments to find a ContactInformation
     * @example
     * // Get one ContactInformation
     * const contactInformation = await prisma.contactInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactInformationFindFirstArgs>(args?: SelectSubset<T, ContactInformationFindFirstArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactInformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationFindFirstOrThrowArgs} args - Arguments to find a ContactInformation
     * @example
     * // Get one ContactInformation
     * const contactInformation = await prisma.contactInformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactInformationFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactInformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactInformations
     * const contactInformations = await prisma.contactInformation.findMany()
     * 
     * // Get first 10 ContactInformations
     * const contactInformations = await prisma.contactInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactInformationWithIdOnly = await prisma.contactInformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactInformationFindManyArgs>(args?: SelectSubset<T, ContactInformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactInformation.
     * @param {ContactInformationCreateArgs} args - Arguments to create a ContactInformation.
     * @example
     * // Create one ContactInformation
     * const ContactInformation = await prisma.contactInformation.create({
     *   data: {
     *     // ... data to create a ContactInformation
     *   }
     * })
     * 
     */
    create<T extends ContactInformationCreateArgs>(args: SelectSubset<T, ContactInformationCreateArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactInformations.
     * @param {ContactInformationCreateManyArgs} args - Arguments to create many ContactInformations.
     * @example
     * // Create many ContactInformations
     * const contactInformation = await prisma.contactInformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactInformationCreateManyArgs>(args?: SelectSubset<T, ContactInformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactInformation.
     * @param {ContactInformationDeleteArgs} args - Arguments to delete one ContactInformation.
     * @example
     * // Delete one ContactInformation
     * const ContactInformation = await prisma.contactInformation.delete({
     *   where: {
     *     // ... filter to delete one ContactInformation
     *   }
     * })
     * 
     */
    delete<T extends ContactInformationDeleteArgs>(args: SelectSubset<T, ContactInformationDeleteArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactInformation.
     * @param {ContactInformationUpdateArgs} args - Arguments to update one ContactInformation.
     * @example
     * // Update one ContactInformation
     * const contactInformation = await prisma.contactInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactInformationUpdateArgs>(args: SelectSubset<T, ContactInformationUpdateArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactInformations.
     * @param {ContactInformationDeleteManyArgs} args - Arguments to filter ContactInformations to delete.
     * @example
     * // Delete a few ContactInformations
     * const { count } = await prisma.contactInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactInformationDeleteManyArgs>(args?: SelectSubset<T, ContactInformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactInformations
     * const contactInformation = await prisma.contactInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactInformationUpdateManyArgs>(args: SelectSubset<T, ContactInformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactInformation.
     * @param {ContactInformationUpsertArgs} args - Arguments to update or create a ContactInformation.
     * @example
     * // Update or create a ContactInformation
     * const contactInformation = await prisma.contactInformation.upsert({
     *   create: {
     *     // ... data to create a ContactInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactInformation we want to update
     *   }
     * })
     */
    upsert<T extends ContactInformationUpsertArgs>(args: SelectSubset<T, ContactInformationUpsertArgs<ExtArgs>>): Prisma__ContactInformationClient<$Result.GetResult<Prisma.$ContactInformationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactInformations that matches the filter.
     * @param {ContactInformationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contactInformation = await prisma.contactInformation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ContactInformationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContactInformation.
     * @param {ContactInformationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contactInformation = await prisma.contactInformation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ContactInformationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ContactInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationCountArgs} args - Arguments to filter ContactInformations to count.
     * @example
     * // Count the number of ContactInformations
     * const count = await prisma.contactInformation.count({
     *   where: {
     *     // ... the filter for the ContactInformations we want to count
     *   }
     * })
    **/
    count<T extends ContactInformationCountArgs>(
      args?: Subset<T, ContactInformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactInformationAggregateArgs>(args: Subset<T, ContactInformationAggregateArgs>): Prisma.PrismaPromise<GetContactInformationAggregateType<T>>

    /**
     * Group by ContactInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactInformationGroupByArgs['orderBy'] }
        : { orderBy?: ContactInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactInformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactInformation model
   */
  readonly fields: ContactInformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactInformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactInformation model
   */
  interface ContactInformationFieldRefs {
    readonly id: FieldRef<"ContactInformation", 'String'>
    readonly email: FieldRef<"ContactInformation", 'String'>
    readonly email2: FieldRef<"ContactInformation", 'String'>
    readonly phone: FieldRef<"ContactInformation", 'String'>
    readonly phone2: FieldRef<"ContactInformation", 'String'>
    readonly address: FieldRef<"ContactInformation", 'String'>
    readonly address2: FieldRef<"ContactInformation", 'String'>
    readonly createdAt: FieldRef<"ContactInformation", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactInformation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactInformation findUnique
   */
  export type ContactInformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * Filter, which ContactInformation to fetch.
     */
    where: ContactInformationWhereUniqueInput
  }

  /**
   * ContactInformation findUniqueOrThrow
   */
  export type ContactInformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * Filter, which ContactInformation to fetch.
     */
    where: ContactInformationWhereUniqueInput
  }

  /**
   * ContactInformation findFirst
   */
  export type ContactInformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * Filter, which ContactInformation to fetch.
     */
    where?: ContactInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInformations to fetch.
     */
    orderBy?: ContactInformationOrderByWithRelationInput | ContactInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInformations.
     */
    cursor?: ContactInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInformations.
     */
    distinct?: ContactInformationScalarFieldEnum | ContactInformationScalarFieldEnum[]
  }

  /**
   * ContactInformation findFirstOrThrow
   */
  export type ContactInformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * Filter, which ContactInformation to fetch.
     */
    where?: ContactInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInformations to fetch.
     */
    orderBy?: ContactInformationOrderByWithRelationInput | ContactInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactInformations.
     */
    cursor?: ContactInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactInformations.
     */
    distinct?: ContactInformationScalarFieldEnum | ContactInformationScalarFieldEnum[]
  }

  /**
   * ContactInformation findMany
   */
  export type ContactInformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * Filter, which ContactInformations to fetch.
     */
    where?: ContactInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactInformations to fetch.
     */
    orderBy?: ContactInformationOrderByWithRelationInput | ContactInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactInformations.
     */
    cursor?: ContactInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactInformations.
     */
    skip?: number
    distinct?: ContactInformationScalarFieldEnum | ContactInformationScalarFieldEnum[]
  }

  /**
   * ContactInformation create
   */
  export type ContactInformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactInformation.
     */
    data: XOR<ContactInformationCreateInput, ContactInformationUncheckedCreateInput>
  }

  /**
   * ContactInformation createMany
   */
  export type ContactInformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactInformations.
     */
    data: ContactInformationCreateManyInput | ContactInformationCreateManyInput[]
  }

  /**
   * ContactInformation update
   */
  export type ContactInformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactInformation.
     */
    data: XOR<ContactInformationUpdateInput, ContactInformationUncheckedUpdateInput>
    /**
     * Choose, which ContactInformation to update.
     */
    where: ContactInformationWhereUniqueInput
  }

  /**
   * ContactInformation updateMany
   */
  export type ContactInformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactInformations.
     */
    data: XOR<ContactInformationUpdateManyMutationInput, ContactInformationUncheckedUpdateManyInput>
    /**
     * Filter which ContactInformations to update
     */
    where?: ContactInformationWhereInput
    /**
     * Limit how many ContactInformations to update.
     */
    limit?: number
  }

  /**
   * ContactInformation upsert
   */
  export type ContactInformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactInformation to update in case it exists.
     */
    where: ContactInformationWhereUniqueInput
    /**
     * In case the ContactInformation found by the `where` argument doesn't exist, create a new ContactInformation with this data.
     */
    create: XOR<ContactInformationCreateInput, ContactInformationUncheckedCreateInput>
    /**
     * In case the ContactInformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactInformationUpdateInput, ContactInformationUncheckedUpdateInput>
  }

  /**
   * ContactInformation delete
   */
  export type ContactInformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
    /**
     * Filter which ContactInformation to delete.
     */
    where: ContactInformationWhereUniqueInput
  }

  /**
   * ContactInformation deleteMany
   */
  export type ContactInformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactInformations to delete
     */
    where?: ContactInformationWhereInput
    /**
     * Limit how many ContactInformations to delete.
     */
    limit?: number
  }

  /**
   * ContactInformation findRaw
   */
  export type ContactInformationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactInformation aggregateRaw
   */
  export type ContactInformationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ContactInformation without action
   */
  export type ContactInformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactInformation
     */
    select?: ContactInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactInformation
     */
    omit?: ContactInformationOmit<ExtArgs> | null
  }


  /**
   * Model SocialNetwork
   */

  export type AggregateSocialNetwork = {
    _count: SocialNetworkCountAggregateOutputType | null
    _min: SocialNetworkMinAggregateOutputType | null
    _max: SocialNetworkMaxAggregateOutputType | null
  }

  export type SocialNetworkMinAggregateOutputType = {
    id: string | null
    facebookLink: string | null
    twitterLink: string | null
    linkedinLink: string | null
    instagramLink: string | null
    youtubeLink: string | null
    dribbleLink: string | null
    whatsappNumber: string | null
    telegramLink: string | null
    snapchatLink: string | null
    tiktokLink: string | null
    threadsLink: string | null
    pinterestLink: string | null
    redditLink: string | null
    githubLink: string | null
    websiteLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialNetworkMaxAggregateOutputType = {
    id: string | null
    facebookLink: string | null
    twitterLink: string | null
    linkedinLink: string | null
    instagramLink: string | null
    youtubeLink: string | null
    dribbleLink: string | null
    whatsappNumber: string | null
    telegramLink: string | null
    snapchatLink: string | null
    tiktokLink: string | null
    threadsLink: string | null
    pinterestLink: string | null
    redditLink: string | null
    githubLink: string | null
    websiteLink: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialNetworkCountAggregateOutputType = {
    id: number
    facebookLink: number
    twitterLink: number
    linkedinLink: number
    instagramLink: number
    youtubeLink: number
    dribbleLink: number
    whatsappNumber: number
    telegramLink: number
    snapchatLink: number
    tiktokLink: number
    threadsLink: number
    pinterestLink: number
    redditLink: number
    githubLink: number
    websiteLink: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialNetworkMinAggregateInputType = {
    id?: true
    facebookLink?: true
    twitterLink?: true
    linkedinLink?: true
    instagramLink?: true
    youtubeLink?: true
    dribbleLink?: true
    whatsappNumber?: true
    telegramLink?: true
    snapchatLink?: true
    tiktokLink?: true
    threadsLink?: true
    pinterestLink?: true
    redditLink?: true
    githubLink?: true
    websiteLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialNetworkMaxAggregateInputType = {
    id?: true
    facebookLink?: true
    twitterLink?: true
    linkedinLink?: true
    instagramLink?: true
    youtubeLink?: true
    dribbleLink?: true
    whatsappNumber?: true
    telegramLink?: true
    snapchatLink?: true
    tiktokLink?: true
    threadsLink?: true
    pinterestLink?: true
    redditLink?: true
    githubLink?: true
    websiteLink?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialNetworkCountAggregateInputType = {
    id?: true
    facebookLink?: true
    twitterLink?: true
    linkedinLink?: true
    instagramLink?: true
    youtubeLink?: true
    dribbleLink?: true
    whatsappNumber?: true
    telegramLink?: true
    snapchatLink?: true
    tiktokLink?: true
    threadsLink?: true
    pinterestLink?: true
    redditLink?: true
    githubLink?: true
    websiteLink?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialNetworkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialNetwork to aggregate.
     */
    where?: SocialNetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialNetworks to fetch.
     */
    orderBy?: SocialNetworkOrderByWithRelationInput | SocialNetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialNetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialNetworks
    **/
    _count?: true | SocialNetworkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialNetworkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialNetworkMaxAggregateInputType
  }

  export type GetSocialNetworkAggregateType<T extends SocialNetworkAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialNetwork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialNetwork[P]>
      : GetScalarType<T[P], AggregateSocialNetwork[P]>
  }




  export type SocialNetworkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialNetworkWhereInput
    orderBy?: SocialNetworkOrderByWithAggregationInput | SocialNetworkOrderByWithAggregationInput[]
    by: SocialNetworkScalarFieldEnum[] | SocialNetworkScalarFieldEnum
    having?: SocialNetworkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialNetworkCountAggregateInputType | true
    _min?: SocialNetworkMinAggregateInputType
    _max?: SocialNetworkMaxAggregateInputType
  }

  export type SocialNetworkGroupByOutputType = {
    id: string
    facebookLink: string | null
    twitterLink: string | null
    linkedinLink: string | null
    instagramLink: string | null
    youtubeLink: string | null
    dribbleLink: string | null
    whatsappNumber: string | null
    telegramLink: string | null
    snapchatLink: string | null
    tiktokLink: string | null
    threadsLink: string | null
    pinterestLink: string | null
    redditLink: string | null
    githubLink: string | null
    websiteLink: string | null
    createdAt: Date
    updatedAt: Date
    _count: SocialNetworkCountAggregateOutputType | null
    _min: SocialNetworkMinAggregateOutputType | null
    _max: SocialNetworkMaxAggregateOutputType | null
  }

  type GetSocialNetworkGroupByPayload<T extends SocialNetworkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialNetworkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialNetworkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialNetworkGroupByOutputType[P]>
            : GetScalarType<T[P], SocialNetworkGroupByOutputType[P]>
        }
      >
    >


  export type SocialNetworkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    facebookLink?: boolean
    twitterLink?: boolean
    linkedinLink?: boolean
    instagramLink?: boolean
    youtubeLink?: boolean
    dribbleLink?: boolean
    whatsappNumber?: boolean
    telegramLink?: boolean
    snapchatLink?: boolean
    tiktokLink?: boolean
    threadsLink?: boolean
    pinterestLink?: boolean
    redditLink?: boolean
    githubLink?: boolean
    websiteLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["socialNetwork"]>



  export type SocialNetworkSelectScalar = {
    id?: boolean
    facebookLink?: boolean
    twitterLink?: boolean
    linkedinLink?: boolean
    instagramLink?: boolean
    youtubeLink?: boolean
    dribbleLink?: boolean
    whatsappNumber?: boolean
    telegramLink?: boolean
    snapchatLink?: boolean
    tiktokLink?: boolean
    threadsLink?: boolean
    pinterestLink?: boolean
    redditLink?: boolean
    githubLink?: boolean
    websiteLink?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialNetworkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "facebookLink" | "twitterLink" | "linkedinLink" | "instagramLink" | "youtubeLink" | "dribbleLink" | "whatsappNumber" | "telegramLink" | "snapchatLink" | "tiktokLink" | "threadsLink" | "pinterestLink" | "redditLink" | "githubLink" | "websiteLink" | "createdAt" | "updatedAt", ExtArgs["result"]["socialNetwork"]>

  export type $SocialNetworkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialNetwork"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      facebookLink: string | null
      twitterLink: string | null
      linkedinLink: string | null
      instagramLink: string | null
      youtubeLink: string | null
      dribbleLink: string | null
      whatsappNumber: string | null
      telegramLink: string | null
      snapchatLink: string | null
      tiktokLink: string | null
      threadsLink: string | null
      pinterestLink: string | null
      redditLink: string | null
      githubLink: string | null
      websiteLink: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialNetwork"]>
    composites: {}
  }

  type SocialNetworkGetPayload<S extends boolean | null | undefined | SocialNetworkDefaultArgs> = $Result.GetResult<Prisma.$SocialNetworkPayload, S>

  type SocialNetworkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialNetworkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialNetworkCountAggregateInputType | true
    }

  export interface SocialNetworkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialNetwork'], meta: { name: 'SocialNetwork' } }
    /**
     * Find zero or one SocialNetwork that matches the filter.
     * @param {SocialNetworkFindUniqueArgs} args - Arguments to find a SocialNetwork
     * @example
     * // Get one SocialNetwork
     * const socialNetwork = await prisma.socialNetwork.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialNetworkFindUniqueArgs>(args: SelectSubset<T, SocialNetworkFindUniqueArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialNetwork that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialNetworkFindUniqueOrThrowArgs} args - Arguments to find a SocialNetwork
     * @example
     * // Get one SocialNetwork
     * const socialNetwork = await prisma.socialNetwork.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialNetworkFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialNetworkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialNetwork that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkFindFirstArgs} args - Arguments to find a SocialNetwork
     * @example
     * // Get one SocialNetwork
     * const socialNetwork = await prisma.socialNetwork.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialNetworkFindFirstArgs>(args?: SelectSubset<T, SocialNetworkFindFirstArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialNetwork that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkFindFirstOrThrowArgs} args - Arguments to find a SocialNetwork
     * @example
     * // Get one SocialNetwork
     * const socialNetwork = await prisma.socialNetwork.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialNetworkFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialNetworkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialNetworks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialNetworks
     * const socialNetworks = await prisma.socialNetwork.findMany()
     * 
     * // Get first 10 SocialNetworks
     * const socialNetworks = await prisma.socialNetwork.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialNetworkWithIdOnly = await prisma.socialNetwork.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialNetworkFindManyArgs>(args?: SelectSubset<T, SocialNetworkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialNetwork.
     * @param {SocialNetworkCreateArgs} args - Arguments to create a SocialNetwork.
     * @example
     * // Create one SocialNetwork
     * const SocialNetwork = await prisma.socialNetwork.create({
     *   data: {
     *     // ... data to create a SocialNetwork
     *   }
     * })
     * 
     */
    create<T extends SocialNetworkCreateArgs>(args: SelectSubset<T, SocialNetworkCreateArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialNetworks.
     * @param {SocialNetworkCreateManyArgs} args - Arguments to create many SocialNetworks.
     * @example
     * // Create many SocialNetworks
     * const socialNetwork = await prisma.socialNetwork.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialNetworkCreateManyArgs>(args?: SelectSubset<T, SocialNetworkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialNetwork.
     * @param {SocialNetworkDeleteArgs} args - Arguments to delete one SocialNetwork.
     * @example
     * // Delete one SocialNetwork
     * const SocialNetwork = await prisma.socialNetwork.delete({
     *   where: {
     *     // ... filter to delete one SocialNetwork
     *   }
     * })
     * 
     */
    delete<T extends SocialNetworkDeleteArgs>(args: SelectSubset<T, SocialNetworkDeleteArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialNetwork.
     * @param {SocialNetworkUpdateArgs} args - Arguments to update one SocialNetwork.
     * @example
     * // Update one SocialNetwork
     * const socialNetwork = await prisma.socialNetwork.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialNetworkUpdateArgs>(args: SelectSubset<T, SocialNetworkUpdateArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialNetworks.
     * @param {SocialNetworkDeleteManyArgs} args - Arguments to filter SocialNetworks to delete.
     * @example
     * // Delete a few SocialNetworks
     * const { count } = await prisma.socialNetwork.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialNetworkDeleteManyArgs>(args?: SelectSubset<T, SocialNetworkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialNetworks
     * const socialNetwork = await prisma.socialNetwork.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialNetworkUpdateManyArgs>(args: SelectSubset<T, SocialNetworkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialNetwork.
     * @param {SocialNetworkUpsertArgs} args - Arguments to update or create a SocialNetwork.
     * @example
     * // Update or create a SocialNetwork
     * const socialNetwork = await prisma.socialNetwork.upsert({
     *   create: {
     *     // ... data to create a SocialNetwork
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialNetwork we want to update
     *   }
     * })
     */
    upsert<T extends SocialNetworkUpsertArgs>(args: SelectSubset<T, SocialNetworkUpsertArgs<ExtArgs>>): Prisma__SocialNetworkClient<$Result.GetResult<Prisma.$SocialNetworkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialNetworks that matches the filter.
     * @param {SocialNetworkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const socialNetwork = await prisma.socialNetwork.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SocialNetworkFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SocialNetwork.
     * @param {SocialNetworkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const socialNetwork = await prisma.socialNetwork.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SocialNetworkAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SocialNetworks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkCountArgs} args - Arguments to filter SocialNetworks to count.
     * @example
     * // Count the number of SocialNetworks
     * const count = await prisma.socialNetwork.count({
     *   where: {
     *     // ... the filter for the SocialNetworks we want to count
     *   }
     * })
    **/
    count<T extends SocialNetworkCountArgs>(
      args?: Subset<T, SocialNetworkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialNetworkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialNetwork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialNetworkAggregateArgs>(args: Subset<T, SocialNetworkAggregateArgs>): Prisma.PrismaPromise<GetSocialNetworkAggregateType<T>>

    /**
     * Group by SocialNetwork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialNetworkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialNetworkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialNetworkGroupByArgs['orderBy'] }
        : { orderBy?: SocialNetworkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialNetworkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialNetworkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialNetwork model
   */
  readonly fields: SocialNetworkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialNetwork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialNetworkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialNetwork model
   */
  interface SocialNetworkFieldRefs {
    readonly id: FieldRef<"SocialNetwork", 'String'>
    readonly facebookLink: FieldRef<"SocialNetwork", 'String'>
    readonly twitterLink: FieldRef<"SocialNetwork", 'String'>
    readonly linkedinLink: FieldRef<"SocialNetwork", 'String'>
    readonly instagramLink: FieldRef<"SocialNetwork", 'String'>
    readonly youtubeLink: FieldRef<"SocialNetwork", 'String'>
    readonly dribbleLink: FieldRef<"SocialNetwork", 'String'>
    readonly whatsappNumber: FieldRef<"SocialNetwork", 'String'>
    readonly telegramLink: FieldRef<"SocialNetwork", 'String'>
    readonly snapchatLink: FieldRef<"SocialNetwork", 'String'>
    readonly tiktokLink: FieldRef<"SocialNetwork", 'String'>
    readonly threadsLink: FieldRef<"SocialNetwork", 'String'>
    readonly pinterestLink: FieldRef<"SocialNetwork", 'String'>
    readonly redditLink: FieldRef<"SocialNetwork", 'String'>
    readonly githubLink: FieldRef<"SocialNetwork", 'String'>
    readonly websiteLink: FieldRef<"SocialNetwork", 'String'>
    readonly createdAt: FieldRef<"SocialNetwork", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialNetwork", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialNetwork findUnique
   */
  export type SocialNetworkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * Filter, which SocialNetwork to fetch.
     */
    where: SocialNetworkWhereUniqueInput
  }

  /**
   * SocialNetwork findUniqueOrThrow
   */
  export type SocialNetworkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * Filter, which SocialNetwork to fetch.
     */
    where: SocialNetworkWhereUniqueInput
  }

  /**
   * SocialNetwork findFirst
   */
  export type SocialNetworkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * Filter, which SocialNetwork to fetch.
     */
    where?: SocialNetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialNetworks to fetch.
     */
    orderBy?: SocialNetworkOrderByWithRelationInput | SocialNetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialNetworks.
     */
    cursor?: SocialNetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialNetworks.
     */
    distinct?: SocialNetworkScalarFieldEnum | SocialNetworkScalarFieldEnum[]
  }

  /**
   * SocialNetwork findFirstOrThrow
   */
  export type SocialNetworkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * Filter, which SocialNetwork to fetch.
     */
    where?: SocialNetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialNetworks to fetch.
     */
    orderBy?: SocialNetworkOrderByWithRelationInput | SocialNetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialNetworks.
     */
    cursor?: SocialNetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialNetworks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialNetworks.
     */
    distinct?: SocialNetworkScalarFieldEnum | SocialNetworkScalarFieldEnum[]
  }

  /**
   * SocialNetwork findMany
   */
  export type SocialNetworkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * Filter, which SocialNetworks to fetch.
     */
    where?: SocialNetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialNetworks to fetch.
     */
    orderBy?: SocialNetworkOrderByWithRelationInput | SocialNetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialNetworks.
     */
    cursor?: SocialNetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialNetworks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialNetworks.
     */
    skip?: number
    distinct?: SocialNetworkScalarFieldEnum | SocialNetworkScalarFieldEnum[]
  }

  /**
   * SocialNetwork create
   */
  export type SocialNetworkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * The data needed to create a SocialNetwork.
     */
    data: XOR<SocialNetworkCreateInput, SocialNetworkUncheckedCreateInput>
  }

  /**
   * SocialNetwork createMany
   */
  export type SocialNetworkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialNetworks.
     */
    data: SocialNetworkCreateManyInput | SocialNetworkCreateManyInput[]
  }

  /**
   * SocialNetwork update
   */
  export type SocialNetworkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * The data needed to update a SocialNetwork.
     */
    data: XOR<SocialNetworkUpdateInput, SocialNetworkUncheckedUpdateInput>
    /**
     * Choose, which SocialNetwork to update.
     */
    where: SocialNetworkWhereUniqueInput
  }

  /**
   * SocialNetwork updateMany
   */
  export type SocialNetworkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialNetworks.
     */
    data: XOR<SocialNetworkUpdateManyMutationInput, SocialNetworkUncheckedUpdateManyInput>
    /**
     * Filter which SocialNetworks to update
     */
    where?: SocialNetworkWhereInput
    /**
     * Limit how many SocialNetworks to update.
     */
    limit?: number
  }

  /**
   * SocialNetwork upsert
   */
  export type SocialNetworkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * The filter to search for the SocialNetwork to update in case it exists.
     */
    where: SocialNetworkWhereUniqueInput
    /**
     * In case the SocialNetwork found by the `where` argument doesn't exist, create a new SocialNetwork with this data.
     */
    create: XOR<SocialNetworkCreateInput, SocialNetworkUncheckedCreateInput>
    /**
     * In case the SocialNetwork was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialNetworkUpdateInput, SocialNetworkUncheckedUpdateInput>
  }

  /**
   * SocialNetwork delete
   */
  export type SocialNetworkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
    /**
     * Filter which SocialNetwork to delete.
     */
    where: SocialNetworkWhereUniqueInput
  }

  /**
   * SocialNetwork deleteMany
   */
  export type SocialNetworkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialNetworks to delete
     */
    where?: SocialNetworkWhereInput
    /**
     * Limit how many SocialNetworks to delete.
     */
    limit?: number
  }

  /**
   * SocialNetwork findRaw
   */
  export type SocialNetworkFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SocialNetwork aggregateRaw
   */
  export type SocialNetworkAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SocialNetwork without action
   */
  export type SocialNetworkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialNetwork
     */
    select?: SocialNetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialNetwork
     */
    omit?: SocialNetworkOmit<ExtArgs> | null
  }


  /**
   * Model SiteConfiguration
   */

  export type AggregateSiteConfiguration = {
    _count: SiteConfigurationCountAggregateOutputType | null
    _min: SiteConfigurationMinAggregateOutputType | null
    _max: SiteConfigurationMaxAggregateOutputType | null
  }

  export type SiteConfigurationMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    copyRights: string | null
    logo: string | null
    logoPublicId: string | null
    favicon: string | null
    faviconPublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteConfigurationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortDescription: string | null
    longDescription: string | null
    copyRights: string | null
    logo: string | null
    logoPublicId: string | null
    favicon: string | null
    faviconPublicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteConfigurationCountAggregateOutputType = {
    id: number
    name: number
    shortDescription: number
    longDescription: number
    copyRights: number
    logo: number
    logoPublicId: number
    favicon: number
    faviconPublicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteConfigurationMinAggregateInputType = {
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    copyRights?: true
    logo?: true
    logoPublicId?: true
    favicon?: true
    faviconPublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteConfigurationMaxAggregateInputType = {
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    copyRights?: true
    logo?: true
    logoPublicId?: true
    favicon?: true
    faviconPublicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteConfigurationCountAggregateInputType = {
    id?: true
    name?: true
    shortDescription?: true
    longDescription?: true
    copyRights?: true
    logo?: true
    logoPublicId?: true
    favicon?: true
    faviconPublicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteConfigurationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfiguration to aggregate.
     */
    where?: SiteConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigurations to fetch.
     */
    orderBy?: SiteConfigurationOrderByWithRelationInput | SiteConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteConfigurations
    **/
    _count?: true | SiteConfigurationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteConfigurationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteConfigurationMaxAggregateInputType
  }

  export type GetSiteConfigurationAggregateType<T extends SiteConfigurationAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteConfiguration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteConfiguration[P]>
      : GetScalarType<T[P], AggregateSiteConfiguration[P]>
  }




  export type SiteConfigurationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteConfigurationWhereInput
    orderBy?: SiteConfigurationOrderByWithAggregationInput | SiteConfigurationOrderByWithAggregationInput[]
    by: SiteConfigurationScalarFieldEnum[] | SiteConfigurationScalarFieldEnum
    having?: SiteConfigurationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteConfigurationCountAggregateInputType | true
    _min?: SiteConfigurationMinAggregateInputType
    _max?: SiteConfigurationMaxAggregateInputType
  }

  export type SiteConfigurationGroupByOutputType = {
    id: string
    name: string
    shortDescription: string
    longDescription: string | null
    copyRights: string
    logo: string
    logoPublicId: string | null
    favicon: string
    faviconPublicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SiteConfigurationCountAggregateOutputType | null
    _min: SiteConfigurationMinAggregateOutputType | null
    _max: SiteConfigurationMaxAggregateOutputType | null
  }

  type GetSiteConfigurationGroupByPayload<T extends SiteConfigurationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteConfigurationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteConfigurationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteConfigurationGroupByOutputType[P]>
            : GetScalarType<T[P], SiteConfigurationGroupByOutputType[P]>
        }
      >
    >


  export type SiteConfigurationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    copyRights?: boolean
    logo?: boolean
    logoPublicId?: boolean
    favicon?: boolean
    faviconPublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteConfiguration"]>



  export type SiteConfigurationSelectScalar = {
    id?: boolean
    name?: boolean
    shortDescription?: boolean
    longDescription?: boolean
    copyRights?: boolean
    logo?: boolean
    logoPublicId?: boolean
    favicon?: boolean
    faviconPublicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteConfigurationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "shortDescription" | "longDescription" | "copyRights" | "logo" | "logoPublicId" | "favicon" | "faviconPublicId" | "createdAt" | "updatedAt", ExtArgs["result"]["siteConfiguration"]>

  export type $SiteConfigurationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteConfiguration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shortDescription: string
      longDescription: string | null
      copyRights: string
      logo: string
      logoPublicId: string | null
      favicon: string
      faviconPublicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteConfiguration"]>
    composites: {}
  }

  type SiteConfigurationGetPayload<S extends boolean | null | undefined | SiteConfigurationDefaultArgs> = $Result.GetResult<Prisma.$SiteConfigurationPayload, S>

  type SiteConfigurationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteConfigurationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteConfigurationCountAggregateInputType | true
    }

  export interface SiteConfigurationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteConfiguration'], meta: { name: 'SiteConfiguration' } }
    /**
     * Find zero or one SiteConfiguration that matches the filter.
     * @param {SiteConfigurationFindUniqueArgs} args - Arguments to find a SiteConfiguration
     * @example
     * // Get one SiteConfiguration
     * const siteConfiguration = await prisma.siteConfiguration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteConfigurationFindUniqueArgs>(args: SelectSubset<T, SiteConfigurationFindUniqueArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteConfiguration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteConfigurationFindUniqueOrThrowArgs} args - Arguments to find a SiteConfiguration
     * @example
     * // Get one SiteConfiguration
     * const siteConfiguration = await prisma.siteConfiguration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteConfigurationFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteConfigurationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfiguration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationFindFirstArgs} args - Arguments to find a SiteConfiguration
     * @example
     * // Get one SiteConfiguration
     * const siteConfiguration = await prisma.siteConfiguration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteConfigurationFindFirstArgs>(args?: SelectSubset<T, SiteConfigurationFindFirstArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteConfiguration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationFindFirstOrThrowArgs} args - Arguments to find a SiteConfiguration
     * @example
     * // Get one SiteConfiguration
     * const siteConfiguration = await prisma.siteConfiguration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteConfigurationFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteConfigurationFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteConfigurations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteConfigurations
     * const siteConfigurations = await prisma.siteConfiguration.findMany()
     * 
     * // Get first 10 SiteConfigurations
     * const siteConfigurations = await prisma.siteConfiguration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteConfigurationWithIdOnly = await prisma.siteConfiguration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteConfigurationFindManyArgs>(args?: SelectSubset<T, SiteConfigurationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteConfiguration.
     * @param {SiteConfigurationCreateArgs} args - Arguments to create a SiteConfiguration.
     * @example
     * // Create one SiteConfiguration
     * const SiteConfiguration = await prisma.siteConfiguration.create({
     *   data: {
     *     // ... data to create a SiteConfiguration
     *   }
     * })
     * 
     */
    create<T extends SiteConfigurationCreateArgs>(args: SelectSubset<T, SiteConfigurationCreateArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteConfigurations.
     * @param {SiteConfigurationCreateManyArgs} args - Arguments to create many SiteConfigurations.
     * @example
     * // Create many SiteConfigurations
     * const siteConfiguration = await prisma.siteConfiguration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteConfigurationCreateManyArgs>(args?: SelectSubset<T, SiteConfigurationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SiteConfiguration.
     * @param {SiteConfigurationDeleteArgs} args - Arguments to delete one SiteConfiguration.
     * @example
     * // Delete one SiteConfiguration
     * const SiteConfiguration = await prisma.siteConfiguration.delete({
     *   where: {
     *     // ... filter to delete one SiteConfiguration
     *   }
     * })
     * 
     */
    delete<T extends SiteConfigurationDeleteArgs>(args: SelectSubset<T, SiteConfigurationDeleteArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteConfiguration.
     * @param {SiteConfigurationUpdateArgs} args - Arguments to update one SiteConfiguration.
     * @example
     * // Update one SiteConfiguration
     * const siteConfiguration = await prisma.siteConfiguration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteConfigurationUpdateArgs>(args: SelectSubset<T, SiteConfigurationUpdateArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteConfigurations.
     * @param {SiteConfigurationDeleteManyArgs} args - Arguments to filter SiteConfigurations to delete.
     * @example
     * // Delete a few SiteConfigurations
     * const { count } = await prisma.siteConfiguration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteConfigurationDeleteManyArgs>(args?: SelectSubset<T, SiteConfigurationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteConfigurations
     * const siteConfiguration = await prisma.siteConfiguration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteConfigurationUpdateManyArgs>(args: SelectSubset<T, SiteConfigurationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SiteConfiguration.
     * @param {SiteConfigurationUpsertArgs} args - Arguments to update or create a SiteConfiguration.
     * @example
     * // Update or create a SiteConfiguration
     * const siteConfiguration = await prisma.siteConfiguration.upsert({
     *   create: {
     *     // ... data to create a SiteConfiguration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteConfiguration we want to update
     *   }
     * })
     */
    upsert<T extends SiteConfigurationUpsertArgs>(args: SelectSubset<T, SiteConfigurationUpsertArgs<ExtArgs>>): Prisma__SiteConfigurationClient<$Result.GetResult<Prisma.$SiteConfigurationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteConfigurations that matches the filter.
     * @param {SiteConfigurationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const siteConfiguration = await prisma.siteConfiguration.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SiteConfigurationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SiteConfiguration.
     * @param {SiteConfigurationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const siteConfiguration = await prisma.siteConfiguration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SiteConfigurationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SiteConfigurations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationCountArgs} args - Arguments to filter SiteConfigurations to count.
     * @example
     * // Count the number of SiteConfigurations
     * const count = await prisma.siteConfiguration.count({
     *   where: {
     *     // ... the filter for the SiteConfigurations we want to count
     *   }
     * })
    **/
    count<T extends SiteConfigurationCountArgs>(
      args?: Subset<T, SiteConfigurationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteConfigurationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteConfigurationAggregateArgs>(args: Subset<T, SiteConfigurationAggregateArgs>): Prisma.PrismaPromise<GetSiteConfigurationAggregateType<T>>

    /**
     * Group by SiteConfiguration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteConfigurationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteConfigurationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteConfigurationGroupByArgs['orderBy'] }
        : { orderBy?: SiteConfigurationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteConfigurationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteConfigurationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteConfiguration model
   */
  readonly fields: SiteConfigurationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteConfiguration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteConfigurationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteConfiguration model
   */
  interface SiteConfigurationFieldRefs {
    readonly id: FieldRef<"SiteConfiguration", 'String'>
    readonly name: FieldRef<"SiteConfiguration", 'String'>
    readonly shortDescription: FieldRef<"SiteConfiguration", 'String'>
    readonly longDescription: FieldRef<"SiteConfiguration", 'String'>
    readonly copyRights: FieldRef<"SiteConfiguration", 'String'>
    readonly logo: FieldRef<"SiteConfiguration", 'String'>
    readonly logoPublicId: FieldRef<"SiteConfiguration", 'String'>
    readonly favicon: FieldRef<"SiteConfiguration", 'String'>
    readonly faviconPublicId: FieldRef<"SiteConfiguration", 'String'>
    readonly createdAt: FieldRef<"SiteConfiguration", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteConfiguration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteConfiguration findUnique
   */
  export type SiteConfigurationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SiteConfiguration to fetch.
     */
    where: SiteConfigurationWhereUniqueInput
  }

  /**
   * SiteConfiguration findUniqueOrThrow
   */
  export type SiteConfigurationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SiteConfiguration to fetch.
     */
    where: SiteConfigurationWhereUniqueInput
  }

  /**
   * SiteConfiguration findFirst
   */
  export type SiteConfigurationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SiteConfiguration to fetch.
     */
    where?: SiteConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigurations to fetch.
     */
    orderBy?: SiteConfigurationOrderByWithRelationInput | SiteConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigurations.
     */
    cursor?: SiteConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigurations.
     */
    distinct?: SiteConfigurationScalarFieldEnum | SiteConfigurationScalarFieldEnum[]
  }

  /**
   * SiteConfiguration findFirstOrThrow
   */
  export type SiteConfigurationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SiteConfiguration to fetch.
     */
    where?: SiteConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigurations to fetch.
     */
    orderBy?: SiteConfigurationOrderByWithRelationInput | SiteConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteConfigurations.
     */
    cursor?: SiteConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigurations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteConfigurations.
     */
    distinct?: SiteConfigurationScalarFieldEnum | SiteConfigurationScalarFieldEnum[]
  }

  /**
   * SiteConfiguration findMany
   */
  export type SiteConfigurationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * Filter, which SiteConfigurations to fetch.
     */
    where?: SiteConfigurationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteConfigurations to fetch.
     */
    orderBy?: SiteConfigurationOrderByWithRelationInput | SiteConfigurationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteConfigurations.
     */
    cursor?: SiteConfigurationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteConfigurations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteConfigurations.
     */
    skip?: number
    distinct?: SiteConfigurationScalarFieldEnum | SiteConfigurationScalarFieldEnum[]
  }

  /**
   * SiteConfiguration create
   */
  export type SiteConfigurationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to create a SiteConfiguration.
     */
    data: XOR<SiteConfigurationCreateInput, SiteConfigurationUncheckedCreateInput>
  }

  /**
   * SiteConfiguration createMany
   */
  export type SiteConfigurationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteConfigurations.
     */
    data: SiteConfigurationCreateManyInput | SiteConfigurationCreateManyInput[]
  }

  /**
   * SiteConfiguration update
   */
  export type SiteConfigurationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * The data needed to update a SiteConfiguration.
     */
    data: XOR<SiteConfigurationUpdateInput, SiteConfigurationUncheckedUpdateInput>
    /**
     * Choose, which SiteConfiguration to update.
     */
    where: SiteConfigurationWhereUniqueInput
  }

  /**
   * SiteConfiguration updateMany
   */
  export type SiteConfigurationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteConfigurations.
     */
    data: XOR<SiteConfigurationUpdateManyMutationInput, SiteConfigurationUncheckedUpdateManyInput>
    /**
     * Filter which SiteConfigurations to update
     */
    where?: SiteConfigurationWhereInput
    /**
     * Limit how many SiteConfigurations to update.
     */
    limit?: number
  }

  /**
   * SiteConfiguration upsert
   */
  export type SiteConfigurationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * The filter to search for the SiteConfiguration to update in case it exists.
     */
    where: SiteConfigurationWhereUniqueInput
    /**
     * In case the SiteConfiguration found by the `where` argument doesn't exist, create a new SiteConfiguration with this data.
     */
    create: XOR<SiteConfigurationCreateInput, SiteConfigurationUncheckedCreateInput>
    /**
     * In case the SiteConfiguration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteConfigurationUpdateInput, SiteConfigurationUncheckedUpdateInput>
  }

  /**
   * SiteConfiguration delete
   */
  export type SiteConfigurationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
    /**
     * Filter which SiteConfiguration to delete.
     */
    where: SiteConfigurationWhereUniqueInput
  }

  /**
   * SiteConfiguration deleteMany
   */
  export type SiteConfigurationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteConfigurations to delete
     */
    where?: SiteConfigurationWhereInput
    /**
     * Limit how many SiteConfigurations to delete.
     */
    limit?: number
  }

  /**
   * SiteConfiguration findRaw
   */
  export type SiteConfigurationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SiteConfiguration aggregateRaw
   */
  export type SiteConfigurationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SiteConfiguration without action
   */
  export type SiteConfigurationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteConfiguration
     */
    select?: SiteConfigurationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteConfiguration
     */
    omit?: SiteConfigurationOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    read: 'read',
    link: 'link',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const RolePackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    roleName: 'roleName',
    price: 'price',
    durationDays: 'durationDays',
    features: 'features',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RolePackageScalarFieldEnum = (typeof RolePackageScalarFieldEnum)[keyof typeof RolePackageScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    avatar: 'avatar',
    avatarPublicId: 'avatarPublicId',
    phone: 'phone',
    bio: 'bio',
    address: 'address',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    previousRole: 'previousRole',
    role: 'role',
    isAdmin: 'isAdmin',
    status: 'status',
    resetCode: 'resetCode',
    resetCodeExpiration: 'resetCodeExpiration',
    flagged: 'flagged',
    flagReason: 'flagReason',
    isNotificationEnabled: 'isNotificationEnabled',
    isTwoFactorEnabled: 'isTwoFactorEnabled',
    twoFactorTempToken: 'twoFactorTempToken',
    twoFactorTempExp: 'twoFactorTempExp',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reputationScore: 'reputationScore',
    reputationHistory: 'reputationHistory'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rolePackageId: 'rolePackageId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    isPaused: 'isPaused',
    isExpired: 'isExpired',
    message: 'message',
    isVerified: 'isVerified',
    verifiedAt: 'verifiedAt',
    verifiedBy: 'verifiedBy',
    createdAt: 'createdAt'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userRoleId: 'userRoleId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    method: 'method',
    stripeId: 'stripeId',
    invoiceUrl: 'invoiceUrl',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    isActive: 'isActive',
    lastUsedAt: 'lastUsedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    reviewerId: 'reviewerId',
    targetUserId: 'targetUserId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const HeroBannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    imagePublicId: 'imagePublicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HeroBannerScalarFieldEnum = (typeof HeroBannerScalarFieldEnum)[keyof typeof HeroBannerScalarFieldEnum]


  export const MarketTrendsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    day: 'day',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketTrendsScalarFieldEnum = (typeof MarketTrendsScalarFieldEnum)[keyof typeof MarketTrendsScalarFieldEnum]


  export const MortageToolsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ctaName: 'ctaName',
    ctaLink: 'ctaLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MortageToolsScalarFieldEnum = (typeof MortageToolsScalarFieldEnum)[keyof typeof MortageToolsScalarFieldEnum]


  export const PrivacyPolicyScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivacyPolicyScalarFieldEnum = (typeof PrivacyPolicyScalarFieldEnum)[keyof typeof PrivacyPolicyScalarFieldEnum]


  export const TermsOfUseScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TermsOfUseScalarFieldEnum = (typeof TermsOfUseScalarFieldEnum)[keyof typeof TermsOfUseScalarFieldEnum]


  export const BuyingGuidesScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuyingGuidesScalarFieldEnum = (typeof BuyingGuidesScalarFieldEnum)[keyof typeof BuyingGuidesScalarFieldEnum]


  export const SellingTipsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellingTipsScalarFieldEnum = (typeof SellingTipsScalarFieldEnum)[keyof typeof SellingTipsScalarFieldEnum]


  export const MarketInsightsScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketInsightsScalarFieldEnum = (typeof MarketInsightsScalarFieldEnum)[keyof typeof MarketInsightsScalarFieldEnum]


  export const MarketAnalysisScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketAnalysisScalarFieldEnum = (typeof MarketAnalysisScalarFieldEnum)[keyof typeof MarketAnalysisScalarFieldEnum]


  export const PressScalarFieldEnum: {
    id: 'id',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PressScalarFieldEnum = (typeof PressScalarFieldEnum)[keyof typeof PressScalarFieldEnum]


  export const BlogScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    image: 'image',
    imagePublicId: 'imagePublicId',
    category: 'category',
    categorySlug: 'categorySlug',
    tags: 'tags',
    location: 'location',
    isFeatured: 'isFeatured',
    authorName: 'authorName',
    authorImage: 'authorImage',
    authorImagePublicId: 'authorImagePublicId',
    views: 'views',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogScalarFieldEnum = (typeof BlogScalarFieldEnum)[keyof typeof BlogScalarFieldEnum]


  export const EmailConfigurationScalarFieldEnum: {
    id: 'id',
    emailMailer: 'emailMailer',
    emailHost: 'emailHost',
    emailPort: 'emailPort',
    emailUserName: 'emailUserName',
    emailPassword: 'emailPassword',
    emailEncryption: 'emailEncryption',
    emailFromName: 'emailFromName',
    emailAddress: 'emailAddress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailConfigurationScalarFieldEnum = (typeof EmailConfigurationScalarFieldEnum)[keyof typeof EmailConfigurationScalarFieldEnum]


  export const StripeConfigurationScalarFieldEnum: {
    id: 'id',
    stripeKey: 'stripeKey',
    stripeSecret: 'stripeSecret',
    stripeMethod: 'stripeMethod',
    stripeWebhookSecret: 'stripeWebhookSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeConfigurationScalarFieldEnum = (typeof StripeConfigurationScalarFieldEnum)[keyof typeof StripeConfigurationScalarFieldEnum]


  export const SellPageBannerScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    imagePublicId: 'imagePublicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellPageBannerScalarFieldEnum = (typeof SellPageBannerScalarFieldEnum)[keyof typeof SellPageBannerScalarFieldEnum]


  export const SellTypesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    items: 'items',
    image: 'image',
    imagePublicId: 'imagePublicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellTypesScalarFieldEnum = (typeof SellTypesScalarFieldEnum)[keyof typeof SellTypesScalarFieldEnum]


  export const SellerResourcesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    imagePublicId: 'imagePublicId',
    items: 'items',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SellerResourcesScalarFieldEnum = (typeof SellerResourcesScalarFieldEnum)[keyof typeof SellerResourcesScalarFieldEnum]


  export const DevelopmentPlatformScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    iosLink: 'iosLink',
    androidLink: 'androidLink',
    image: 'image',
    imagePublicId: 'imagePublicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DevelopmentPlatformScalarFieldEnum = (typeof DevelopmentPlatformScalarFieldEnum)[keyof typeof DevelopmentPlatformScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    price: 'price',
    address: 'address',
    city: 'city',
    state: 'state',
    zip: 'zip',
    latitude: 'latitude',
    longitude: 'longitude',
    neighborhood: 'neighborhood',
    views: 'views',
    type: 'type',
    property: 'property',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    size: 'size',
    lotSize: 'lotSize',
    yearBuilt: 'yearBuilt',
    hoaFees: 'hoaFees',
    leaseLength: 'leaseLength',
    furnished: 'furnished',
    deposit: 'deposit',
    moveInDate: 'moveInDate',
    amenities: 'amenities',
    garage: 'garage',
    basement: 'basement',
    fireplace: 'fireplace',
    pool: 'pool',
    pet: 'pet',
    utilities: 'utilities',
    income: 'income',
    school: 'school',
    bus: 'bus',
    restaurant: 'restaurant',
    images: 'images',
    description: 'description',
    listingStatus: 'listingStatus',
    listingType: 'listingType',
    userId: 'userId',
    userName: 'userName',
    userAvatar: 'userAvatar',
    userEmail: 'userEmail',
    status: 'status',
    flagged: 'flagged',
    reportedBy: 'reportedBy',
    flagReason: 'flagReason',
    flagStatus: 'flagStatus',
    flaggedAt: 'flaggedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const BookmarkScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    propertyId: 'propertyId',
    createdAt: 'createdAt'
  };

  export type BookmarkScalarFieldEnum = (typeof BookmarkScalarFieldEnum)[keyof typeof BookmarkScalarFieldEnum]


  export const PropertyViewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    propertyId: 'propertyId',
    viewedAt: 'viewedAt'
  };

  export type PropertyViewScalarFieldEnum = (typeof PropertyViewScalarFieldEnum)[keyof typeof PropertyViewScalarFieldEnum]


  export const PropertyTourRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    propertyId: 'propertyId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    message: 'message',
    tourTimes: 'tourTimes',
    createdAt: 'createdAt'
  };

  export type PropertyTourRequestScalarFieldEnum = (typeof PropertyTourRequestScalarFieldEnum)[keyof typeof PropertyTourRequestScalarFieldEnum]


  export const PropertyContactUserRequestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    message: 'message',
    userId: 'userId',
    propertyId: 'propertyId',
    createdAt: 'createdAt'
  };

  export type PropertyContactUserRequestScalarFieldEnum = (typeof PropertyContactUserRequestScalarFieldEnum)[keyof typeof PropertyContactUserRequestScalarFieldEnum]


  export const ContactUserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ContactUserScalarFieldEnum = (typeof ContactUserScalarFieldEnum)[keyof typeof ContactUserScalarFieldEnum]


  export const GetEstimateScalarFieldEnum: {
    id: 'id',
    email: 'email',
    createdAt: 'createdAt'
  };

  export type GetEstimateScalarFieldEnum = (typeof GetEstimateScalarFieldEnum)[keyof typeof GetEstimateScalarFieldEnum]


  export const FaqsScalarFieldEnum: {
    id: 'id',
    question: 'question',
    slug: 'slug',
    answer: 'answer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FaqsScalarFieldEnum = (typeof FaqsScalarFieldEnum)[keyof typeof FaqsScalarFieldEnum]


  export const ContactInformationScalarFieldEnum: {
    id: 'id',
    email: 'email',
    email2: 'email2',
    phone: 'phone',
    phone2: 'phone2',
    address: 'address',
    address2: 'address2',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactInformationScalarFieldEnum = (typeof ContactInformationScalarFieldEnum)[keyof typeof ContactInformationScalarFieldEnum]


  export const SocialNetworkScalarFieldEnum: {
    id: 'id',
    facebookLink: 'facebookLink',
    twitterLink: 'twitterLink',
    linkedinLink: 'linkedinLink',
    instagramLink: 'instagramLink',
    youtubeLink: 'youtubeLink',
    dribbleLink: 'dribbleLink',
    whatsappNumber: 'whatsappNumber',
    telegramLink: 'telegramLink',
    snapchatLink: 'snapchatLink',
    tiktokLink: 'tiktokLink',
    threadsLink: 'threadsLink',
    pinterestLink: 'pinterestLink',
    redditLink: 'redditLink',
    githubLink: 'githubLink',
    websiteLink: 'websiteLink',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialNetworkScalarFieldEnum = (typeof SocialNetworkScalarFieldEnum)[keyof typeof SocialNetworkScalarFieldEnum]


  export const SiteConfigurationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortDescription: 'shortDescription',
    longDescription: 'longDescription',
    copyRights: 'copyRights',
    logo: 'logo',
    logoPublicId: 'logoPublicId',
    favicon: 'favicon',
    faviconPublicId: 'faviconPublicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteConfigurationScalarFieldEnum = (typeof SiteConfigurationScalarFieldEnum)[keyof typeof SiteConfigurationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>
    


  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyType[]'
   */
  export type ListEnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType[]'>
    


  /**
   * Reference to a field of type 'PropertyCategory'
   */
  export type EnumPropertyCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCategory'>
    


  /**
   * Reference to a field of type 'PropertyCategory[]'
   */
  export type ListEnumPropertyCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyCategory[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'PropertyStatus[]'
   */
  export type ListEnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type RolePackageWhereInput = {
    AND?: RolePackageWhereInput | RolePackageWhereInput[]
    OR?: RolePackageWhereInput[]
    NOT?: RolePackageWhereInput | RolePackageWhereInput[]
    id?: StringFilter<"RolePackage"> | string
    name?: StringFilter<"RolePackage"> | string
    roleName?: EnumRoleNameFilter<"RolePackage"> | $Enums.RoleName
    price?: FloatFilter<"RolePackage"> | number
    durationDays?: IntFilter<"RolePackage"> | number
    features?: StringNullableListFilter<"RolePackage">
    createdAt?: DateTimeFilter<"RolePackage"> | Date | string
    updatedAt?: DateTimeFilter<"RolePackage"> | Date | string
    userRoles?: UserRoleListRelationFilter
  }

  export type RolePackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    roleName?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userRoles?: UserRoleOrderByRelationAggregateInput
  }

  export type RolePackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RolePackageWhereInput | RolePackageWhereInput[]
    OR?: RolePackageWhereInput[]
    NOT?: RolePackageWhereInput | RolePackageWhereInput[]
    name?: StringFilter<"RolePackage"> | string
    roleName?: EnumRoleNameFilter<"RolePackage"> | $Enums.RoleName
    price?: FloatFilter<"RolePackage"> | number
    durationDays?: IntFilter<"RolePackage"> | number
    features?: StringNullableListFilter<"RolePackage">
    createdAt?: DateTimeFilter<"RolePackage"> | Date | string
    updatedAt?: DateTimeFilter<"RolePackage"> | Date | string
    userRoles?: UserRoleListRelationFilter
  }, "id">

  export type RolePackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    roleName?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RolePackageCountOrderByAggregateInput
    _avg?: RolePackageAvgOrderByAggregateInput
    _max?: RolePackageMaxOrderByAggregateInput
    _min?: RolePackageMinOrderByAggregateInput
    _sum?: RolePackageSumOrderByAggregateInput
  }

  export type RolePackageScalarWhereWithAggregatesInput = {
    AND?: RolePackageScalarWhereWithAggregatesInput | RolePackageScalarWhereWithAggregatesInput[]
    OR?: RolePackageScalarWhereWithAggregatesInput[]
    NOT?: RolePackageScalarWhereWithAggregatesInput | RolePackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePackage"> | string
    name?: StringWithAggregatesFilter<"RolePackage"> | string
    roleName?: EnumRoleNameWithAggregatesFilter<"RolePackage"> | $Enums.RoleName
    price?: FloatWithAggregatesFilter<"RolePackage"> | number
    durationDays?: IntWithAggregatesFilter<"RolePackage"> | number
    features?: StringNullableListFilter<"RolePackage">
    createdAt?: DateTimeWithAggregatesFilter<"RolePackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RolePackage"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    avatarPublicId?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    previousRole?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    status?: EnumStatusFilter<"User"> | $Enums.Status
    resetCode?: StringNullableFilter<"User"> | string | null
    resetCodeExpiration?: DateTimeNullableFilter<"User"> | Date | string | null
    flagged?: BoolNullableFilter<"User"> | boolean | null
    flagReason?: StringNullableFilter<"User"> | string | null
    isNotificationEnabled?: BoolFilter<"User"> | boolean
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorTempToken?: StringNullableFilter<"User"> | string | null
    twoFactorTempExp?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reputationScore?: IntFilter<"User"> | number
    reputationHistory?: JsonNullableFilter<"User">
    notifications?: NotificationListRelationFilter
    userRoles?: UserRoleListRelationFilter
    sessions?: SessionListRelationFilter
    property?: PropertyListRelationFilter
    Bookmark?: BookmarkListRelationFilter
    PropertyView?: PropertyViewListRelationFilter
    PropertyTourRequest?: PropertyTourRequestListRelationFilter
    PropertyContactUserRequest?: PropertyContactUserRequestListRelationFilter
    transactions?: TransactionListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    avatarPublicId?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    previousRole?: SortOrder
    role?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    resetCode?: SortOrder
    resetCodeExpiration?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    isNotificationEnabled?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorTempToken?: SortOrder
    twoFactorTempExp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reputationScore?: SortOrder
    reputationHistory?: SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
    userRoles?: UserRoleOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    property?: PropertyOrderByRelationAggregateInput
    Bookmark?: BookmarkOrderByRelationAggregateInput
    PropertyView?: PropertyViewOrderByRelationAggregateInput
    PropertyTourRequest?: PropertyTourRequestOrderByRelationAggregateInput
    PropertyContactUserRequest?: PropertyContactUserRequestOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    reviewsGiven?: ReviewOrderByRelationAggregateInput
    reviewsReceived?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    avatarPublicId?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    zipCode?: StringNullableFilter<"User"> | string | null
    previousRole?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    isAdmin?: BoolFilter<"User"> | boolean
    status?: EnumStatusFilter<"User"> | $Enums.Status
    resetCode?: StringNullableFilter<"User"> | string | null
    resetCodeExpiration?: DateTimeNullableFilter<"User"> | Date | string | null
    flagged?: BoolNullableFilter<"User"> | boolean | null
    flagReason?: StringNullableFilter<"User"> | string | null
    isNotificationEnabled?: BoolFilter<"User"> | boolean
    isTwoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorTempToken?: StringNullableFilter<"User"> | string | null
    twoFactorTempExp?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    reputationScore?: IntFilter<"User"> | number
    reputationHistory?: JsonNullableFilter<"User">
    notifications?: NotificationListRelationFilter
    userRoles?: UserRoleListRelationFilter
    sessions?: SessionListRelationFilter
    property?: PropertyListRelationFilter
    Bookmark?: BookmarkListRelationFilter
    PropertyView?: PropertyViewListRelationFilter
    PropertyTourRequest?: PropertyTourRequestListRelationFilter
    PropertyContactUserRequest?: PropertyContactUserRequestListRelationFilter
    transactions?: TransactionListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    avatarPublicId?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    previousRole?: SortOrder
    role?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    resetCode?: SortOrder
    resetCodeExpiration?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    isNotificationEnabled?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorTempToken?: SortOrder
    twoFactorTempExp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reputationScore?: SortOrder
    reputationHistory?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarPublicId?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    previousRole?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    status?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    resetCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetCodeExpiration?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    flagged?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
    flagReason?: StringNullableWithAggregatesFilter<"User"> | string | null
    isNotificationEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    isTwoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorTempToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    twoFactorTempExp?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    reputationScore?: IntWithAggregatesFilter<"User"> | number
    reputationHistory?: JsonNullableWithAggregatesFilter<"User">
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    rolePackageId?: StringFilter<"UserRole"> | string
    startDate?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    endDate?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    isPaused?: BoolFilter<"UserRole"> | boolean
    isExpired?: BoolFilter<"UserRole"> | boolean
    message?: StringNullableFilter<"UserRole"> | string | null
    isVerified?: BoolFilter<"UserRole"> | boolean
    verifiedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    verifiedBy?: StringNullableFilter<"UserRole"> | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rolePackage?: XOR<RolePackageScalarRelationFilter, RolePackageWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rolePackageId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPaused?: SortOrder
    isExpired?: SortOrder
    message?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    rolePackage?: RolePackageOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: StringFilter<"UserRole"> | string
    rolePackageId?: StringFilter<"UserRole"> | string
    startDate?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    endDate?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    isPaused?: BoolFilter<"UserRole"> | boolean
    isExpired?: BoolFilter<"UserRole"> | boolean
    message?: StringNullableFilter<"UserRole"> | string | null
    isVerified?: BoolFilter<"UserRole"> | boolean
    verifiedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    verifiedBy?: StringNullableFilter<"UserRole"> | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    rolePackage?: XOR<RolePackageScalarRelationFilter, RolePackageWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rolePackageId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPaused?: SortOrder
    isExpired?: SortOrder
    message?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserRole"> | string
    userId?: StringWithAggregatesFilter<"UserRole"> | string
    rolePackageId?: StringWithAggregatesFilter<"UserRole"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"UserRole"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"UserRole"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"UserRole"> | boolean
    isPaused?: BoolWithAggregatesFilter<"UserRole"> | boolean
    isExpired?: BoolWithAggregatesFilter<"UserRole"> | boolean
    message?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    isVerified?: BoolWithAggregatesFilter<"UserRole"> | boolean
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"UserRole"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserRole"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    userRoleId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    method?: StringNullableFilter<"Transaction"> | string | null
    stripeId?: StringFilter<"Transaction"> | string
    invoiceUrl?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    userRole?: XOR<UserRoleScalarRelationFilter, UserRoleWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userRoleId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    stripeId?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    userRole?: UserRoleOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeId?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    userRoleId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    method?: StringNullableFilter<"Transaction"> | string | null
    invoiceUrl?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    userRole?: XOR<UserRoleScalarRelationFilter, UserRoleWhereInput>
  }, "id" | "stripeId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userRoleId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    stripeId?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    userRoleId?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    method?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    stripeId?: StringWithAggregatesFilter<"Transaction"> | string
    invoiceUrl?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    deviceInfo?: StringFilter<"Session"> | string
    isActive?: BoolFilter<"Session"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    deviceInfo?: StringFilter<"Session"> | string
    isActive?: BoolFilter<"Session"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    deviceInfo?: StringWithAggregatesFilter<"Session"> | string
    isActive?: BoolWithAggregatesFilter<"Session"> | boolean
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    targetUserId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    targetUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    reviewerId?: SortOrder
    targetUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewer?: UserOrderByWithRelationInput
    targetUser?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewerId_targetUserId?: ReviewReviewerIdTargetUserIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    reviewerId?: StringFilter<"Review"> | string
    targetUserId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    targetUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reviewerId_targetUserId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    reviewerId?: SortOrder
    targetUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    reviewerId?: StringWithAggregatesFilter<"Review"> | string
    targetUserId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringWithAggregatesFilter<"Review"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type HeroBannerWhereInput = {
    AND?: HeroBannerWhereInput | HeroBannerWhereInput[]
    OR?: HeroBannerWhereInput[]
    NOT?: HeroBannerWhereInput | HeroBannerWhereInput[]
    id?: StringFilter<"HeroBanner"> | string
    title?: StringFilter<"HeroBanner"> | string
    description?: StringFilter<"HeroBanner"> | string
    image?: StringFilter<"HeroBanner"> | string
    imagePublicId?: StringNullableFilter<"HeroBanner"> | string | null
    createdAt?: DateTimeFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBanner"> | Date | string
  }

  export type HeroBannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HeroBannerWhereInput | HeroBannerWhereInput[]
    OR?: HeroBannerWhereInput[]
    NOT?: HeroBannerWhereInput | HeroBannerWhereInput[]
    title?: StringFilter<"HeroBanner"> | string
    description?: StringFilter<"HeroBanner"> | string
    image?: StringFilter<"HeroBanner"> | string
    imagePublicId?: StringNullableFilter<"HeroBanner"> | string | null
    createdAt?: DateTimeFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeFilter<"HeroBanner"> | Date | string
  }, "id">

  export type HeroBannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HeroBannerCountOrderByAggregateInput
    _max?: HeroBannerMaxOrderByAggregateInput
    _min?: HeroBannerMinOrderByAggregateInput
  }

  export type HeroBannerScalarWhereWithAggregatesInput = {
    AND?: HeroBannerScalarWhereWithAggregatesInput | HeroBannerScalarWhereWithAggregatesInput[]
    OR?: HeroBannerScalarWhereWithAggregatesInput[]
    NOT?: HeroBannerScalarWhereWithAggregatesInput | HeroBannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HeroBanner"> | string
    title?: StringWithAggregatesFilter<"HeroBanner"> | string
    description?: StringWithAggregatesFilter<"HeroBanner"> | string
    image?: StringWithAggregatesFilter<"HeroBanner"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"HeroBanner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HeroBanner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HeroBanner"> | Date | string
  }

  export type MarketTrendsWhereInput = {
    AND?: MarketTrendsWhereInput | MarketTrendsWhereInput[]
    OR?: MarketTrendsWhereInput[]
    NOT?: MarketTrendsWhereInput | MarketTrendsWhereInput[]
    id?: StringFilter<"MarketTrends"> | string
    name?: StringFilter<"MarketTrends"> | string
    price?: FloatFilter<"MarketTrends"> | number
    day?: IntFilter<"MarketTrends"> | number
    status?: StringFilter<"MarketTrends"> | string
    createdAt?: DateTimeFilter<"MarketTrends"> | Date | string
    updatedAt?: DateTimeFilter<"MarketTrends"> | Date | string
  }

  export type MarketTrendsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    day?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketTrendsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketTrendsWhereInput | MarketTrendsWhereInput[]
    OR?: MarketTrendsWhereInput[]
    NOT?: MarketTrendsWhereInput | MarketTrendsWhereInput[]
    name?: StringFilter<"MarketTrends"> | string
    price?: FloatFilter<"MarketTrends"> | number
    day?: IntFilter<"MarketTrends"> | number
    status?: StringFilter<"MarketTrends"> | string
    createdAt?: DateTimeFilter<"MarketTrends"> | Date | string
    updatedAt?: DateTimeFilter<"MarketTrends"> | Date | string
  }, "id">

  export type MarketTrendsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    day?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketTrendsCountOrderByAggregateInput
    _avg?: MarketTrendsAvgOrderByAggregateInput
    _max?: MarketTrendsMaxOrderByAggregateInput
    _min?: MarketTrendsMinOrderByAggregateInput
    _sum?: MarketTrendsSumOrderByAggregateInput
  }

  export type MarketTrendsScalarWhereWithAggregatesInput = {
    AND?: MarketTrendsScalarWhereWithAggregatesInput | MarketTrendsScalarWhereWithAggregatesInput[]
    OR?: MarketTrendsScalarWhereWithAggregatesInput[]
    NOT?: MarketTrendsScalarWhereWithAggregatesInput | MarketTrendsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketTrends"> | string
    name?: StringWithAggregatesFilter<"MarketTrends"> | string
    price?: FloatWithAggregatesFilter<"MarketTrends"> | number
    day?: IntWithAggregatesFilter<"MarketTrends"> | number
    status?: StringWithAggregatesFilter<"MarketTrends"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MarketTrends"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketTrends"> | Date | string
  }

  export type MortageToolsWhereInput = {
    AND?: MortageToolsWhereInput | MortageToolsWhereInput[]
    OR?: MortageToolsWhereInput[]
    NOT?: MortageToolsWhereInput | MortageToolsWhereInput[]
    id?: StringFilter<"MortageTools"> | string
    name?: StringFilter<"MortageTools"> | string
    description?: StringFilter<"MortageTools"> | string
    ctaName?: StringFilter<"MortageTools"> | string
    ctaLink?: StringFilter<"MortageTools"> | string
    createdAt?: DateTimeFilter<"MortageTools"> | Date | string
    updatedAt?: DateTimeFilter<"MortageTools"> | Date | string
  }

  export type MortageToolsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ctaName?: SortOrder
    ctaLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MortageToolsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MortageToolsWhereInput | MortageToolsWhereInput[]
    OR?: MortageToolsWhereInput[]
    NOT?: MortageToolsWhereInput | MortageToolsWhereInput[]
    name?: StringFilter<"MortageTools"> | string
    description?: StringFilter<"MortageTools"> | string
    ctaName?: StringFilter<"MortageTools"> | string
    ctaLink?: StringFilter<"MortageTools"> | string
    createdAt?: DateTimeFilter<"MortageTools"> | Date | string
    updatedAt?: DateTimeFilter<"MortageTools"> | Date | string
  }, "id">

  export type MortageToolsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ctaName?: SortOrder
    ctaLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MortageToolsCountOrderByAggregateInput
    _max?: MortageToolsMaxOrderByAggregateInput
    _min?: MortageToolsMinOrderByAggregateInput
  }

  export type MortageToolsScalarWhereWithAggregatesInput = {
    AND?: MortageToolsScalarWhereWithAggregatesInput | MortageToolsScalarWhereWithAggregatesInput[]
    OR?: MortageToolsScalarWhereWithAggregatesInput[]
    NOT?: MortageToolsScalarWhereWithAggregatesInput | MortageToolsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MortageTools"> | string
    name?: StringWithAggregatesFilter<"MortageTools"> | string
    description?: StringWithAggregatesFilter<"MortageTools"> | string
    ctaName?: StringWithAggregatesFilter<"MortageTools"> | string
    ctaLink?: StringWithAggregatesFilter<"MortageTools"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MortageTools"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MortageTools"> | Date | string
  }

  export type PrivacyPolicyWhereInput = {
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    id?: StringFilter<"PrivacyPolicy"> | string
    content?: StringFilter<"PrivacyPolicy"> | string
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
  }

  export type PrivacyPolicyOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    OR?: PrivacyPolicyWhereInput[]
    NOT?: PrivacyPolicyWhereInput | PrivacyPolicyWhereInput[]
    content?: StringFilter<"PrivacyPolicy"> | string
    createdAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"PrivacyPolicy"> | Date | string
  }, "id">

  export type PrivacyPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivacyPolicyCountOrderByAggregateInput
    _max?: PrivacyPolicyMaxOrderByAggregateInput
    _min?: PrivacyPolicyMinOrderByAggregateInput
  }

  export type PrivacyPolicyScalarWhereWithAggregatesInput = {
    AND?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    OR?: PrivacyPolicyScalarWhereWithAggregatesInput[]
    NOT?: PrivacyPolicyScalarWhereWithAggregatesInput | PrivacyPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivacyPolicy"> | string
    content?: StringWithAggregatesFilter<"PrivacyPolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivacyPolicy"> | Date | string
  }

  export type TermsOfUseWhereInput = {
    AND?: TermsOfUseWhereInput | TermsOfUseWhereInput[]
    OR?: TermsOfUseWhereInput[]
    NOT?: TermsOfUseWhereInput | TermsOfUseWhereInput[]
    id?: StringFilter<"TermsOfUse"> | string
    content?: StringFilter<"TermsOfUse"> | string
    createdAt?: DateTimeFilter<"TermsOfUse"> | Date | string
    updatedAt?: DateTimeFilter<"TermsOfUse"> | Date | string
  }

  export type TermsOfUseOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsOfUseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TermsOfUseWhereInput | TermsOfUseWhereInput[]
    OR?: TermsOfUseWhereInput[]
    NOT?: TermsOfUseWhereInput | TermsOfUseWhereInput[]
    content?: StringFilter<"TermsOfUse"> | string
    createdAt?: DateTimeFilter<"TermsOfUse"> | Date | string
    updatedAt?: DateTimeFilter<"TermsOfUse"> | Date | string
  }, "id">

  export type TermsOfUseOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TermsOfUseCountOrderByAggregateInput
    _max?: TermsOfUseMaxOrderByAggregateInput
    _min?: TermsOfUseMinOrderByAggregateInput
  }

  export type TermsOfUseScalarWhereWithAggregatesInput = {
    AND?: TermsOfUseScalarWhereWithAggregatesInput | TermsOfUseScalarWhereWithAggregatesInput[]
    OR?: TermsOfUseScalarWhereWithAggregatesInput[]
    NOT?: TermsOfUseScalarWhereWithAggregatesInput | TermsOfUseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TermsOfUse"> | string
    content?: StringWithAggregatesFilter<"TermsOfUse"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TermsOfUse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TermsOfUse"> | Date | string
  }

  export type BuyingGuidesWhereInput = {
    AND?: BuyingGuidesWhereInput | BuyingGuidesWhereInput[]
    OR?: BuyingGuidesWhereInput[]
    NOT?: BuyingGuidesWhereInput | BuyingGuidesWhereInput[]
    id?: StringFilter<"BuyingGuides"> | string
    content?: StringFilter<"BuyingGuides"> | string
    createdAt?: DateTimeFilter<"BuyingGuides"> | Date | string
    updatedAt?: DateTimeFilter<"BuyingGuides"> | Date | string
  }

  export type BuyingGuidesOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuyingGuidesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuyingGuidesWhereInput | BuyingGuidesWhereInput[]
    OR?: BuyingGuidesWhereInput[]
    NOT?: BuyingGuidesWhereInput | BuyingGuidesWhereInput[]
    content?: StringFilter<"BuyingGuides"> | string
    createdAt?: DateTimeFilter<"BuyingGuides"> | Date | string
    updatedAt?: DateTimeFilter<"BuyingGuides"> | Date | string
  }, "id">

  export type BuyingGuidesOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuyingGuidesCountOrderByAggregateInput
    _max?: BuyingGuidesMaxOrderByAggregateInput
    _min?: BuyingGuidesMinOrderByAggregateInput
  }

  export type BuyingGuidesScalarWhereWithAggregatesInput = {
    AND?: BuyingGuidesScalarWhereWithAggregatesInput | BuyingGuidesScalarWhereWithAggregatesInput[]
    OR?: BuyingGuidesScalarWhereWithAggregatesInput[]
    NOT?: BuyingGuidesScalarWhereWithAggregatesInput | BuyingGuidesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BuyingGuides"> | string
    content?: StringWithAggregatesFilter<"BuyingGuides"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BuyingGuides"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BuyingGuides"> | Date | string
  }

  export type SellingTipsWhereInput = {
    AND?: SellingTipsWhereInput | SellingTipsWhereInput[]
    OR?: SellingTipsWhereInput[]
    NOT?: SellingTipsWhereInput | SellingTipsWhereInput[]
    id?: StringFilter<"SellingTips"> | string
    content?: StringFilter<"SellingTips"> | string
    createdAt?: DateTimeFilter<"SellingTips"> | Date | string
    updatedAt?: DateTimeFilter<"SellingTips"> | Date | string
  }

  export type SellingTipsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingTipsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellingTipsWhereInput | SellingTipsWhereInput[]
    OR?: SellingTipsWhereInput[]
    NOT?: SellingTipsWhereInput | SellingTipsWhereInput[]
    content?: StringFilter<"SellingTips"> | string
    createdAt?: DateTimeFilter<"SellingTips"> | Date | string
    updatedAt?: DateTimeFilter<"SellingTips"> | Date | string
  }, "id">

  export type SellingTipsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellingTipsCountOrderByAggregateInput
    _max?: SellingTipsMaxOrderByAggregateInput
    _min?: SellingTipsMinOrderByAggregateInput
  }

  export type SellingTipsScalarWhereWithAggregatesInput = {
    AND?: SellingTipsScalarWhereWithAggregatesInput | SellingTipsScalarWhereWithAggregatesInput[]
    OR?: SellingTipsScalarWhereWithAggregatesInput[]
    NOT?: SellingTipsScalarWhereWithAggregatesInput | SellingTipsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellingTips"> | string
    content?: StringWithAggregatesFilter<"SellingTips"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SellingTips"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellingTips"> | Date | string
  }

  export type MarketInsightsWhereInput = {
    AND?: MarketInsightsWhereInput | MarketInsightsWhereInput[]
    OR?: MarketInsightsWhereInput[]
    NOT?: MarketInsightsWhereInput | MarketInsightsWhereInput[]
    id?: StringFilter<"MarketInsights"> | string
    content?: StringFilter<"MarketInsights"> | string
    createdAt?: DateTimeFilter<"MarketInsights"> | Date | string
    updatedAt?: DateTimeFilter<"MarketInsights"> | Date | string
  }

  export type MarketInsightsOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketInsightsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketInsightsWhereInput | MarketInsightsWhereInput[]
    OR?: MarketInsightsWhereInput[]
    NOT?: MarketInsightsWhereInput | MarketInsightsWhereInput[]
    content?: StringFilter<"MarketInsights"> | string
    createdAt?: DateTimeFilter<"MarketInsights"> | Date | string
    updatedAt?: DateTimeFilter<"MarketInsights"> | Date | string
  }, "id">

  export type MarketInsightsOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketInsightsCountOrderByAggregateInput
    _max?: MarketInsightsMaxOrderByAggregateInput
    _min?: MarketInsightsMinOrderByAggregateInput
  }

  export type MarketInsightsScalarWhereWithAggregatesInput = {
    AND?: MarketInsightsScalarWhereWithAggregatesInput | MarketInsightsScalarWhereWithAggregatesInput[]
    OR?: MarketInsightsScalarWhereWithAggregatesInput[]
    NOT?: MarketInsightsScalarWhereWithAggregatesInput | MarketInsightsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketInsights"> | string
    content?: StringWithAggregatesFilter<"MarketInsights"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MarketInsights"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketInsights"> | Date | string
  }

  export type MarketAnalysisWhereInput = {
    AND?: MarketAnalysisWhereInput | MarketAnalysisWhereInput[]
    OR?: MarketAnalysisWhereInput[]
    NOT?: MarketAnalysisWhereInput | MarketAnalysisWhereInput[]
    id?: StringFilter<"MarketAnalysis"> | string
    content?: StringFilter<"MarketAnalysis"> | string
    createdAt?: DateTimeFilter<"MarketAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"MarketAnalysis"> | Date | string
  }

  export type MarketAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketAnalysisWhereInput | MarketAnalysisWhereInput[]
    OR?: MarketAnalysisWhereInput[]
    NOT?: MarketAnalysisWhereInput | MarketAnalysisWhereInput[]
    content?: StringFilter<"MarketAnalysis"> | string
    createdAt?: DateTimeFilter<"MarketAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"MarketAnalysis"> | Date | string
  }, "id">

  export type MarketAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketAnalysisCountOrderByAggregateInput
    _max?: MarketAnalysisMaxOrderByAggregateInput
    _min?: MarketAnalysisMinOrderByAggregateInput
  }

  export type MarketAnalysisScalarWhereWithAggregatesInput = {
    AND?: MarketAnalysisScalarWhereWithAggregatesInput | MarketAnalysisScalarWhereWithAggregatesInput[]
    OR?: MarketAnalysisScalarWhereWithAggregatesInput[]
    NOT?: MarketAnalysisScalarWhereWithAggregatesInput | MarketAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketAnalysis"> | string
    content?: StringWithAggregatesFilter<"MarketAnalysis"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MarketAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketAnalysis"> | Date | string
  }

  export type PressWhereInput = {
    AND?: PressWhereInput | PressWhereInput[]
    OR?: PressWhereInput[]
    NOT?: PressWhereInput | PressWhereInput[]
    id?: StringFilter<"Press"> | string
    content?: StringFilter<"Press"> | string
    createdAt?: DateTimeFilter<"Press"> | Date | string
    updatedAt?: DateTimeFilter<"Press"> | Date | string
  }

  export type PressOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PressWhereInput | PressWhereInput[]
    OR?: PressWhereInput[]
    NOT?: PressWhereInput | PressWhereInput[]
    content?: StringFilter<"Press"> | string
    createdAt?: DateTimeFilter<"Press"> | Date | string
    updatedAt?: DateTimeFilter<"Press"> | Date | string
  }, "id">

  export type PressOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PressCountOrderByAggregateInput
    _max?: PressMaxOrderByAggregateInput
    _min?: PressMinOrderByAggregateInput
  }

  export type PressScalarWhereWithAggregatesInput = {
    AND?: PressScalarWhereWithAggregatesInput | PressScalarWhereWithAggregatesInput[]
    OR?: PressScalarWhereWithAggregatesInput[]
    NOT?: PressScalarWhereWithAggregatesInput | PressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Press"> | string
    content?: StringWithAggregatesFilter<"Press"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Press"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Press"> | Date | string
  }

  export type BlogWhereInput = {
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    id?: StringFilter<"Blog"> | string
    title?: StringFilter<"Blog"> | string
    slug?: StringFilter<"Blog"> | string
    shortDescription?: StringFilter<"Blog"> | string
    longDescription?: StringFilter<"Blog"> | string
    image?: StringFilter<"Blog"> | string
    imagePublicId?: StringNullableFilter<"Blog"> | string | null
    category?: StringFilter<"Blog"> | string
    categorySlug?: StringFilter<"Blog"> | string
    tags?: StringNullableListFilter<"Blog">
    location?: StringNullableFilter<"Blog"> | string | null
    isFeatured?: BoolFilter<"Blog"> | boolean
    authorName?: StringFilter<"Blog"> | string
    authorImage?: StringFilter<"Blog"> | string
    authorImagePublicId?: StringNullableFilter<"Blog"> | string | null
    views?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
  }

  export type BlogOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    category?: SortOrder
    categorySlug?: SortOrder
    tags?: SortOrder
    location?: SortOrder
    isFeatured?: SortOrder
    authorName?: SortOrder
    authorImage?: SortOrder
    authorImagePublicId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BlogWhereInput | BlogWhereInput[]
    OR?: BlogWhereInput[]
    NOT?: BlogWhereInput | BlogWhereInput[]
    title?: StringFilter<"Blog"> | string
    shortDescription?: StringFilter<"Blog"> | string
    longDescription?: StringFilter<"Blog"> | string
    image?: StringFilter<"Blog"> | string
    imagePublicId?: StringNullableFilter<"Blog"> | string | null
    category?: StringFilter<"Blog"> | string
    categorySlug?: StringFilter<"Blog"> | string
    tags?: StringNullableListFilter<"Blog">
    location?: StringNullableFilter<"Blog"> | string | null
    isFeatured?: BoolFilter<"Blog"> | boolean
    authorName?: StringFilter<"Blog"> | string
    authorImage?: StringFilter<"Blog"> | string
    authorImagePublicId?: StringNullableFilter<"Blog"> | string | null
    views?: IntFilter<"Blog"> | number
    createdAt?: DateTimeFilter<"Blog"> | Date | string
    updatedAt?: DateTimeFilter<"Blog"> | Date | string
  }, "id" | "slug">

  export type BlogOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    category?: SortOrder
    categorySlug?: SortOrder
    tags?: SortOrder
    location?: SortOrder
    isFeatured?: SortOrder
    authorName?: SortOrder
    authorImage?: SortOrder
    authorImagePublicId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogCountOrderByAggregateInput
    _avg?: BlogAvgOrderByAggregateInput
    _max?: BlogMaxOrderByAggregateInput
    _min?: BlogMinOrderByAggregateInput
    _sum?: BlogSumOrderByAggregateInput
  }

  export type BlogScalarWhereWithAggregatesInput = {
    AND?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    OR?: BlogScalarWhereWithAggregatesInput[]
    NOT?: BlogScalarWhereWithAggregatesInput | BlogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Blog"> | string
    title?: StringWithAggregatesFilter<"Blog"> | string
    slug?: StringWithAggregatesFilter<"Blog"> | string
    shortDescription?: StringWithAggregatesFilter<"Blog"> | string
    longDescription?: StringWithAggregatesFilter<"Blog"> | string
    image?: StringWithAggregatesFilter<"Blog"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    category?: StringWithAggregatesFilter<"Blog"> | string
    categorySlug?: StringWithAggregatesFilter<"Blog"> | string
    tags?: StringNullableListFilter<"Blog">
    location?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    isFeatured?: BoolWithAggregatesFilter<"Blog"> | boolean
    authorName?: StringWithAggregatesFilter<"Blog"> | string
    authorImage?: StringWithAggregatesFilter<"Blog"> | string
    authorImagePublicId?: StringNullableWithAggregatesFilter<"Blog"> | string | null
    views?: IntWithAggregatesFilter<"Blog"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Blog"> | Date | string
  }

  export type EmailConfigurationWhereInput = {
    AND?: EmailConfigurationWhereInput | EmailConfigurationWhereInput[]
    OR?: EmailConfigurationWhereInput[]
    NOT?: EmailConfigurationWhereInput | EmailConfigurationWhereInput[]
    id?: StringFilter<"EmailConfiguration"> | string
    emailMailer?: StringFilter<"EmailConfiguration"> | string
    emailHost?: StringFilter<"EmailConfiguration"> | string
    emailPort?: IntFilter<"EmailConfiguration"> | number
    emailUserName?: StringFilter<"EmailConfiguration"> | string
    emailPassword?: StringFilter<"EmailConfiguration"> | string
    emailEncryption?: StringFilter<"EmailConfiguration"> | string
    emailFromName?: StringFilter<"EmailConfiguration"> | string
    emailAddress?: StringFilter<"EmailConfiguration"> | string
    createdAt?: DateTimeFilter<"EmailConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"EmailConfiguration"> | Date | string
  }

  export type EmailConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    emailMailer?: SortOrder
    emailHost?: SortOrder
    emailPort?: SortOrder
    emailUserName?: SortOrder
    emailPassword?: SortOrder
    emailEncryption?: SortOrder
    emailFromName?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    emailAddress?: string
    AND?: EmailConfigurationWhereInput | EmailConfigurationWhereInput[]
    OR?: EmailConfigurationWhereInput[]
    NOT?: EmailConfigurationWhereInput | EmailConfigurationWhereInput[]
    emailMailer?: StringFilter<"EmailConfiguration"> | string
    emailHost?: StringFilter<"EmailConfiguration"> | string
    emailPort?: IntFilter<"EmailConfiguration"> | number
    emailUserName?: StringFilter<"EmailConfiguration"> | string
    emailPassword?: StringFilter<"EmailConfiguration"> | string
    emailEncryption?: StringFilter<"EmailConfiguration"> | string
    emailFromName?: StringFilter<"EmailConfiguration"> | string
    createdAt?: DateTimeFilter<"EmailConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"EmailConfiguration"> | Date | string
  }, "id" | "emailAddress">

  export type EmailConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    emailMailer?: SortOrder
    emailHost?: SortOrder
    emailPort?: SortOrder
    emailUserName?: SortOrder
    emailPassword?: SortOrder
    emailEncryption?: SortOrder
    emailFromName?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailConfigurationCountOrderByAggregateInput
    _avg?: EmailConfigurationAvgOrderByAggregateInput
    _max?: EmailConfigurationMaxOrderByAggregateInput
    _min?: EmailConfigurationMinOrderByAggregateInput
    _sum?: EmailConfigurationSumOrderByAggregateInput
  }

  export type EmailConfigurationScalarWhereWithAggregatesInput = {
    AND?: EmailConfigurationScalarWhereWithAggregatesInput | EmailConfigurationScalarWhereWithAggregatesInput[]
    OR?: EmailConfigurationScalarWhereWithAggregatesInput[]
    NOT?: EmailConfigurationScalarWhereWithAggregatesInput | EmailConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailMailer?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailHost?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailPort?: IntWithAggregatesFilter<"EmailConfiguration"> | number
    emailUserName?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailPassword?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailEncryption?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailFromName?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    emailAddress?: StringWithAggregatesFilter<"EmailConfiguration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailConfiguration"> | Date | string
  }

  export type StripeConfigurationWhereInput = {
    AND?: StripeConfigurationWhereInput | StripeConfigurationWhereInput[]
    OR?: StripeConfigurationWhereInput[]
    NOT?: StripeConfigurationWhereInput | StripeConfigurationWhereInput[]
    id?: StringFilter<"StripeConfiguration"> | string
    stripeKey?: StringFilter<"StripeConfiguration"> | string
    stripeSecret?: StringFilter<"StripeConfiguration"> | string
    stripeMethod?: StringFilter<"StripeConfiguration"> | string
    stripeWebhookSecret?: StringFilter<"StripeConfiguration"> | string
    createdAt?: DateTimeFilter<"StripeConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"StripeConfiguration"> | Date | string
  }

  export type StripeConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    stripeKey?: SortOrder
    stripeSecret?: SortOrder
    stripeMethod?: SortOrder
    stripeWebhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StripeConfigurationWhereInput | StripeConfigurationWhereInput[]
    OR?: StripeConfigurationWhereInput[]
    NOT?: StripeConfigurationWhereInput | StripeConfigurationWhereInput[]
    stripeKey?: StringFilter<"StripeConfiguration"> | string
    stripeSecret?: StringFilter<"StripeConfiguration"> | string
    stripeMethod?: StringFilter<"StripeConfiguration"> | string
    stripeWebhookSecret?: StringFilter<"StripeConfiguration"> | string
    createdAt?: DateTimeFilter<"StripeConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"StripeConfiguration"> | Date | string
  }, "id">

  export type StripeConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    stripeKey?: SortOrder
    stripeSecret?: SortOrder
    stripeMethod?: SortOrder
    stripeWebhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeConfigurationCountOrderByAggregateInput
    _max?: StripeConfigurationMaxOrderByAggregateInput
    _min?: StripeConfigurationMinOrderByAggregateInput
  }

  export type StripeConfigurationScalarWhereWithAggregatesInput = {
    AND?: StripeConfigurationScalarWhereWithAggregatesInput | StripeConfigurationScalarWhereWithAggregatesInput[]
    OR?: StripeConfigurationScalarWhereWithAggregatesInput[]
    NOT?: StripeConfigurationScalarWhereWithAggregatesInput | StripeConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeConfiguration"> | string
    stripeKey?: StringWithAggregatesFilter<"StripeConfiguration"> | string
    stripeSecret?: StringWithAggregatesFilter<"StripeConfiguration"> | string
    stripeMethod?: StringWithAggregatesFilter<"StripeConfiguration"> | string
    stripeWebhookSecret?: StringWithAggregatesFilter<"StripeConfiguration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StripeConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeConfiguration"> | Date | string
  }

  export type SellPageBannerWhereInput = {
    AND?: SellPageBannerWhereInput | SellPageBannerWhereInput[]
    OR?: SellPageBannerWhereInput[]
    NOT?: SellPageBannerWhereInput | SellPageBannerWhereInput[]
    id?: StringFilter<"SellPageBanner"> | string
    title?: StringFilter<"SellPageBanner"> | string
    description?: StringFilter<"SellPageBanner"> | string
    image?: StringFilter<"SellPageBanner"> | string
    imagePublicId?: StringNullableFilter<"SellPageBanner"> | string | null
    createdAt?: DateTimeFilter<"SellPageBanner"> | Date | string
    updatedAt?: DateTimeFilter<"SellPageBanner"> | Date | string
  }

  export type SellPageBannerOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellPageBannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellPageBannerWhereInput | SellPageBannerWhereInput[]
    OR?: SellPageBannerWhereInput[]
    NOT?: SellPageBannerWhereInput | SellPageBannerWhereInput[]
    title?: StringFilter<"SellPageBanner"> | string
    description?: StringFilter<"SellPageBanner"> | string
    image?: StringFilter<"SellPageBanner"> | string
    imagePublicId?: StringNullableFilter<"SellPageBanner"> | string | null
    createdAt?: DateTimeFilter<"SellPageBanner"> | Date | string
    updatedAt?: DateTimeFilter<"SellPageBanner"> | Date | string
  }, "id">

  export type SellPageBannerOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellPageBannerCountOrderByAggregateInput
    _max?: SellPageBannerMaxOrderByAggregateInput
    _min?: SellPageBannerMinOrderByAggregateInput
  }

  export type SellPageBannerScalarWhereWithAggregatesInput = {
    AND?: SellPageBannerScalarWhereWithAggregatesInput | SellPageBannerScalarWhereWithAggregatesInput[]
    OR?: SellPageBannerScalarWhereWithAggregatesInput[]
    NOT?: SellPageBannerScalarWhereWithAggregatesInput | SellPageBannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellPageBanner"> | string
    title?: StringWithAggregatesFilter<"SellPageBanner"> | string
    description?: StringWithAggregatesFilter<"SellPageBanner"> | string
    image?: StringWithAggregatesFilter<"SellPageBanner"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"SellPageBanner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SellPageBanner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellPageBanner"> | Date | string
  }

  export type SellTypesWhereInput = {
    AND?: SellTypesWhereInput | SellTypesWhereInput[]
    OR?: SellTypesWhereInput[]
    NOT?: SellTypesWhereInput | SellTypesWhereInput[]
    id?: StringFilter<"SellTypes"> | string
    title?: StringFilter<"SellTypes"> | string
    description?: StringFilter<"SellTypes"> | string
    items?: JsonNullableFilter<"SellTypes">
    image?: StringFilter<"SellTypes"> | string
    imagePublicId?: StringNullableFilter<"SellTypes"> | string | null
    createdAt?: DateTimeFilter<"SellTypes"> | Date | string
    updatedAt?: DateTimeFilter<"SellTypes"> | Date | string
  }

  export type SellTypesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    items?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellTypesWhereInput | SellTypesWhereInput[]
    OR?: SellTypesWhereInput[]
    NOT?: SellTypesWhereInput | SellTypesWhereInput[]
    title?: StringFilter<"SellTypes"> | string
    description?: StringFilter<"SellTypes"> | string
    items?: JsonNullableFilter<"SellTypes">
    image?: StringFilter<"SellTypes"> | string
    imagePublicId?: StringNullableFilter<"SellTypes"> | string | null
    createdAt?: DateTimeFilter<"SellTypes"> | Date | string
    updatedAt?: DateTimeFilter<"SellTypes"> | Date | string
  }, "id">

  export type SellTypesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    items?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellTypesCountOrderByAggregateInput
    _max?: SellTypesMaxOrderByAggregateInput
    _min?: SellTypesMinOrderByAggregateInput
  }

  export type SellTypesScalarWhereWithAggregatesInput = {
    AND?: SellTypesScalarWhereWithAggregatesInput | SellTypesScalarWhereWithAggregatesInput[]
    OR?: SellTypesScalarWhereWithAggregatesInput[]
    NOT?: SellTypesScalarWhereWithAggregatesInput | SellTypesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellTypes"> | string
    title?: StringWithAggregatesFilter<"SellTypes"> | string
    description?: StringWithAggregatesFilter<"SellTypes"> | string
    items?: JsonNullableWithAggregatesFilter<"SellTypes">
    image?: StringWithAggregatesFilter<"SellTypes"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"SellTypes"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SellTypes"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellTypes"> | Date | string
  }

  export type SellerResourcesWhereInput = {
    AND?: SellerResourcesWhereInput | SellerResourcesWhereInput[]
    OR?: SellerResourcesWhereInput[]
    NOT?: SellerResourcesWhereInput | SellerResourcesWhereInput[]
    id?: StringFilter<"SellerResources"> | string
    title?: StringFilter<"SellerResources"> | string
    description?: StringNullableFilter<"SellerResources"> | string | null
    image?: StringNullableFilter<"SellerResources"> | string | null
    imagePublicId?: StringNullableFilter<"SellerResources"> | string | null
    items?: JsonNullableFilter<"SellerResources">
    createdAt?: DateTimeFilter<"SellerResources"> | Date | string
    updatedAt?: DateTimeFilter<"SellerResources"> | Date | string
  }

  export type SellerResourcesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerResourcesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellerResourcesWhereInput | SellerResourcesWhereInput[]
    OR?: SellerResourcesWhereInput[]
    NOT?: SellerResourcesWhereInput | SellerResourcesWhereInput[]
    title?: StringFilter<"SellerResources"> | string
    description?: StringNullableFilter<"SellerResources"> | string | null
    image?: StringNullableFilter<"SellerResources"> | string | null
    imagePublicId?: StringNullableFilter<"SellerResources"> | string | null
    items?: JsonNullableFilter<"SellerResources">
    createdAt?: DateTimeFilter<"SellerResources"> | Date | string
    updatedAt?: DateTimeFilter<"SellerResources"> | Date | string
  }, "id">

  export type SellerResourcesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SellerResourcesCountOrderByAggregateInput
    _max?: SellerResourcesMaxOrderByAggregateInput
    _min?: SellerResourcesMinOrderByAggregateInput
  }

  export type SellerResourcesScalarWhereWithAggregatesInput = {
    AND?: SellerResourcesScalarWhereWithAggregatesInput | SellerResourcesScalarWhereWithAggregatesInput[]
    OR?: SellerResourcesScalarWhereWithAggregatesInput[]
    NOT?: SellerResourcesScalarWhereWithAggregatesInput | SellerResourcesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SellerResources"> | string
    title?: StringWithAggregatesFilter<"SellerResources"> | string
    description?: StringNullableWithAggregatesFilter<"SellerResources"> | string | null
    image?: StringNullableWithAggregatesFilter<"SellerResources"> | string | null
    imagePublicId?: StringNullableWithAggregatesFilter<"SellerResources"> | string | null
    items?: JsonNullableWithAggregatesFilter<"SellerResources">
    createdAt?: DateTimeWithAggregatesFilter<"SellerResources"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SellerResources"> | Date | string
  }

  export type DevelopmentPlatformWhereInput = {
    AND?: DevelopmentPlatformWhereInput | DevelopmentPlatformWhereInput[]
    OR?: DevelopmentPlatformWhereInput[]
    NOT?: DevelopmentPlatformWhereInput | DevelopmentPlatformWhereInput[]
    id?: StringFilter<"DevelopmentPlatform"> | string
    title?: StringFilter<"DevelopmentPlatform"> | string
    description?: StringFilter<"DevelopmentPlatform"> | string
    iosLink?: StringFilter<"DevelopmentPlatform"> | string
    androidLink?: StringFilter<"DevelopmentPlatform"> | string
    image?: StringFilter<"DevelopmentPlatform"> | string
    imagePublicId?: StringNullableFilter<"DevelopmentPlatform"> | string | null
    createdAt?: DateTimeFilter<"DevelopmentPlatform"> | Date | string
    updatedAt?: DateTimeFilter<"DevelopmentPlatform"> | Date | string
  }

  export type DevelopmentPlatformOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iosLink?: SortOrder
    androidLink?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevelopmentPlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DevelopmentPlatformWhereInput | DevelopmentPlatformWhereInput[]
    OR?: DevelopmentPlatformWhereInput[]
    NOT?: DevelopmentPlatformWhereInput | DevelopmentPlatformWhereInput[]
    title?: StringFilter<"DevelopmentPlatform"> | string
    description?: StringFilter<"DevelopmentPlatform"> | string
    iosLink?: StringFilter<"DevelopmentPlatform"> | string
    androidLink?: StringFilter<"DevelopmentPlatform"> | string
    image?: StringFilter<"DevelopmentPlatform"> | string
    imagePublicId?: StringNullableFilter<"DevelopmentPlatform"> | string | null
    createdAt?: DateTimeFilter<"DevelopmentPlatform"> | Date | string
    updatedAt?: DateTimeFilter<"DevelopmentPlatform"> | Date | string
  }, "id">

  export type DevelopmentPlatformOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iosLink?: SortOrder
    androidLink?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DevelopmentPlatformCountOrderByAggregateInput
    _max?: DevelopmentPlatformMaxOrderByAggregateInput
    _min?: DevelopmentPlatformMinOrderByAggregateInput
  }

  export type DevelopmentPlatformScalarWhereWithAggregatesInput = {
    AND?: DevelopmentPlatformScalarWhereWithAggregatesInput | DevelopmentPlatformScalarWhereWithAggregatesInput[]
    OR?: DevelopmentPlatformScalarWhereWithAggregatesInput[]
    NOT?: DevelopmentPlatformScalarWhereWithAggregatesInput | DevelopmentPlatformScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DevelopmentPlatform"> | string
    title?: StringWithAggregatesFilter<"DevelopmentPlatform"> | string
    description?: StringWithAggregatesFilter<"DevelopmentPlatform"> | string
    iosLink?: StringWithAggregatesFilter<"DevelopmentPlatform"> | string
    androidLink?: StringWithAggregatesFilter<"DevelopmentPlatform"> | string
    image?: StringWithAggregatesFilter<"DevelopmentPlatform"> | string
    imagePublicId?: StringNullableWithAggregatesFilter<"DevelopmentPlatform"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DevelopmentPlatform"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DevelopmentPlatform"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    title?: StringFilter<"Property"> | string
    slug?: StringFilter<"Property"> | string
    price?: FloatFilter<"Property"> | number
    address?: StringNullableFilter<"Property"> | string | null
    city?: StringNullableFilter<"Property"> | string | null
    state?: StringNullableFilter<"Property"> | string | null
    zip?: StringNullableFilter<"Property"> | string | null
    latitude?: StringNullableFilter<"Property"> | string | null
    longitude?: StringNullableFilter<"Property"> | string | null
    neighborhood?: StringNullableFilter<"Property"> | string | null
    views?: IntFilter<"Property"> | number
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    property?: EnumPropertyCategoryFilter<"Property"> | $Enums.PropertyCategory
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: IntNullableFilter<"Property"> | number | null
    size?: IntNullableFilter<"Property"> | number | null
    lotSize?: FloatNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    hoaFees?: IntNullableFilter<"Property"> | number | null
    leaseLength?: StringNullableFilter<"Property"> | string | null
    furnished?: BoolNullableFilter<"Property"> | boolean | null
    deposit?: FloatNullableFilter<"Property"> | number | null
    moveInDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    amenities?: StringNullableListFilter<"Property">
    garage?: BoolNullableFilter<"Property"> | boolean | null
    basement?: BoolNullableFilter<"Property"> | boolean | null
    fireplace?: BoolNullableFilter<"Property"> | boolean | null
    pool?: BoolNullableFilter<"Property"> | boolean | null
    pet?: StringNullableFilter<"Property"> | string | null
    utilities?: StringNullableFilter<"Property"> | string | null
    income?: StringNullableFilter<"Property"> | string | null
    school?: StringNullableFilter<"Property"> | string | null
    bus?: StringNullableFilter<"Property"> | string | null
    restaurant?: StringNullableFilter<"Property"> | string | null
    images?: JsonNullableFilter<"Property">
    description?: StringFilter<"Property"> | string
    listingStatus?: EnumListingStatusNullableFilter<"Property"> | $Enums.ListingStatus | null
    listingType?: StringFilter<"Property"> | string
    userId?: StringFilter<"Property"> | string
    userName?: StringNullableFilter<"Property"> | string | null
    userAvatar?: StringNullableFilter<"Property"> | string | null
    userEmail?: StringNullableFilter<"Property"> | string | null
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    flagged?: BoolFilter<"Property"> | boolean
    reportedBy?: StringNullableListFilter<"Property">
    flagReason?: StringNullableFilter<"Property"> | string | null
    flagStatus?: StringNullableFilter<"Property"> | string | null
    flaggedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Bookmark?: BookmarkListRelationFilter
    PropertyView?: PropertyViewListRelationFilter
    PropertyTourRequest?: PropertyTourRequestListRelationFilter
    PropertyContactUserRequest?: PropertyContactUserRequestListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    neighborhood?: SortOrder
    views?: SortOrder
    type?: SortOrder
    property?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    leaseLength?: SortOrder
    furnished?: SortOrder
    deposit?: SortOrder
    moveInDate?: SortOrder
    amenities?: SortOrder
    garage?: SortOrder
    basement?: SortOrder
    fireplace?: SortOrder
    pool?: SortOrder
    pet?: SortOrder
    utilities?: SortOrder
    income?: SortOrder
    school?: SortOrder
    bus?: SortOrder
    restaurant?: SortOrder
    images?: SortOrder
    description?: SortOrder
    listingStatus?: SortOrder
    listingType?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userAvatar?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    reportedBy?: SortOrder
    flagReason?: SortOrder
    flagStatus?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    Bookmark?: BookmarkOrderByRelationAggregateInput
    PropertyView?: PropertyViewOrderByRelationAggregateInput
    PropertyTourRequest?: PropertyTourRequestOrderByRelationAggregateInput
    PropertyContactUserRequest?: PropertyContactUserRequestOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    title?: StringFilter<"Property"> | string
    slug?: StringFilter<"Property"> | string
    price?: FloatFilter<"Property"> | number
    address?: StringNullableFilter<"Property"> | string | null
    city?: StringNullableFilter<"Property"> | string | null
    state?: StringNullableFilter<"Property"> | string | null
    zip?: StringNullableFilter<"Property"> | string | null
    latitude?: StringNullableFilter<"Property"> | string | null
    longitude?: StringNullableFilter<"Property"> | string | null
    neighborhood?: StringNullableFilter<"Property"> | string | null
    views?: IntFilter<"Property"> | number
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    property?: EnumPropertyCategoryFilter<"Property"> | $Enums.PropertyCategory
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: IntNullableFilter<"Property"> | number | null
    size?: IntNullableFilter<"Property"> | number | null
    lotSize?: FloatNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    hoaFees?: IntNullableFilter<"Property"> | number | null
    leaseLength?: StringNullableFilter<"Property"> | string | null
    furnished?: BoolNullableFilter<"Property"> | boolean | null
    deposit?: FloatNullableFilter<"Property"> | number | null
    moveInDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    amenities?: StringNullableListFilter<"Property">
    garage?: BoolNullableFilter<"Property"> | boolean | null
    basement?: BoolNullableFilter<"Property"> | boolean | null
    fireplace?: BoolNullableFilter<"Property"> | boolean | null
    pool?: BoolNullableFilter<"Property"> | boolean | null
    pet?: StringNullableFilter<"Property"> | string | null
    utilities?: StringNullableFilter<"Property"> | string | null
    income?: StringNullableFilter<"Property"> | string | null
    school?: StringNullableFilter<"Property"> | string | null
    bus?: StringNullableFilter<"Property"> | string | null
    restaurant?: StringNullableFilter<"Property"> | string | null
    images?: JsonNullableFilter<"Property">
    description?: StringFilter<"Property"> | string
    listingStatus?: EnumListingStatusNullableFilter<"Property"> | $Enums.ListingStatus | null
    listingType?: StringFilter<"Property"> | string
    userId?: StringFilter<"Property"> | string
    userName?: StringNullableFilter<"Property"> | string | null
    userAvatar?: StringNullableFilter<"Property"> | string | null
    userEmail?: StringNullableFilter<"Property"> | string | null
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    flagged?: BoolFilter<"Property"> | boolean
    reportedBy?: StringNullableListFilter<"Property">
    flagReason?: StringNullableFilter<"Property"> | string | null
    flagStatus?: StringNullableFilter<"Property"> | string | null
    flaggedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    Bookmark?: BookmarkListRelationFilter
    PropertyView?: PropertyViewListRelationFilter
    PropertyTourRequest?: PropertyTourRequestListRelationFilter
    PropertyContactUserRequest?: PropertyContactUserRequestListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    neighborhood?: SortOrder
    views?: SortOrder
    type?: SortOrder
    property?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    leaseLength?: SortOrder
    furnished?: SortOrder
    deposit?: SortOrder
    moveInDate?: SortOrder
    amenities?: SortOrder
    garage?: SortOrder
    basement?: SortOrder
    fireplace?: SortOrder
    pool?: SortOrder
    pet?: SortOrder
    utilities?: SortOrder
    income?: SortOrder
    school?: SortOrder
    bus?: SortOrder
    restaurant?: SortOrder
    images?: SortOrder
    description?: SortOrder
    listingStatus?: SortOrder
    listingType?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userAvatar?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    reportedBy?: SortOrder
    flagReason?: SortOrder
    flagStatus?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    title?: StringWithAggregatesFilter<"Property"> | string
    slug?: StringWithAggregatesFilter<"Property"> | string
    price?: FloatWithAggregatesFilter<"Property"> | number
    address?: StringNullableWithAggregatesFilter<"Property"> | string | null
    city?: StringNullableWithAggregatesFilter<"Property"> | string | null
    state?: StringNullableWithAggregatesFilter<"Property"> | string | null
    zip?: StringNullableWithAggregatesFilter<"Property"> | string | null
    latitude?: StringNullableWithAggregatesFilter<"Property"> | string | null
    longitude?: StringNullableWithAggregatesFilter<"Property"> | string | null
    neighborhood?: StringNullableWithAggregatesFilter<"Property"> | string | null
    views?: IntWithAggregatesFilter<"Property"> | number
    type?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
    property?: EnumPropertyCategoryWithAggregatesFilter<"Property"> | $Enums.PropertyCategory
    bedrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    bathrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    size?: IntNullableWithAggregatesFilter<"Property"> | number | null
    lotSize?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    yearBuilt?: IntNullableWithAggregatesFilter<"Property"> | number | null
    hoaFees?: IntNullableWithAggregatesFilter<"Property"> | number | null
    leaseLength?: StringNullableWithAggregatesFilter<"Property"> | string | null
    furnished?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    deposit?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    moveInDate?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    amenities?: StringNullableListFilter<"Property">
    garage?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    basement?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    fireplace?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    pool?: BoolNullableWithAggregatesFilter<"Property"> | boolean | null
    pet?: StringNullableWithAggregatesFilter<"Property"> | string | null
    utilities?: StringNullableWithAggregatesFilter<"Property"> | string | null
    income?: StringNullableWithAggregatesFilter<"Property"> | string | null
    school?: StringNullableWithAggregatesFilter<"Property"> | string | null
    bus?: StringNullableWithAggregatesFilter<"Property"> | string | null
    restaurant?: StringNullableWithAggregatesFilter<"Property"> | string | null
    images?: JsonNullableWithAggregatesFilter<"Property">
    description?: StringWithAggregatesFilter<"Property"> | string
    listingStatus?: EnumListingStatusNullableWithAggregatesFilter<"Property"> | $Enums.ListingStatus | null
    listingType?: StringWithAggregatesFilter<"Property"> | string
    userId?: StringWithAggregatesFilter<"Property"> | string
    userName?: StringNullableWithAggregatesFilter<"Property"> | string | null
    userAvatar?: StringNullableWithAggregatesFilter<"Property"> | string | null
    userEmail?: StringNullableWithAggregatesFilter<"Property"> | string | null
    status?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    flagged?: BoolWithAggregatesFilter<"Property"> | boolean
    reportedBy?: StringNullableListFilter<"Property">
    flagReason?: StringNullableWithAggregatesFilter<"Property"> | string | null
    flagStatus?: StringNullableWithAggregatesFilter<"Property"> | string | null
    flaggedAt?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type BookmarkWhereInput = {
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    userId?: StringFilter<"Bookmark"> | string
    propertyId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type BookmarkOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type BookmarkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_propertyId?: BookmarkUserIdPropertyIdCompoundUniqueInput
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    userId?: StringFilter<"Bookmark"> | string
    propertyId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "userId_propertyId">

  export type BookmarkOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkCountOrderByAggregateInput
    _max?: BookmarkMaxOrderByAggregateInput
    _min?: BookmarkMinOrderByAggregateInput
  }

  export type BookmarkScalarWhereWithAggregatesInput = {
    AND?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    OR?: BookmarkScalarWhereWithAggregatesInput[]
    NOT?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bookmark"> | string
    userId?: StringWithAggregatesFilter<"Bookmark"> | string
    propertyId?: StringWithAggregatesFilter<"Bookmark"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bookmark"> | Date | string
  }

  export type PropertyViewWhereInput = {
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    id?: StringFilter<"PropertyView"> | string
    userId?: StringFilter<"PropertyView"> | string
    propertyId?: StringFilter<"PropertyView"> | string
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyViewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyViewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_propertyId?: PropertyViewUserIdPropertyIdCompoundUniqueInput
    AND?: PropertyViewWhereInput | PropertyViewWhereInput[]
    OR?: PropertyViewWhereInput[]
    NOT?: PropertyViewWhereInput | PropertyViewWhereInput[]
    userId?: StringFilter<"PropertyView"> | string
    propertyId?: StringFilter<"PropertyView"> | string
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "userId_propertyId">

  export type PropertyViewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
    _count?: PropertyViewCountOrderByAggregateInput
    _max?: PropertyViewMaxOrderByAggregateInput
    _min?: PropertyViewMinOrderByAggregateInput
  }

  export type PropertyViewScalarWhereWithAggregatesInput = {
    AND?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    OR?: PropertyViewScalarWhereWithAggregatesInput[]
    NOT?: PropertyViewScalarWhereWithAggregatesInput | PropertyViewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyView"> | string
    userId?: StringWithAggregatesFilter<"PropertyView"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyView"> | string
    viewedAt?: DateTimeWithAggregatesFilter<"PropertyView"> | Date | string
  }

  export type PropertyTourRequestWhereInput = {
    AND?: PropertyTourRequestWhereInput | PropertyTourRequestWhereInput[]
    OR?: PropertyTourRequestWhereInput[]
    NOT?: PropertyTourRequestWhereInput | PropertyTourRequestWhereInput[]
    id?: StringFilter<"PropertyTourRequest"> | string
    userId?: StringFilter<"PropertyTourRequest"> | string
    propertyId?: StringFilter<"PropertyTourRequest"> | string
    name?: StringFilter<"PropertyTourRequest"> | string
    email?: StringFilter<"PropertyTourRequest"> | string
    phone?: StringFilter<"PropertyTourRequest"> | string
    message?: StringNullableFilter<"PropertyTourRequest"> | string | null
    tourTimes?: JsonFilter<"PropertyTourRequest">
    createdAt?: DateTimeFilter<"PropertyTourRequest"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyTourRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    tourTimes?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyTourRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyTourRequestWhereInput | PropertyTourRequestWhereInput[]
    OR?: PropertyTourRequestWhereInput[]
    NOT?: PropertyTourRequestWhereInput | PropertyTourRequestWhereInput[]
    userId?: StringFilter<"PropertyTourRequest"> | string
    propertyId?: StringFilter<"PropertyTourRequest"> | string
    name?: StringFilter<"PropertyTourRequest"> | string
    email?: StringFilter<"PropertyTourRequest"> | string
    phone?: StringFilter<"PropertyTourRequest"> | string
    message?: StringNullableFilter<"PropertyTourRequest"> | string | null
    tourTimes?: JsonFilter<"PropertyTourRequest">
    createdAt?: DateTimeFilter<"PropertyTourRequest"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyTourRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    tourTimes?: SortOrder
    createdAt?: SortOrder
    _count?: PropertyTourRequestCountOrderByAggregateInput
    _max?: PropertyTourRequestMaxOrderByAggregateInput
    _min?: PropertyTourRequestMinOrderByAggregateInput
  }

  export type PropertyTourRequestScalarWhereWithAggregatesInput = {
    AND?: PropertyTourRequestScalarWhereWithAggregatesInput | PropertyTourRequestScalarWhereWithAggregatesInput[]
    OR?: PropertyTourRequestScalarWhereWithAggregatesInput[]
    NOT?: PropertyTourRequestScalarWhereWithAggregatesInput | PropertyTourRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyTourRequest"> | string
    userId?: StringWithAggregatesFilter<"PropertyTourRequest"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyTourRequest"> | string
    name?: StringWithAggregatesFilter<"PropertyTourRequest"> | string
    email?: StringWithAggregatesFilter<"PropertyTourRequest"> | string
    phone?: StringWithAggregatesFilter<"PropertyTourRequest"> | string
    message?: StringNullableWithAggregatesFilter<"PropertyTourRequest"> | string | null
    tourTimes?: JsonWithAggregatesFilter<"PropertyTourRequest">
    createdAt?: DateTimeWithAggregatesFilter<"PropertyTourRequest"> | Date | string
  }

  export type PropertyContactUserRequestWhereInput = {
    AND?: PropertyContactUserRequestWhereInput | PropertyContactUserRequestWhereInput[]
    OR?: PropertyContactUserRequestWhereInput[]
    NOT?: PropertyContactUserRequestWhereInput | PropertyContactUserRequestWhereInput[]
    id?: StringFilter<"PropertyContactUserRequest"> | string
    name?: StringFilter<"PropertyContactUserRequest"> | string
    phone?: StringFilter<"PropertyContactUserRequest"> | string
    email?: StringFilter<"PropertyContactUserRequest"> | string
    message?: StringFilter<"PropertyContactUserRequest"> | string
    userId?: StringFilter<"PropertyContactUserRequest"> | string
    propertyId?: StringFilter<"PropertyContactUserRequest"> | string
    createdAt?: DateTimeFilter<"PropertyContactUserRequest"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyContactUserRequestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyContactUserRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyContactUserRequestWhereInput | PropertyContactUserRequestWhereInput[]
    OR?: PropertyContactUserRequestWhereInput[]
    NOT?: PropertyContactUserRequestWhereInput | PropertyContactUserRequestWhereInput[]
    name?: StringFilter<"PropertyContactUserRequest"> | string
    phone?: StringFilter<"PropertyContactUserRequest"> | string
    email?: StringFilter<"PropertyContactUserRequest"> | string
    message?: StringFilter<"PropertyContactUserRequest"> | string
    userId?: StringFilter<"PropertyContactUserRequest"> | string
    propertyId?: StringFilter<"PropertyContactUserRequest"> | string
    createdAt?: DateTimeFilter<"PropertyContactUserRequest"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyContactUserRequestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
    _count?: PropertyContactUserRequestCountOrderByAggregateInput
    _max?: PropertyContactUserRequestMaxOrderByAggregateInput
    _min?: PropertyContactUserRequestMinOrderByAggregateInput
  }

  export type PropertyContactUserRequestScalarWhereWithAggregatesInput = {
    AND?: PropertyContactUserRequestScalarWhereWithAggregatesInput | PropertyContactUserRequestScalarWhereWithAggregatesInput[]
    OR?: PropertyContactUserRequestScalarWhereWithAggregatesInput[]
    NOT?: PropertyContactUserRequestScalarWhereWithAggregatesInput | PropertyContactUserRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    name?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    phone?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    email?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    message?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    userId?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyContactUserRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyContactUserRequest"> | Date | string
  }

  export type ContactUserWhereInput = {
    AND?: ContactUserWhereInput | ContactUserWhereInput[]
    OR?: ContactUserWhereInput[]
    NOT?: ContactUserWhereInput | ContactUserWhereInput[]
    id?: StringFilter<"ContactUser"> | string
    name?: StringFilter<"ContactUser"> | string
    email?: StringFilter<"ContactUser"> | string
    subject?: StringFilter<"ContactUser"> | string
    message?: StringFilter<"ContactUser"> | string
    createdAt?: DateTimeFilter<"ContactUser"> | Date | string
  }

  export type ContactUserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactUserWhereInput | ContactUserWhereInput[]
    OR?: ContactUserWhereInput[]
    NOT?: ContactUserWhereInput | ContactUserWhereInput[]
    name?: StringFilter<"ContactUser"> | string
    email?: StringFilter<"ContactUser"> | string
    subject?: StringFilter<"ContactUser"> | string
    message?: StringFilter<"ContactUser"> | string
    createdAt?: DateTimeFilter<"ContactUser"> | Date | string
  }, "id">

  export type ContactUserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: ContactUserCountOrderByAggregateInput
    _max?: ContactUserMaxOrderByAggregateInput
    _min?: ContactUserMinOrderByAggregateInput
  }

  export type ContactUserScalarWhereWithAggregatesInput = {
    AND?: ContactUserScalarWhereWithAggregatesInput | ContactUserScalarWhereWithAggregatesInput[]
    OR?: ContactUserScalarWhereWithAggregatesInput[]
    NOT?: ContactUserScalarWhereWithAggregatesInput | ContactUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactUser"> | string
    name?: StringWithAggregatesFilter<"ContactUser"> | string
    email?: StringWithAggregatesFilter<"ContactUser"> | string
    subject?: StringWithAggregatesFilter<"ContactUser"> | string
    message?: StringWithAggregatesFilter<"ContactUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactUser"> | Date | string
  }

  export type GetEstimateWhereInput = {
    AND?: GetEstimateWhereInput | GetEstimateWhereInput[]
    OR?: GetEstimateWhereInput[]
    NOT?: GetEstimateWhereInput | GetEstimateWhereInput[]
    id?: StringFilter<"GetEstimate"> | string
    email?: StringFilter<"GetEstimate"> | string
    createdAt?: DateTimeFilter<"GetEstimate"> | Date | string
  }

  export type GetEstimateOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type GetEstimateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GetEstimateWhereInput | GetEstimateWhereInput[]
    OR?: GetEstimateWhereInput[]
    NOT?: GetEstimateWhereInput | GetEstimateWhereInput[]
    email?: StringFilter<"GetEstimate"> | string
    createdAt?: DateTimeFilter<"GetEstimate"> | Date | string
  }, "id">

  export type GetEstimateOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    _count?: GetEstimateCountOrderByAggregateInput
    _max?: GetEstimateMaxOrderByAggregateInput
    _min?: GetEstimateMinOrderByAggregateInput
  }

  export type GetEstimateScalarWhereWithAggregatesInput = {
    AND?: GetEstimateScalarWhereWithAggregatesInput | GetEstimateScalarWhereWithAggregatesInput[]
    OR?: GetEstimateScalarWhereWithAggregatesInput[]
    NOT?: GetEstimateScalarWhereWithAggregatesInput | GetEstimateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GetEstimate"> | string
    email?: StringWithAggregatesFilter<"GetEstimate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GetEstimate"> | Date | string
  }

  export type FaqsWhereInput = {
    AND?: FaqsWhereInput | FaqsWhereInput[]
    OR?: FaqsWhereInput[]
    NOT?: FaqsWhereInput | FaqsWhereInput[]
    id?: StringFilter<"Faqs"> | string
    question?: StringFilter<"Faqs"> | string
    slug?: StringFilter<"Faqs"> | string
    answer?: StringFilter<"Faqs"> | string
    createdAt?: DateTimeFilter<"Faqs"> | Date | string
    updatedAt?: DateTimeFilter<"Faqs"> | Date | string
  }

  export type FaqsOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FaqsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: FaqsWhereInput | FaqsWhereInput[]
    OR?: FaqsWhereInput[]
    NOT?: FaqsWhereInput | FaqsWhereInput[]
    question?: StringFilter<"Faqs"> | string
    answer?: StringFilter<"Faqs"> | string
    createdAt?: DateTimeFilter<"Faqs"> | Date | string
    updatedAt?: DateTimeFilter<"Faqs"> | Date | string
  }, "id" | "slug">

  export type FaqsOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FaqsCountOrderByAggregateInput
    _max?: FaqsMaxOrderByAggregateInput
    _min?: FaqsMinOrderByAggregateInput
  }

  export type FaqsScalarWhereWithAggregatesInput = {
    AND?: FaqsScalarWhereWithAggregatesInput | FaqsScalarWhereWithAggregatesInput[]
    OR?: FaqsScalarWhereWithAggregatesInput[]
    NOT?: FaqsScalarWhereWithAggregatesInput | FaqsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Faqs"> | string
    question?: StringWithAggregatesFilter<"Faqs"> | string
    slug?: StringWithAggregatesFilter<"Faqs"> | string
    answer?: StringWithAggregatesFilter<"Faqs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Faqs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Faqs"> | Date | string
  }

  export type ContactInformationWhereInput = {
    AND?: ContactInformationWhereInput | ContactInformationWhereInput[]
    OR?: ContactInformationWhereInput[]
    NOT?: ContactInformationWhereInput | ContactInformationWhereInput[]
    id?: StringFilter<"ContactInformation"> | string
    email?: StringFilter<"ContactInformation"> | string
    email2?: StringNullableFilter<"ContactInformation"> | string | null
    phone?: StringFilter<"ContactInformation"> | string
    phone2?: StringNullableFilter<"ContactInformation"> | string | null
    address?: StringFilter<"ContactInformation"> | string
    address2?: StringNullableFilter<"ContactInformation"> | string | null
    createdAt?: DateTimeFilter<"ContactInformation"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInformation"> | Date | string
  }

  export type ContactInformationOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    email2?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInformationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactInformationWhereInput | ContactInformationWhereInput[]
    OR?: ContactInformationWhereInput[]
    NOT?: ContactInformationWhereInput | ContactInformationWhereInput[]
    email?: StringFilter<"ContactInformation"> | string
    email2?: StringNullableFilter<"ContactInformation"> | string | null
    phone?: StringFilter<"ContactInformation"> | string
    phone2?: StringNullableFilter<"ContactInformation"> | string | null
    address?: StringFilter<"ContactInformation"> | string
    address2?: StringNullableFilter<"ContactInformation"> | string | null
    createdAt?: DateTimeFilter<"ContactInformation"> | Date | string
    updatedAt?: DateTimeFilter<"ContactInformation"> | Date | string
  }, "id">

  export type ContactInformationOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    email2?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactInformationCountOrderByAggregateInput
    _max?: ContactInformationMaxOrderByAggregateInput
    _min?: ContactInformationMinOrderByAggregateInput
  }

  export type ContactInformationScalarWhereWithAggregatesInput = {
    AND?: ContactInformationScalarWhereWithAggregatesInput | ContactInformationScalarWhereWithAggregatesInput[]
    OR?: ContactInformationScalarWhereWithAggregatesInput[]
    NOT?: ContactInformationScalarWhereWithAggregatesInput | ContactInformationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactInformation"> | string
    email?: StringWithAggregatesFilter<"ContactInformation"> | string
    email2?: StringNullableWithAggregatesFilter<"ContactInformation"> | string | null
    phone?: StringWithAggregatesFilter<"ContactInformation"> | string
    phone2?: StringNullableWithAggregatesFilter<"ContactInformation"> | string | null
    address?: StringWithAggregatesFilter<"ContactInformation"> | string
    address2?: StringNullableWithAggregatesFilter<"ContactInformation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContactInformation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactInformation"> | Date | string
  }

  export type SocialNetworkWhereInput = {
    AND?: SocialNetworkWhereInput | SocialNetworkWhereInput[]
    OR?: SocialNetworkWhereInput[]
    NOT?: SocialNetworkWhereInput | SocialNetworkWhereInput[]
    id?: StringFilter<"SocialNetwork"> | string
    facebookLink?: StringNullableFilter<"SocialNetwork"> | string | null
    twitterLink?: StringNullableFilter<"SocialNetwork"> | string | null
    linkedinLink?: StringNullableFilter<"SocialNetwork"> | string | null
    instagramLink?: StringNullableFilter<"SocialNetwork"> | string | null
    youtubeLink?: StringNullableFilter<"SocialNetwork"> | string | null
    dribbleLink?: StringNullableFilter<"SocialNetwork"> | string | null
    whatsappNumber?: StringNullableFilter<"SocialNetwork"> | string | null
    telegramLink?: StringNullableFilter<"SocialNetwork"> | string | null
    snapchatLink?: StringNullableFilter<"SocialNetwork"> | string | null
    tiktokLink?: StringNullableFilter<"SocialNetwork"> | string | null
    threadsLink?: StringNullableFilter<"SocialNetwork"> | string | null
    pinterestLink?: StringNullableFilter<"SocialNetwork"> | string | null
    redditLink?: StringNullableFilter<"SocialNetwork"> | string | null
    githubLink?: StringNullableFilter<"SocialNetwork"> | string | null
    websiteLink?: StringNullableFilter<"SocialNetwork"> | string | null
    createdAt?: DateTimeFilter<"SocialNetwork"> | Date | string
    updatedAt?: DateTimeFilter<"SocialNetwork"> | Date | string
  }

  export type SocialNetworkOrderByWithRelationInput = {
    id?: SortOrder
    facebookLink?: SortOrder
    twitterLink?: SortOrder
    linkedinLink?: SortOrder
    instagramLink?: SortOrder
    youtubeLink?: SortOrder
    dribbleLink?: SortOrder
    whatsappNumber?: SortOrder
    telegramLink?: SortOrder
    snapchatLink?: SortOrder
    tiktokLink?: SortOrder
    threadsLink?: SortOrder
    pinterestLink?: SortOrder
    redditLink?: SortOrder
    githubLink?: SortOrder
    websiteLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialNetworkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SocialNetworkWhereInput | SocialNetworkWhereInput[]
    OR?: SocialNetworkWhereInput[]
    NOT?: SocialNetworkWhereInput | SocialNetworkWhereInput[]
    facebookLink?: StringNullableFilter<"SocialNetwork"> | string | null
    twitterLink?: StringNullableFilter<"SocialNetwork"> | string | null
    linkedinLink?: StringNullableFilter<"SocialNetwork"> | string | null
    instagramLink?: StringNullableFilter<"SocialNetwork"> | string | null
    youtubeLink?: StringNullableFilter<"SocialNetwork"> | string | null
    dribbleLink?: StringNullableFilter<"SocialNetwork"> | string | null
    whatsappNumber?: StringNullableFilter<"SocialNetwork"> | string | null
    telegramLink?: StringNullableFilter<"SocialNetwork"> | string | null
    snapchatLink?: StringNullableFilter<"SocialNetwork"> | string | null
    tiktokLink?: StringNullableFilter<"SocialNetwork"> | string | null
    threadsLink?: StringNullableFilter<"SocialNetwork"> | string | null
    pinterestLink?: StringNullableFilter<"SocialNetwork"> | string | null
    redditLink?: StringNullableFilter<"SocialNetwork"> | string | null
    githubLink?: StringNullableFilter<"SocialNetwork"> | string | null
    websiteLink?: StringNullableFilter<"SocialNetwork"> | string | null
    createdAt?: DateTimeFilter<"SocialNetwork"> | Date | string
    updatedAt?: DateTimeFilter<"SocialNetwork"> | Date | string
  }, "id">

  export type SocialNetworkOrderByWithAggregationInput = {
    id?: SortOrder
    facebookLink?: SortOrder
    twitterLink?: SortOrder
    linkedinLink?: SortOrder
    instagramLink?: SortOrder
    youtubeLink?: SortOrder
    dribbleLink?: SortOrder
    whatsappNumber?: SortOrder
    telegramLink?: SortOrder
    snapchatLink?: SortOrder
    tiktokLink?: SortOrder
    threadsLink?: SortOrder
    pinterestLink?: SortOrder
    redditLink?: SortOrder
    githubLink?: SortOrder
    websiteLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialNetworkCountOrderByAggregateInput
    _max?: SocialNetworkMaxOrderByAggregateInput
    _min?: SocialNetworkMinOrderByAggregateInput
  }

  export type SocialNetworkScalarWhereWithAggregatesInput = {
    AND?: SocialNetworkScalarWhereWithAggregatesInput | SocialNetworkScalarWhereWithAggregatesInput[]
    OR?: SocialNetworkScalarWhereWithAggregatesInput[]
    NOT?: SocialNetworkScalarWhereWithAggregatesInput | SocialNetworkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialNetwork"> | string
    facebookLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    twitterLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    linkedinLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    instagramLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    youtubeLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    dribbleLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    whatsappNumber?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    telegramLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    snapchatLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    tiktokLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    threadsLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    pinterestLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    redditLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    githubLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    websiteLink?: StringNullableWithAggregatesFilter<"SocialNetwork"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SocialNetwork"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialNetwork"> | Date | string
  }

  export type SiteConfigurationWhereInput = {
    AND?: SiteConfigurationWhereInput | SiteConfigurationWhereInput[]
    OR?: SiteConfigurationWhereInput[]
    NOT?: SiteConfigurationWhereInput | SiteConfigurationWhereInput[]
    id?: StringFilter<"SiteConfiguration"> | string
    name?: StringFilter<"SiteConfiguration"> | string
    shortDescription?: StringFilter<"SiteConfiguration"> | string
    longDescription?: StringNullableFilter<"SiteConfiguration"> | string | null
    copyRights?: StringFilter<"SiteConfiguration"> | string
    logo?: StringFilter<"SiteConfiguration"> | string
    logoPublicId?: StringNullableFilter<"SiteConfiguration"> | string | null
    favicon?: StringFilter<"SiteConfiguration"> | string
    faviconPublicId?: StringNullableFilter<"SiteConfiguration"> | string | null
    createdAt?: DateTimeFilter<"SiteConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfiguration"> | Date | string
  }

  export type SiteConfigurationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    copyRights?: SortOrder
    logo?: SortOrder
    logoPublicId?: SortOrder
    favicon?: SortOrder
    faviconPublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigurationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SiteConfigurationWhereInput | SiteConfigurationWhereInput[]
    OR?: SiteConfigurationWhereInput[]
    NOT?: SiteConfigurationWhereInput | SiteConfigurationWhereInput[]
    name?: StringFilter<"SiteConfiguration"> | string
    shortDescription?: StringFilter<"SiteConfiguration"> | string
    longDescription?: StringNullableFilter<"SiteConfiguration"> | string | null
    copyRights?: StringFilter<"SiteConfiguration"> | string
    logo?: StringFilter<"SiteConfiguration"> | string
    logoPublicId?: StringNullableFilter<"SiteConfiguration"> | string | null
    favicon?: StringFilter<"SiteConfiguration"> | string
    faviconPublicId?: StringNullableFilter<"SiteConfiguration"> | string | null
    createdAt?: DateTimeFilter<"SiteConfiguration"> | Date | string
    updatedAt?: DateTimeFilter<"SiteConfiguration"> | Date | string
  }, "id">

  export type SiteConfigurationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    copyRights?: SortOrder
    logo?: SortOrder
    logoPublicId?: SortOrder
    favicon?: SortOrder
    faviconPublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteConfigurationCountOrderByAggregateInput
    _max?: SiteConfigurationMaxOrderByAggregateInput
    _min?: SiteConfigurationMinOrderByAggregateInput
  }

  export type SiteConfigurationScalarWhereWithAggregatesInput = {
    AND?: SiteConfigurationScalarWhereWithAggregatesInput | SiteConfigurationScalarWhereWithAggregatesInput[]
    OR?: SiteConfigurationScalarWhereWithAggregatesInput[]
    NOT?: SiteConfigurationScalarWhereWithAggregatesInput | SiteConfigurationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SiteConfiguration"> | string
    name?: StringWithAggregatesFilter<"SiteConfiguration"> | string
    shortDescription?: StringWithAggregatesFilter<"SiteConfiguration"> | string
    longDescription?: StringNullableWithAggregatesFilter<"SiteConfiguration"> | string | null
    copyRights?: StringWithAggregatesFilter<"SiteConfiguration"> | string
    logo?: StringWithAggregatesFilter<"SiteConfiguration"> | string
    logoPublicId?: StringNullableWithAggregatesFilter<"SiteConfiguration"> | string | null
    favicon?: StringWithAggregatesFilter<"SiteConfiguration"> | string
    faviconPublicId?: StringNullableWithAggregatesFilter<"SiteConfiguration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SiteConfiguration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteConfiguration"> | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePackageCreateInput = {
    id?: string
    name: string
    roleName: $Enums.RoleName
    price: number
    durationDays: number
    features?: RolePackageCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleCreateNestedManyWithoutRolePackageInput
  }

  export type RolePackageUncheckedCreateInput = {
    id?: string
    name: string
    roleName: $Enums.RoleName
    price: number
    durationDays: number
    features?: RolePackageCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutRolePackageInput
  }

  export type RolePackageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    price?: FloatFieldUpdateOperationsInput | number
    durationDays?: IntFieldUpdateOperationsInput | number
    features?: RolePackageUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUpdateManyWithoutRolePackageNestedInput
  }

  export type RolePackageUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    price?: FloatFieldUpdateOperationsInput | number
    durationDays?: IntFieldUpdateOperationsInput | number
    features?: RolePackageUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRoles?: UserRoleUncheckedUpdateManyWithoutRolePackageNestedInput
  }

  export type RolePackageCreateManyInput = {
    id?: string
    name: string
    roleName: $Enums.RoleName
    price: number
    durationDays: number
    features?: RolePackageCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePackageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    price?: FloatFieldUpdateOperationsInput | number
    durationDays?: IntFieldUpdateOperationsInput | number
    features?: RolePackageUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePackageUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    price?: FloatFieldUpdateOperationsInput | number
    durationDays?: IntFieldUpdateOperationsInput | number
    features?: RolePackageUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
  }

  export type UserUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
  }

  export type UserRoleCreateInput = {
    id?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    rolePackage: RolePackageCreateNestedOneWithoutUserRolesInput
    transactions?: TransactionCreateNestedManyWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: string
    userId: string
    rolePackageId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserRoleInput
  }

  export type UserRoleUpdateInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    rolePackage?: RolePackageUpdateOneRequiredWithoutUserRolesNestedInput
    transactions?: TransactionUpdateManyWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rolePackageId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserRoleNestedInput
  }

  export type UserRoleCreateManyInput = {
    id?: string
    userId: string
    rolePackageId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateManyMutationInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rolePackageId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    userRole: UserRoleCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    userRoleId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    userRole?: UserRoleUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userRoleId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    userRoleId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userRoleId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    deviceInfo: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    deviceInfo: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    deviceInfo: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    targetUser: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    reviewerId: string
    targetUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    targetUser?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    reviewerId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    reviewerId: string
    targetUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    reviewerId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerCreateInput = {
    id?: string
    title: string
    description: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerCreateManyInput = {
    id?: string
    title: string
    description: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HeroBannerUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HeroBannerUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTrendsCreateInput = {
    id?: string
    name: string
    price: number
    day: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketTrendsUncheckedCreateInput = {
    id?: string
    name: string
    price: number
    day: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketTrendsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    day?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTrendsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    day?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTrendsCreateManyInput = {
    id?: string
    name: string
    price: number
    day: number
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketTrendsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    day?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketTrendsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    day?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MortageToolsCreateInput = {
    id?: string
    name: string
    description: string
    ctaName: string
    ctaLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MortageToolsUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    ctaName: string
    ctaLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MortageToolsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ctaName?: StringFieldUpdateOperationsInput | string
    ctaLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MortageToolsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ctaName?: StringFieldUpdateOperationsInput | string
    ctaLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MortageToolsCreateManyInput = {
    id?: string
    name: string
    description: string
    ctaName: string
    ctaLink: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MortageToolsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ctaName?: StringFieldUpdateOperationsInput | string
    ctaLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MortageToolsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ctaName?: StringFieldUpdateOperationsInput | string
    ctaLink?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivacyPolicyUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivacyPolicyUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsOfUseCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsOfUseUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsOfUseUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsOfUseUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsOfUseCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TermsOfUseUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TermsOfUseUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyingGuidesCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyingGuidesUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyingGuidesUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyingGuidesUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyingGuidesCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuyingGuidesUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuyingGuidesUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingTipsCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingTipsUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingTipsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingTipsUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingTipsCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellingTipsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellingTipsUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketInsightsCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketInsightsUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketInsightsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketInsightsUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketInsightsCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketInsightsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketInsightsUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketAnalysisCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketAnalysisUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketAnalysisUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketAnalysisUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketAnalysisCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketAnalysisUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketAnalysisUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PressCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PressUncheckedCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PressUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PressUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PressCreateManyInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PressUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PressUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateInput = {
    id?: string
    title: string
    slug: string
    shortDescription: string
    longDescription: string
    image: string
    imagePublicId?: string | null
    category: string
    categorySlug: string
    tags?: BlogCreatetagsInput | string[]
    location?: string | null
    isFeatured?: boolean
    authorName: string
    authorImage: string
    authorImagePublicId?: string | null
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    shortDescription: string
    longDescription: string
    image: string
    imagePublicId?: string | null
    category: string
    categorySlug: string
    tags?: BlogCreatetagsInput | string[]
    location?: string | null
    isFeatured?: boolean
    authorName: string
    authorImage: string
    authorImagePublicId?: string | null
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    authorImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    authorImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogCreateManyInput = {
    id?: string
    title: string
    slug: string
    shortDescription: string
    longDescription: string
    image: string
    imagePublicId?: string | null
    category: string
    categorySlug: string
    tags?: BlogCreatetagsInput | string[]
    location?: string | null
    isFeatured?: boolean
    authorName: string
    authorImage: string
    authorImagePublicId?: string | null
    views?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    authorImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    categorySlug?: StringFieldUpdateOperationsInput | string
    tags?: BlogUpdatetagsInput | string[]
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: StringFieldUpdateOperationsInput | string
    authorImage?: StringFieldUpdateOperationsInput | string
    authorImagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailConfigurationCreateInput = {
    id?: string
    emailMailer: string
    emailHost: string
    emailPort: number
    emailUserName: string
    emailPassword: string
    emailEncryption: string
    emailFromName: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailConfigurationUncheckedCreateInput = {
    id?: string
    emailMailer: string
    emailHost: string
    emailPort: number
    emailUserName: string
    emailPassword: string
    emailEncryption: string
    emailFromName: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailConfigurationUpdateInput = {
    emailMailer?: StringFieldUpdateOperationsInput | string
    emailHost?: StringFieldUpdateOperationsInput | string
    emailPort?: IntFieldUpdateOperationsInput | number
    emailUserName?: StringFieldUpdateOperationsInput | string
    emailPassword?: StringFieldUpdateOperationsInput | string
    emailEncryption?: StringFieldUpdateOperationsInput | string
    emailFromName?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailConfigurationUncheckedUpdateInput = {
    emailMailer?: StringFieldUpdateOperationsInput | string
    emailHost?: StringFieldUpdateOperationsInput | string
    emailPort?: IntFieldUpdateOperationsInput | number
    emailUserName?: StringFieldUpdateOperationsInput | string
    emailPassword?: StringFieldUpdateOperationsInput | string
    emailEncryption?: StringFieldUpdateOperationsInput | string
    emailFromName?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailConfigurationCreateManyInput = {
    id?: string
    emailMailer: string
    emailHost: string
    emailPort: number
    emailUserName: string
    emailPassword: string
    emailEncryption: string
    emailFromName: string
    emailAddress: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailConfigurationUpdateManyMutationInput = {
    emailMailer?: StringFieldUpdateOperationsInput | string
    emailHost?: StringFieldUpdateOperationsInput | string
    emailPort?: IntFieldUpdateOperationsInput | number
    emailUserName?: StringFieldUpdateOperationsInput | string
    emailPassword?: StringFieldUpdateOperationsInput | string
    emailEncryption?: StringFieldUpdateOperationsInput | string
    emailFromName?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailConfigurationUncheckedUpdateManyInput = {
    emailMailer?: StringFieldUpdateOperationsInput | string
    emailHost?: StringFieldUpdateOperationsInput | string
    emailPort?: IntFieldUpdateOperationsInput | number
    emailUserName?: StringFieldUpdateOperationsInput | string
    emailPassword?: StringFieldUpdateOperationsInput | string
    emailEncryption?: StringFieldUpdateOperationsInput | string
    emailFromName?: StringFieldUpdateOperationsInput | string
    emailAddress?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConfigurationCreateInput = {
    id?: string
    stripeKey: string
    stripeSecret: string
    stripeMethod: string
    stripeWebhookSecret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeConfigurationUncheckedCreateInput = {
    id?: string
    stripeKey: string
    stripeSecret: string
    stripeMethod: string
    stripeWebhookSecret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeConfigurationUpdateInput = {
    stripeKey?: StringFieldUpdateOperationsInput | string
    stripeSecret?: StringFieldUpdateOperationsInput | string
    stripeMethod?: StringFieldUpdateOperationsInput | string
    stripeWebhookSecret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConfigurationUncheckedUpdateInput = {
    stripeKey?: StringFieldUpdateOperationsInput | string
    stripeSecret?: StringFieldUpdateOperationsInput | string
    stripeMethod?: StringFieldUpdateOperationsInput | string
    stripeWebhookSecret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConfigurationCreateManyInput = {
    id?: string
    stripeKey: string
    stripeSecret: string
    stripeMethod: string
    stripeWebhookSecret: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeConfigurationUpdateManyMutationInput = {
    stripeKey?: StringFieldUpdateOperationsInput | string
    stripeSecret?: StringFieldUpdateOperationsInput | string
    stripeMethod?: StringFieldUpdateOperationsInput | string
    stripeWebhookSecret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeConfigurationUncheckedUpdateManyInput = {
    stripeKey?: StringFieldUpdateOperationsInput | string
    stripeSecret?: StringFieldUpdateOperationsInput | string
    stripeMethod?: StringFieldUpdateOperationsInput | string
    stripeWebhookSecret?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellPageBannerCreateInput = {
    id?: string
    title: string
    description: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellPageBannerUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellPageBannerUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellPageBannerUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellPageBannerCreateManyInput = {
    id?: string
    title: string
    description: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellPageBannerUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellPageBannerUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellTypesCreateInput = {
    id?: string
    title: string
    description: string
    items?: InputJsonValue | null
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellTypesUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    items?: InputJsonValue | null
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellTypesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    items?: InputJsonValue | InputJsonValue | null
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellTypesUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    items?: InputJsonValue | InputJsonValue | null
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellTypesCreateManyInput = {
    id?: string
    title: string
    description: string
    items?: InputJsonValue | null
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellTypesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    items?: InputJsonValue | InputJsonValue | null
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellTypesUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    items?: InputJsonValue | InputJsonValue | null
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerResourcesCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    imagePublicId?: string | null
    items?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerResourcesUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    imagePublicId?: string | null
    items?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerResourcesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerResourcesUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerResourcesCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    imagePublicId?: string | null
    items?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SellerResourcesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SellerResourcesUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    items?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevelopmentPlatformCreateInput = {
    id?: string
    title: string
    description: string
    iosLink: string
    androidLink: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevelopmentPlatformUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    iosLink: string
    androidLink: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevelopmentPlatformUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iosLink?: StringFieldUpdateOperationsInput | string
    androidLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevelopmentPlatformUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iosLink?: StringFieldUpdateOperationsInput | string
    androidLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevelopmentPlatformCreateManyInput = {
    id?: string
    title: string
    description: string
    iosLink: string
    androidLink: string
    image: string
    imagePublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DevelopmentPlatformUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iosLink?: StringFieldUpdateOperationsInput | string
    androidLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DevelopmentPlatformUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    iosLink?: StringFieldUpdateOperationsInput | string
    androidLink?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    imagePublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyInput
    Bookmark?: BookmarkCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Bookmark?: BookmarkUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookmark?: BookmarkUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookmarkInput
    property: PropertyCreateNestedOneWithoutBookmarkInput
  }

  export type BookmarkUncheckedCreateInput = {
    id?: string
    userId: string
    propertyId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarkNestedInput
    property?: PropertyUpdateOneRequiredWithoutBookmarkNestedInput
  }

  export type BookmarkUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateManyInput = {
    id?: string
    userId: string
    propertyId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewCreateInput = {
    id?: string
    viewedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyViewInput
    property: PropertyCreateNestedOneWithoutPropertyViewInput
  }

  export type PropertyViewUncheckedCreateInput = {
    id?: string
    userId: string
    propertyId: string
    viewedAt?: Date | string
  }

  export type PropertyViewUpdateInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyViewNestedInput
    property?: PropertyUpdateOneRequiredWithoutPropertyViewNestedInput
  }

  export type PropertyViewUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewCreateManyInput = {
    id?: string
    userId: string
    propertyId: string
    viewedAt?: Date | string
  }

  export type PropertyViewUpdateManyMutationInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestCreateInput = {
    id?: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPropertyTourRequestInput
    property: PropertyCreateNestedOneWithoutPropertyTourRequestInput
  }

  export type PropertyTourRequestUncheckedCreateInput = {
    id?: string
    userId: string
    propertyId: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyTourRequestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPropertyTourRequestNestedInput
    property?: PropertyUpdateOneRequiredWithoutPropertyTourRequestNestedInput
  }

  export type PropertyTourRequestUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestCreateManyInput = {
    id?: string
    userId: string
    propertyId: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyTourRequestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestCreateInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPropertyContactUserRequestInput
    property: PropertyCreateNestedOneWithoutPropertyContactUserRequestInput
  }

  export type PropertyContactUserRequestUncheckedCreateInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    userId: string
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyContactUserRequestUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPropertyContactUserRequestNestedInput
    property?: PropertyUpdateOneRequiredWithoutPropertyContactUserRequestNestedInput
  }

  export type PropertyContactUserRequestUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestCreateManyInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    userId: string
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyContactUserRequestUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUserCreateInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
  }

  export type ContactUserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
  }

  export type ContactUserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUserCreateManyInput = {
    id?: string
    name: string
    email: string
    subject: string
    message: string
    createdAt?: Date | string
  }

  export type ContactUserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GetEstimateCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string
  }

  export type GetEstimateUncheckedCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string
  }

  export type GetEstimateUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GetEstimateUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GetEstimateCreateManyInput = {
    id?: string
    email: string
    createdAt?: Date | string
  }

  export type GetEstimateUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GetEstimateUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqsCreateInput = {
    id?: string
    question: string
    slug: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaqsUncheckedCreateInput = {
    id?: string
    question: string
    slug: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaqsUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqsUncheckedUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqsCreateManyInput = {
    id?: string
    question: string
    slug: string
    answer: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FaqsUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FaqsUncheckedUpdateManyInput = {
    question?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInformationCreateInput = {
    id?: string
    email: string
    email2?: string | null
    phone: string
    phone2?: string | null
    address: string
    address2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInformationUncheckedCreateInput = {
    id?: string
    email: string
    email2?: string | null
    phone: string
    phone2?: string | null
    address: string
    address2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInformationUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    email2?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInformationUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    email2?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInformationCreateManyInput = {
    id?: string
    email: string
    email2?: string | null
    phone: string
    phone2?: string | null
    address: string
    address2?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactInformationUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    email2?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactInformationUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    email2?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    phone2?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    address2?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialNetworkCreateInput = {
    id?: string
    facebookLink?: string | null
    twitterLink?: string | null
    linkedinLink?: string | null
    instagramLink?: string | null
    youtubeLink?: string | null
    dribbleLink?: string | null
    whatsappNumber?: string | null
    telegramLink?: string | null
    snapchatLink?: string | null
    tiktokLink?: string | null
    threadsLink?: string | null
    pinterestLink?: string | null
    redditLink?: string | null
    githubLink?: string | null
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialNetworkUncheckedCreateInput = {
    id?: string
    facebookLink?: string | null
    twitterLink?: string | null
    linkedinLink?: string | null
    instagramLink?: string | null
    youtubeLink?: string | null
    dribbleLink?: string | null
    whatsappNumber?: string | null
    telegramLink?: string | null
    snapchatLink?: string | null
    tiktokLink?: string | null
    threadsLink?: string | null
    pinterestLink?: string | null
    redditLink?: string | null
    githubLink?: string | null
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialNetworkUpdateInput = {
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitterLink?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    dribbleLink?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramLink?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatLink?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokLink?: NullableStringFieldUpdateOperationsInput | string | null
    threadsLink?: NullableStringFieldUpdateOperationsInput | string | null
    pinterestLink?: NullableStringFieldUpdateOperationsInput | string | null
    redditLink?: NullableStringFieldUpdateOperationsInput | string | null
    githubLink?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialNetworkUncheckedUpdateInput = {
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitterLink?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    dribbleLink?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramLink?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatLink?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokLink?: NullableStringFieldUpdateOperationsInput | string | null
    threadsLink?: NullableStringFieldUpdateOperationsInput | string | null
    pinterestLink?: NullableStringFieldUpdateOperationsInput | string | null
    redditLink?: NullableStringFieldUpdateOperationsInput | string | null
    githubLink?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialNetworkCreateManyInput = {
    id?: string
    facebookLink?: string | null
    twitterLink?: string | null
    linkedinLink?: string | null
    instagramLink?: string | null
    youtubeLink?: string | null
    dribbleLink?: string | null
    whatsappNumber?: string | null
    telegramLink?: string | null
    snapchatLink?: string | null
    tiktokLink?: string | null
    threadsLink?: string | null
    pinterestLink?: string | null
    redditLink?: string | null
    githubLink?: string | null
    websiteLink?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialNetworkUpdateManyMutationInput = {
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitterLink?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    dribbleLink?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramLink?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatLink?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokLink?: NullableStringFieldUpdateOperationsInput | string | null
    threadsLink?: NullableStringFieldUpdateOperationsInput | string | null
    pinterestLink?: NullableStringFieldUpdateOperationsInput | string | null
    redditLink?: NullableStringFieldUpdateOperationsInput | string | null
    githubLink?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialNetworkUncheckedUpdateManyInput = {
    facebookLink?: NullableStringFieldUpdateOperationsInput | string | null
    twitterLink?: NullableStringFieldUpdateOperationsInput | string | null
    linkedinLink?: NullableStringFieldUpdateOperationsInput | string | null
    instagramLink?: NullableStringFieldUpdateOperationsInput | string | null
    youtubeLink?: NullableStringFieldUpdateOperationsInput | string | null
    dribbleLink?: NullableStringFieldUpdateOperationsInput | string | null
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    telegramLink?: NullableStringFieldUpdateOperationsInput | string | null
    snapchatLink?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokLink?: NullableStringFieldUpdateOperationsInput | string | null
    threadsLink?: NullableStringFieldUpdateOperationsInput | string | null
    pinterestLink?: NullableStringFieldUpdateOperationsInput | string | null
    redditLink?: NullableStringFieldUpdateOperationsInput | string | null
    githubLink?: NullableStringFieldUpdateOperationsInput | string | null
    websiteLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigurationCreateInput = {
    id?: string
    name: string
    shortDescription: string
    longDescription?: string | null
    copyRights: string
    logo: string
    logoPublicId?: string | null
    favicon: string
    faviconPublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigurationUncheckedCreateInput = {
    id?: string
    name: string
    shortDescription: string
    longDescription?: string | null
    copyRights: string
    logo: string
    logoPublicId?: string | null
    favicon: string
    faviconPublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigurationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    copyRights?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    logoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: StringFieldUpdateOperationsInput | string
    faviconPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigurationUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    copyRights?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    logoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: StringFieldUpdateOperationsInput | string
    faviconPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigurationCreateManyInput = {
    id?: string
    name: string
    shortDescription: string
    longDescription?: string | null
    copyRights: string
    logo: string
    logoPublicId?: string | null
    favicon: string
    faviconPublicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteConfigurationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    copyRights?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    logoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: StringFieldUpdateOperationsInput | string
    faviconPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteConfigurationUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortDescription?: StringFieldUpdateOperationsInput | string
    longDescription?: NullableStringFieldUpdateOperationsInput | string | null
    copyRights?: StringFieldUpdateOperationsInput | string
    logo?: StringFieldUpdateOperationsInput | string
    logoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: StringFieldUpdateOperationsInput | string
    faviconPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    link?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolePackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    roleName?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePackageAvgOrderByAggregateInput = {
    price?: SortOrder
    durationDays?: SortOrder
  }

  export type RolePackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    roleName?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    roleName?: SortOrder
    price?: SortOrder
    durationDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RolePackageSumOrderByAggregateInput = {
    price?: SortOrder
    durationDays?: SortOrder
  }

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type BookmarkListRelationFilter = {
    every?: BookmarkWhereInput
    some?: BookmarkWhereInput
    none?: BookmarkWhereInput
  }

  export type PropertyViewListRelationFilter = {
    every?: PropertyViewWhereInput
    some?: PropertyViewWhereInput
    none?: PropertyViewWhereInput
  }

  export type PropertyTourRequestListRelationFilter = {
    every?: PropertyTourRequestWhereInput
    some?: PropertyTourRequestWhereInput
    none?: PropertyTourRequestWhereInput
  }

  export type PropertyContactUserRequestListRelationFilter = {
    every?: PropertyContactUserRequestWhereInput
    some?: PropertyContactUserRequestWhereInput
    none?: PropertyContactUserRequestWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyTourRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyContactUserRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    avatarPublicId?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    previousRole?: SortOrder
    role?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    resetCode?: SortOrder
    resetCodeExpiration?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    isNotificationEnabled?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorTempToken?: SortOrder
    twoFactorTempExp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reputationScore?: SortOrder
    reputationHistory?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    reputationScore?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    avatarPublicId?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    previousRole?: SortOrder
    role?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    resetCode?: SortOrder
    resetCodeExpiration?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    isNotificationEnabled?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorTempToken?: SortOrder
    twoFactorTempExp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reputationScore?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    avatarPublicId?: SortOrder
    phone?: SortOrder
    bio?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    previousRole?: SortOrder
    role?: SortOrder
    isAdmin?: SortOrder
    status?: SortOrder
    resetCode?: SortOrder
    resetCodeExpiration?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    isNotificationEnabled?: SortOrder
    isTwoFactorEnabled?: SortOrder
    twoFactorTempToken?: SortOrder
    twoFactorTempExp?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reputationScore?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    reputationScore?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type RolePackageScalarRelationFilter = {
    is?: RolePackageWhereInput
    isNot?: RolePackageWhereInput
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rolePackageId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPaused?: SortOrder
    isExpired?: SortOrder
    message?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rolePackageId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPaused?: SortOrder
    isExpired?: SortOrder
    message?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rolePackageId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    isPaused?: SortOrder
    isExpired?: SortOrder
    message?: SortOrder
    isVerified?: SortOrder
    verifiedAt?: SortOrder
    verifiedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleScalarRelationFilter = {
    is?: UserRoleWhereInput
    isNot?: UserRoleWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userRoleId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    stripeId?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userRoleId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    stripeId?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userRoleId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    stripeId?: SortOrder
    invoiceUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    isActive?: SortOrder
    lastUsedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewReviewerIdTargetUserIdCompoundUniqueInput = {
    reviewerId: string
    targetUserId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    reviewerId?: SortOrder
    targetUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewerId?: SortOrder
    targetUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    reviewerId?: SortOrder
    targetUserId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type HeroBannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HeroBannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketTrendsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    day?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketTrendsAvgOrderByAggregateInput = {
    price?: SortOrder
    day?: SortOrder
  }

  export type MarketTrendsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    day?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketTrendsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    day?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketTrendsSumOrderByAggregateInput = {
    price?: SortOrder
    day?: SortOrder
  }

  export type MortageToolsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ctaName?: SortOrder
    ctaLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MortageToolsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ctaName?: SortOrder
    ctaLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MortageToolsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ctaName?: SortOrder
    ctaLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivacyPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsOfUseCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsOfUseMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TermsOfUseMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuyingGuidesCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuyingGuidesMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuyingGuidesMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingTipsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingTipsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellingTipsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketInsightsCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketInsightsMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketInsightsMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PressCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PressMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PressMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    category?: SortOrder
    categorySlug?: SortOrder
    tags?: SortOrder
    location?: SortOrder
    isFeatured?: SortOrder
    authorName?: SortOrder
    authorImage?: SortOrder
    authorImagePublicId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type BlogMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    category?: SortOrder
    categorySlug?: SortOrder
    location?: SortOrder
    isFeatured?: SortOrder
    authorName?: SortOrder
    authorImage?: SortOrder
    authorImagePublicId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    category?: SortOrder
    categorySlug?: SortOrder
    location?: SortOrder
    isFeatured?: SortOrder
    authorName?: SortOrder
    authorImage?: SortOrder
    authorImagePublicId?: SortOrder
    views?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type EmailConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    emailMailer?: SortOrder
    emailHost?: SortOrder
    emailPort?: SortOrder
    emailUserName?: SortOrder
    emailPassword?: SortOrder
    emailEncryption?: SortOrder
    emailFromName?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailConfigurationAvgOrderByAggregateInput = {
    emailPort?: SortOrder
  }

  export type EmailConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    emailMailer?: SortOrder
    emailHost?: SortOrder
    emailPort?: SortOrder
    emailUserName?: SortOrder
    emailPassword?: SortOrder
    emailEncryption?: SortOrder
    emailFromName?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    emailMailer?: SortOrder
    emailHost?: SortOrder
    emailPort?: SortOrder
    emailUserName?: SortOrder
    emailPassword?: SortOrder
    emailEncryption?: SortOrder
    emailFromName?: SortOrder
    emailAddress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailConfigurationSumOrderByAggregateInput = {
    emailPort?: SortOrder
  }

  export type StripeConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    stripeKey?: SortOrder
    stripeSecret?: SortOrder
    stripeMethod?: SortOrder
    stripeWebhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    stripeKey?: SortOrder
    stripeSecret?: SortOrder
    stripeMethod?: SortOrder
    stripeWebhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    stripeKey?: SortOrder
    stripeSecret?: SortOrder
    stripeMethod?: SortOrder
    stripeWebhookSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellPageBannerCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellPageBannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellPageBannerMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellTypesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    items?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellTypesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerResourcesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    items?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerResourcesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SellerResourcesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevelopmentPlatformCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iosLink?: SortOrder
    androidLink?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevelopmentPlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iosLink?: SortOrder
    androidLink?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DevelopmentPlatformMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    iosLink?: SortOrder
    androidLink?: SortOrder
    image?: SortOrder
    imagePublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type EnumPropertyCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryFilter<$PrismaModel> | $Enums.PropertyCategory
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type EnumListingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingStatusNullableFilter<$PrismaModel> | $Enums.ListingStatus | null
    isSet?: boolean
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    neighborhood?: SortOrder
    views?: SortOrder
    type?: SortOrder
    property?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    leaseLength?: SortOrder
    furnished?: SortOrder
    deposit?: SortOrder
    moveInDate?: SortOrder
    amenities?: SortOrder
    garage?: SortOrder
    basement?: SortOrder
    fireplace?: SortOrder
    pool?: SortOrder
    pet?: SortOrder
    utilities?: SortOrder
    income?: SortOrder
    school?: SortOrder
    bus?: SortOrder
    restaurant?: SortOrder
    images?: SortOrder
    description?: SortOrder
    listingStatus?: SortOrder
    listingType?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userAvatar?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    reportedBy?: SortOrder
    flagReason?: SortOrder
    flagStatus?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    price?: SortOrder
    views?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    deposit?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    neighborhood?: SortOrder
    views?: SortOrder
    type?: SortOrder
    property?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    leaseLength?: SortOrder
    furnished?: SortOrder
    deposit?: SortOrder
    moveInDate?: SortOrder
    garage?: SortOrder
    basement?: SortOrder
    fireplace?: SortOrder
    pool?: SortOrder
    pet?: SortOrder
    utilities?: SortOrder
    income?: SortOrder
    school?: SortOrder
    bus?: SortOrder
    restaurant?: SortOrder
    description?: SortOrder
    listingStatus?: SortOrder
    listingType?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userAvatar?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    flagStatus?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    price?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    neighborhood?: SortOrder
    views?: SortOrder
    type?: SortOrder
    property?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    leaseLength?: SortOrder
    furnished?: SortOrder
    deposit?: SortOrder
    moveInDate?: SortOrder
    garage?: SortOrder
    basement?: SortOrder
    fireplace?: SortOrder
    pool?: SortOrder
    pet?: SortOrder
    utilities?: SortOrder
    income?: SortOrder
    school?: SortOrder
    bus?: SortOrder
    restaurant?: SortOrder
    description?: SortOrder
    listingStatus?: SortOrder
    listingType?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    userAvatar?: SortOrder
    userEmail?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    flagStatus?: SortOrder
    flaggedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    price?: SortOrder
    views?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    size?: SortOrder
    lotSize?: SortOrder
    yearBuilt?: SortOrder
    hoaFees?: SortOrder
    deposit?: SortOrder
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type EnumPropertyCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyCategoryFilter<$PrismaModel>
    _max?: NestedEnumPropertyCategoryFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumListingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumListingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumListingStatusNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type BookmarkUserIdPropertyIdCompoundUniqueInput = {
    userId: string
    propertyId: string
  }

  export type BookmarkCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyViewUserIdPropertyIdCompoundUniqueInput = {
    userId: string
    propertyId: string
  }

  export type PropertyViewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
  }

  export type PropertyViewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
  }

  export type PropertyViewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    viewedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PropertyTourRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    tourTimes?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyTourRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyTourRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PropertyContactUserRequestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyContactUserRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyContactUserRequestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactUserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type GetEstimateCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type GetEstimateMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type GetEstimateMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type FaqsCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FaqsMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FaqsMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
    slug?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInformationCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    email2?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    email2?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactInformationMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    email2?: SortOrder
    phone?: SortOrder
    phone2?: SortOrder
    address?: SortOrder
    address2?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialNetworkCountOrderByAggregateInput = {
    id?: SortOrder
    facebookLink?: SortOrder
    twitterLink?: SortOrder
    linkedinLink?: SortOrder
    instagramLink?: SortOrder
    youtubeLink?: SortOrder
    dribbleLink?: SortOrder
    whatsappNumber?: SortOrder
    telegramLink?: SortOrder
    snapchatLink?: SortOrder
    tiktokLink?: SortOrder
    threadsLink?: SortOrder
    pinterestLink?: SortOrder
    redditLink?: SortOrder
    githubLink?: SortOrder
    websiteLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialNetworkMaxOrderByAggregateInput = {
    id?: SortOrder
    facebookLink?: SortOrder
    twitterLink?: SortOrder
    linkedinLink?: SortOrder
    instagramLink?: SortOrder
    youtubeLink?: SortOrder
    dribbleLink?: SortOrder
    whatsappNumber?: SortOrder
    telegramLink?: SortOrder
    snapchatLink?: SortOrder
    tiktokLink?: SortOrder
    threadsLink?: SortOrder
    pinterestLink?: SortOrder
    redditLink?: SortOrder
    githubLink?: SortOrder
    websiteLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialNetworkMinOrderByAggregateInput = {
    id?: SortOrder
    facebookLink?: SortOrder
    twitterLink?: SortOrder
    linkedinLink?: SortOrder
    instagramLink?: SortOrder
    youtubeLink?: SortOrder
    dribbleLink?: SortOrder
    whatsappNumber?: SortOrder
    telegramLink?: SortOrder
    snapchatLink?: SortOrder
    tiktokLink?: SortOrder
    threadsLink?: SortOrder
    pinterestLink?: SortOrder
    redditLink?: SortOrder
    githubLink?: SortOrder
    websiteLink?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigurationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    copyRights?: SortOrder
    logo?: SortOrder
    logoPublicId?: SortOrder
    favicon?: SortOrder
    faviconPublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigurationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    copyRights?: SortOrder
    logo?: SortOrder
    logoPublicId?: SortOrder
    favicon?: SortOrder
    faviconPublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteConfigurationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortDescription?: SortOrder
    longDescription?: SortOrder
    copyRights?: SortOrder
    logo?: SortOrder
    logoPublicId?: SortOrder
    favicon?: SortOrder
    faviconPublicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type RolePackageCreatefeaturesInput = {
    set: string[]
  }

  export type UserRoleCreateNestedManyWithoutRolePackageInput = {
    create?: XOR<UserRoleCreateWithoutRolePackageInput, UserRoleUncheckedCreateWithoutRolePackageInput> | UserRoleCreateWithoutRolePackageInput[] | UserRoleUncheckedCreateWithoutRolePackageInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRolePackageInput | UserRoleCreateOrConnectWithoutRolePackageInput[]
    createMany?: UserRoleCreateManyRolePackageInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRolePackageInput = {
    create?: XOR<UserRoleCreateWithoutRolePackageInput, UserRoleUncheckedCreateWithoutRolePackageInput> | UserRoleCreateWithoutRolePackageInput[] | UserRoleUncheckedCreateWithoutRolePackageInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRolePackageInput | UserRoleCreateOrConnectWithoutRolePackageInput[]
    createMany?: UserRoleCreateManyRolePackageInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RolePackageUpdatefeaturesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserRoleUpdateManyWithoutRolePackageNestedInput = {
    create?: XOR<UserRoleCreateWithoutRolePackageInput, UserRoleUncheckedCreateWithoutRolePackageInput> | UserRoleCreateWithoutRolePackageInput[] | UserRoleUncheckedCreateWithoutRolePackageInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRolePackageInput | UserRoleCreateOrConnectWithoutRolePackageInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRolePackageInput | UserRoleUpsertWithWhereUniqueWithoutRolePackageInput[]
    createMany?: UserRoleCreateManyRolePackageInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRolePackageInput | UserRoleUpdateWithWhereUniqueWithoutRolePackageInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRolePackageInput | UserRoleUpdateManyWithWhereWithoutRolePackageInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRolePackageNestedInput = {
    create?: XOR<UserRoleCreateWithoutRolePackageInput, UserRoleUncheckedCreateWithoutRolePackageInput> | UserRoleCreateWithoutRolePackageInput[] | UserRoleUncheckedCreateWithoutRolePackageInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRolePackageInput | UserRoleCreateOrConnectWithoutRolePackageInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRolePackageInput | UserRoleUpsertWithWhereUniqueWithoutRolePackageInput[]
    createMany?: UserRoleCreateManyRolePackageInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRolePackageInput | UserRoleUpdateWithWhereUniqueWithoutRolePackageInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRolePackageInput | UserRoleUpdateManyWithWhereWithoutRolePackageInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PropertyCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type PropertyViewCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyTourRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyTourRequestCreateWithoutUserInput, PropertyTourRequestUncheckedCreateWithoutUserInput> | PropertyTourRequestCreateWithoutUserInput[] | PropertyTourRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutUserInput | PropertyTourRequestCreateOrConnectWithoutUserInput[]
    createMany?: PropertyTourRequestCreateManyUserInputEnvelope
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
  }

  export type PropertyContactUserRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutUserInput, PropertyContactUserRequestUncheckedCreateWithoutUserInput> | PropertyContactUserRequestCreateWithoutUserInput[] | PropertyContactUserRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutUserInput | PropertyContactUserRequestCreateOrConnectWithoutUserInput[]
    createMany?: PropertyContactUserRequestCreateManyUserInputEnvelope
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<ReviewCreateWithoutTargetUserInput, ReviewUncheckedCreateWithoutTargetUserInput> | ReviewCreateWithoutTargetUserInput[] | ReviewUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutTargetUserInput | ReviewCreateOrConnectWithoutTargetUserInput[]
    createMany?: ReviewCreateManyTargetUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyTourRequestCreateWithoutUserInput, PropertyTourRequestUncheckedCreateWithoutUserInput> | PropertyTourRequestCreateWithoutUserInput[] | PropertyTourRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutUserInput | PropertyTourRequestCreateOrConnectWithoutUserInput[]
    createMany?: PropertyTourRequestCreateManyUserInputEnvelope
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
  }

  export type PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutUserInput, PropertyContactUserRequestUncheckedCreateWithoutUserInput> | PropertyContactUserRequestCreateWithoutUserInput[] | PropertyContactUserRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutUserInput | PropertyContactUserRequestCreateOrConnectWithoutUserInput[]
    createMany?: PropertyContactUserRequestCreateManyUserInputEnvelope
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutTargetUserInput = {
    create?: XOR<ReviewCreateWithoutTargetUserInput, ReviewUncheckedCreateWithoutTargetUserInput> | ReviewCreateWithoutTargetUserInput[] | ReviewUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutTargetUserInput | ReviewCreateOrConnectWithoutTargetUserInput[]
    createMany?: ReviewCreateManyTargetUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PropertyUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BookmarkUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type PropertyViewUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutUserInput | PropertyViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutUserInput | PropertyViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutUserInput | PropertyViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyTourRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyTourRequestCreateWithoutUserInput, PropertyTourRequestUncheckedCreateWithoutUserInput> | PropertyTourRequestCreateWithoutUserInput[] | PropertyTourRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutUserInput | PropertyTourRequestCreateOrConnectWithoutUserInput[]
    upsert?: PropertyTourRequestUpsertWithWhereUniqueWithoutUserInput | PropertyTourRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyTourRequestCreateManyUserInputEnvelope
    set?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    disconnect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    delete?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    update?: PropertyTourRequestUpdateWithWhereUniqueWithoutUserInput | PropertyTourRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyTourRequestUpdateManyWithWhereWithoutUserInput | PropertyTourRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyTourRequestScalarWhereInput | PropertyTourRequestScalarWhereInput[]
  }

  export type PropertyContactUserRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutUserInput, PropertyContactUserRequestUncheckedCreateWithoutUserInput> | PropertyContactUserRequestCreateWithoutUserInput[] | PropertyContactUserRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutUserInput | PropertyContactUserRequestCreateOrConnectWithoutUserInput[]
    upsert?: PropertyContactUserRequestUpsertWithWhereUniqueWithoutUserInput | PropertyContactUserRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyContactUserRequestCreateManyUserInputEnvelope
    set?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    disconnect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    delete?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    update?: PropertyContactUserRequestUpdateWithWhereUniqueWithoutUserInput | PropertyContactUserRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyContactUserRequestUpdateManyWithWhereWithoutUserInput | PropertyContactUserRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyContactUserRequestScalarWhereInput | PropertyContactUserRequestScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutReviewerInput | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutReviewerInput | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutReviewerInput | ReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<ReviewCreateWithoutTargetUserInput, ReviewUncheckedCreateWithoutTargetUserInput> | ReviewCreateWithoutTargetUserInput[] | ReviewUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutTargetUserInput | ReviewCreateOrConnectWithoutTargetUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutTargetUserInput | ReviewUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: ReviewCreateManyTargetUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutTargetUserInput | ReviewUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutTargetUserInput | ReviewUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput> | PropertyCreateWithoutUserInput[] | PropertyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput | PropertyCreateOrConnectWithoutUserInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutUserInput | PropertyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyCreateManyUserInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutUserInput | PropertyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutUserInput | PropertyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type PropertyViewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput> | PropertyViewCreateWithoutUserInput[] | PropertyViewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutUserInput | PropertyViewCreateOrConnectWithoutUserInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutUserInput | PropertyViewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyViewCreateManyUserInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutUserInput | PropertyViewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutUserInput | PropertyViewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyTourRequestCreateWithoutUserInput, PropertyTourRequestUncheckedCreateWithoutUserInput> | PropertyTourRequestCreateWithoutUserInput[] | PropertyTourRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutUserInput | PropertyTourRequestCreateOrConnectWithoutUserInput[]
    upsert?: PropertyTourRequestUpsertWithWhereUniqueWithoutUserInput | PropertyTourRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyTourRequestCreateManyUserInputEnvelope
    set?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    disconnect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    delete?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    update?: PropertyTourRequestUpdateWithWhereUniqueWithoutUserInput | PropertyTourRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyTourRequestUpdateManyWithWhereWithoutUserInput | PropertyTourRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyTourRequestScalarWhereInput | PropertyTourRequestScalarWhereInput[]
  }

  export type PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutUserInput, PropertyContactUserRequestUncheckedCreateWithoutUserInput> | PropertyContactUserRequestCreateWithoutUserInput[] | PropertyContactUserRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutUserInput | PropertyContactUserRequestCreateOrConnectWithoutUserInput[]
    upsert?: PropertyContactUserRequestUpsertWithWhereUniqueWithoutUserInput | PropertyContactUserRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PropertyContactUserRequestCreateManyUserInputEnvelope
    set?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    disconnect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    delete?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    update?: PropertyContactUserRequestUpdateWithWhereUniqueWithoutUserInput | PropertyContactUserRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PropertyContactUserRequestUpdateManyWithWhereWithoutUserInput | PropertyContactUserRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PropertyContactUserRequestScalarWhereInput | PropertyContactUserRequestScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutReviewerInput | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutReviewerInput | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutReviewerInput | ReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutTargetUserNestedInput = {
    create?: XOR<ReviewCreateWithoutTargetUserInput, ReviewUncheckedCreateWithoutTargetUserInput> | ReviewCreateWithoutTargetUserInput[] | ReviewUncheckedCreateWithoutTargetUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutTargetUserInput | ReviewCreateOrConnectWithoutTargetUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutTargetUserInput | ReviewUpsertWithWhereUniqueWithoutTargetUserInput[]
    createMany?: ReviewCreateManyTargetUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutTargetUserInput | ReviewUpdateWithWhereUniqueWithoutTargetUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutTargetUserInput | ReviewUpdateManyWithWhereWithoutTargetUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RolePackageCreateNestedOneWithoutUserRolesInput = {
    create?: XOR<RolePackageCreateWithoutUserRolesInput, RolePackageUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RolePackageCreateOrConnectWithoutUserRolesInput
    connect?: RolePackageWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutUserRoleInput = {
    create?: XOR<TransactionCreateWithoutUserRoleInput, TransactionUncheckedCreateWithoutUserRoleInput> | TransactionCreateWithoutUserRoleInput[] | TransactionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserRoleInput | TransactionCreateOrConnectWithoutUserRoleInput[]
    createMany?: TransactionCreateManyUserRoleInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserRoleInput = {
    create?: XOR<TransactionCreateWithoutUserRoleInput, TransactionUncheckedCreateWithoutUserRoleInput> | TransactionCreateWithoutUserRoleInput[] | TransactionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserRoleInput | TransactionCreateOrConnectWithoutUserRoleInput[]
    createMany?: TransactionCreateManyUserRoleInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserRolesInput
    upsert?: UserUpsertWithoutUserRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserRolesInput, UserUpdateWithoutUserRolesInput>, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type RolePackageUpdateOneRequiredWithoutUserRolesNestedInput = {
    create?: XOR<RolePackageCreateWithoutUserRolesInput, RolePackageUncheckedCreateWithoutUserRolesInput>
    connectOrCreate?: RolePackageCreateOrConnectWithoutUserRolesInput
    upsert?: RolePackageUpsertWithoutUserRolesInput
    connect?: RolePackageWhereUniqueInput
    update?: XOR<XOR<RolePackageUpdateToOneWithWhereWithoutUserRolesInput, RolePackageUpdateWithoutUserRolesInput>, RolePackageUncheckedUpdateWithoutUserRolesInput>
  }

  export type TransactionUpdateManyWithoutUserRoleNestedInput = {
    create?: XOR<TransactionCreateWithoutUserRoleInput, TransactionUncheckedCreateWithoutUserRoleInput> | TransactionCreateWithoutUserRoleInput[] | TransactionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserRoleInput | TransactionCreateOrConnectWithoutUserRoleInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserRoleInput | TransactionUpsertWithWhereUniqueWithoutUserRoleInput[]
    createMany?: TransactionCreateManyUserRoleInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserRoleInput | TransactionUpdateWithWhereUniqueWithoutUserRoleInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserRoleInput | TransactionUpdateManyWithWhereWithoutUserRoleInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserRoleNestedInput = {
    create?: XOR<TransactionCreateWithoutUserRoleInput, TransactionUncheckedCreateWithoutUserRoleInput> | TransactionCreateWithoutUserRoleInput[] | TransactionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserRoleInput | TransactionCreateOrConnectWithoutUserRoleInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserRoleInput | TransactionUpsertWithWhereUniqueWithoutUserRoleInput[]
    createMany?: TransactionCreateManyUserRoleInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserRoleInput | TransactionUpdateWithWhereUniqueWithoutUserRoleInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserRoleInput | TransactionUpdateManyWithWhereWithoutUserRoleInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserRoleCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserRoleCreateWithoutTransactionsInput, UserRoleUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutTransactionsInput
    connect?: UserRoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserRoleUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserRoleCreateWithoutTransactionsInput, UserRoleUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutTransactionsInput
    upsert?: UserRoleUpsertWithoutTransactionsInput
    connect?: UserRoleWhereUniqueInput
    update?: XOR<XOR<UserRoleUpdateToOneWithWhereWithoutTransactionsInput, UserRoleUpdateWithoutTransactionsInput>, UserRoleUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutReviewsGivenInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsReceivedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    upsert?: UserUpsertWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsGivenInput, UserUpdateWithoutReviewsGivenInput>, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    upsert?: UserUpsertWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsReceivedInput, UserUpdateWithoutReviewsReceivedInput>, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type BlogCreatetagsInput = {
    set: string[]
  }

  export type BlogUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PropertyCreateamenitiesInput = {
    set: string[]
  }

  export type PropertyCreatereportedByInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutPropertyInput = {
    create?: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput
    connect?: UserWhereUniqueInput
  }

  export type BookmarkCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BookmarkCreateWithoutPropertyInput, BookmarkUncheckedCreateWithoutPropertyInput> | BookmarkCreateWithoutPropertyInput[] | BookmarkUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPropertyInput | BookmarkCreateOrConnectWithoutPropertyInput[]
    createMany?: BookmarkCreateManyPropertyInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type PropertyViewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyTourRequestCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyTourRequestCreateWithoutPropertyInput, PropertyTourRequestUncheckedCreateWithoutPropertyInput> | PropertyTourRequestCreateWithoutPropertyInput[] | PropertyTourRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutPropertyInput | PropertyTourRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyTourRequestCreateManyPropertyInputEnvelope
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
  }

  export type PropertyContactUserRequestCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutPropertyInput, PropertyContactUserRequestUncheckedCreateWithoutPropertyInput> | PropertyContactUserRequestCreateWithoutPropertyInput[] | PropertyContactUserRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutPropertyInput | PropertyContactUserRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyContactUserRequestCreateManyPropertyInputEnvelope
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BookmarkCreateWithoutPropertyInput, BookmarkUncheckedCreateWithoutPropertyInput> | BookmarkCreateWithoutPropertyInput[] | BookmarkUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPropertyInput | BookmarkCreateOrConnectWithoutPropertyInput[]
    createMany?: BookmarkCreateManyPropertyInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type PropertyViewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
  }

  export type PropertyTourRequestUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyTourRequestCreateWithoutPropertyInput, PropertyTourRequestUncheckedCreateWithoutPropertyInput> | PropertyTourRequestCreateWithoutPropertyInput[] | PropertyTourRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutPropertyInput | PropertyTourRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyTourRequestCreateManyPropertyInputEnvelope
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
  }

  export type PropertyContactUserRequestUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutPropertyInput, PropertyContactUserRequestUncheckedCreateWithoutPropertyInput> | PropertyContactUserRequestCreateWithoutPropertyInput[] | PropertyContactUserRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutPropertyInput | PropertyContactUserRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyContactUserRequestCreateManyPropertyInputEnvelope
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type EnumPropertyCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PropertyCategory
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type PropertyUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus | null
    unset?: boolean
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type PropertyUpdatereportedByInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutPropertyNestedInput = {
    create?: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput
    upsert?: UserUpsertWithoutPropertyInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyInput, UserUpdateWithoutPropertyInput>, UserUncheckedUpdateWithoutPropertyInput>
  }

  export type BookmarkUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BookmarkCreateWithoutPropertyInput, BookmarkUncheckedCreateWithoutPropertyInput> | BookmarkCreateWithoutPropertyInput[] | BookmarkUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPropertyInput | BookmarkCreateOrConnectWithoutPropertyInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutPropertyInput | BookmarkUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BookmarkCreateManyPropertyInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutPropertyInput | BookmarkUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutPropertyInput | BookmarkUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type PropertyViewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyTourRequestUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyTourRequestCreateWithoutPropertyInput, PropertyTourRequestUncheckedCreateWithoutPropertyInput> | PropertyTourRequestCreateWithoutPropertyInput[] | PropertyTourRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutPropertyInput | PropertyTourRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyTourRequestUpsertWithWhereUniqueWithoutPropertyInput | PropertyTourRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyTourRequestCreateManyPropertyInputEnvelope
    set?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    disconnect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    delete?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    update?: PropertyTourRequestUpdateWithWhereUniqueWithoutPropertyInput | PropertyTourRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyTourRequestUpdateManyWithWhereWithoutPropertyInput | PropertyTourRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyTourRequestScalarWhereInput | PropertyTourRequestScalarWhereInput[]
  }

  export type PropertyContactUserRequestUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutPropertyInput, PropertyContactUserRequestUncheckedCreateWithoutPropertyInput> | PropertyContactUserRequestCreateWithoutPropertyInput[] | PropertyContactUserRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutPropertyInput | PropertyContactUserRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyContactUserRequestUpsertWithWhereUniqueWithoutPropertyInput | PropertyContactUserRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyContactUserRequestCreateManyPropertyInputEnvelope
    set?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    disconnect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    delete?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    update?: PropertyContactUserRequestUpdateWithWhereUniqueWithoutPropertyInput | PropertyContactUserRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyContactUserRequestUpdateManyWithWhereWithoutPropertyInput | PropertyContactUserRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyContactUserRequestScalarWhereInput | PropertyContactUserRequestScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BookmarkCreateWithoutPropertyInput, BookmarkUncheckedCreateWithoutPropertyInput> | BookmarkCreateWithoutPropertyInput[] | BookmarkUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutPropertyInput | BookmarkCreateOrConnectWithoutPropertyInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutPropertyInput | BookmarkUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BookmarkCreateManyPropertyInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutPropertyInput | BookmarkUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutPropertyInput | BookmarkUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput> | PropertyViewCreateWithoutPropertyInput[] | PropertyViewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyViewCreateOrConnectWithoutPropertyInput | PropertyViewCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyViewUpsertWithWhereUniqueWithoutPropertyInput | PropertyViewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyViewCreateManyPropertyInputEnvelope
    set?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    disconnect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    delete?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    connect?: PropertyViewWhereUniqueInput | PropertyViewWhereUniqueInput[]
    update?: PropertyViewUpdateWithWhereUniqueWithoutPropertyInput | PropertyViewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyViewUpdateManyWithWhereWithoutPropertyInput | PropertyViewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
  }

  export type PropertyTourRequestUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyTourRequestCreateWithoutPropertyInput, PropertyTourRequestUncheckedCreateWithoutPropertyInput> | PropertyTourRequestCreateWithoutPropertyInput[] | PropertyTourRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyTourRequestCreateOrConnectWithoutPropertyInput | PropertyTourRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyTourRequestUpsertWithWhereUniqueWithoutPropertyInput | PropertyTourRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyTourRequestCreateManyPropertyInputEnvelope
    set?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    disconnect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    delete?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    connect?: PropertyTourRequestWhereUniqueInput | PropertyTourRequestWhereUniqueInput[]
    update?: PropertyTourRequestUpdateWithWhereUniqueWithoutPropertyInput | PropertyTourRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyTourRequestUpdateManyWithWhereWithoutPropertyInput | PropertyTourRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyTourRequestScalarWhereInput | PropertyTourRequestScalarWhereInput[]
  }

  export type PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyContactUserRequestCreateWithoutPropertyInput, PropertyContactUserRequestUncheckedCreateWithoutPropertyInput> | PropertyContactUserRequestCreateWithoutPropertyInput[] | PropertyContactUserRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyContactUserRequestCreateOrConnectWithoutPropertyInput | PropertyContactUserRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyContactUserRequestUpsertWithWhereUniqueWithoutPropertyInput | PropertyContactUserRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyContactUserRequestCreateManyPropertyInputEnvelope
    set?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    disconnect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    delete?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    connect?: PropertyContactUserRequestWhereUniqueInput | PropertyContactUserRequestWhereUniqueInput[]
    update?: PropertyContactUserRequestUpdateWithWhereUniqueWithoutPropertyInput | PropertyContactUserRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyContactUserRequestUpdateManyWithWhereWithoutPropertyInput | PropertyContactUserRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyContactUserRequestScalarWhereInput | PropertyContactUserRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookmarkInput = {
    create?: XOR<UserCreateWithoutBookmarkInput, UserUncheckedCreateWithoutBookmarkInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarkInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutBookmarkInput = {
    create?: XOR<PropertyCreateWithoutBookmarkInput, PropertyUncheckedCreateWithoutBookmarkInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBookmarkInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookmarkNestedInput = {
    create?: XOR<UserCreateWithoutBookmarkInput, UserUncheckedCreateWithoutBookmarkInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarkInput
    upsert?: UserUpsertWithoutBookmarkInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookmarkInput, UserUpdateWithoutBookmarkInput>, UserUncheckedUpdateWithoutBookmarkInput>
  }

  export type PropertyUpdateOneRequiredWithoutBookmarkNestedInput = {
    create?: XOR<PropertyCreateWithoutBookmarkInput, PropertyUncheckedCreateWithoutBookmarkInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBookmarkInput
    upsert?: PropertyUpsertWithoutBookmarkInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutBookmarkInput, PropertyUpdateWithoutBookmarkInput>, PropertyUncheckedUpdateWithoutBookmarkInput>
  }

  export type UserCreateNestedOneWithoutPropertyViewInput = {
    create?: XOR<UserCreateWithoutPropertyViewInput, UserUncheckedCreateWithoutPropertyViewInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyViewInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutPropertyViewInput = {
    create?: XOR<PropertyCreateWithoutPropertyViewInput, PropertyUncheckedCreateWithoutPropertyViewInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyViewInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPropertyViewNestedInput = {
    create?: XOR<UserCreateWithoutPropertyViewInput, UserUncheckedCreateWithoutPropertyViewInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyViewInput
    upsert?: UserUpsertWithoutPropertyViewInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyViewInput, UserUpdateWithoutPropertyViewInput>, UserUncheckedUpdateWithoutPropertyViewInput>
  }

  export type PropertyUpdateOneRequiredWithoutPropertyViewNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyViewInput, PropertyUncheckedCreateWithoutPropertyViewInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyViewInput
    upsert?: PropertyUpsertWithoutPropertyViewInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyViewInput, PropertyUpdateWithoutPropertyViewInput>, PropertyUncheckedUpdateWithoutPropertyViewInput>
  }

  export type UserCreateNestedOneWithoutPropertyTourRequestInput = {
    create?: XOR<UserCreateWithoutPropertyTourRequestInput, UserUncheckedCreateWithoutPropertyTourRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyTourRequestInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutPropertyTourRequestInput = {
    create?: XOR<PropertyCreateWithoutPropertyTourRequestInput, PropertyUncheckedCreateWithoutPropertyTourRequestInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTourRequestInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserUpdateOneWithoutPropertyTourRequestNestedInput = {
    create?: XOR<UserCreateWithoutPropertyTourRequestInput, UserUncheckedCreateWithoutPropertyTourRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyTourRequestInput
    upsert?: UserUpsertWithoutPropertyTourRequestInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyTourRequestInput, UserUpdateWithoutPropertyTourRequestInput>, UserUncheckedUpdateWithoutPropertyTourRequestInput>
  }

  export type PropertyUpdateOneRequiredWithoutPropertyTourRequestNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyTourRequestInput, PropertyUncheckedCreateWithoutPropertyTourRequestInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyTourRequestInput
    upsert?: PropertyUpsertWithoutPropertyTourRequestInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyTourRequestInput, PropertyUpdateWithoutPropertyTourRequestInput>, PropertyUncheckedUpdateWithoutPropertyTourRequestInput>
  }

  export type UserCreateNestedOneWithoutPropertyContactUserRequestInput = {
    create?: XOR<UserCreateWithoutPropertyContactUserRequestInput, UserUncheckedCreateWithoutPropertyContactUserRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyContactUserRequestInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutPropertyContactUserRequestInput = {
    create?: XOR<PropertyCreateWithoutPropertyContactUserRequestInput, PropertyUncheckedCreateWithoutPropertyContactUserRequestInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyContactUserRequestInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserUpdateOneWithoutPropertyContactUserRequestNestedInput = {
    create?: XOR<UserCreateWithoutPropertyContactUserRequestInput, UserUncheckedCreateWithoutPropertyContactUserRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyContactUserRequestInput
    upsert?: UserUpsertWithoutPropertyContactUserRequestInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyContactUserRequestInput, UserUpdateWithoutPropertyContactUserRequestInput>, UserUncheckedUpdateWithoutPropertyContactUserRequestInput>
  }

  export type PropertyUpdateOneRequiredWithoutPropertyContactUserRequestNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyContactUserRequestInput, PropertyUncheckedCreateWithoutPropertyContactUserRequestInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyContactUserRequestInput
    upsert?: PropertyUpsertWithoutPropertyContactUserRequestInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPropertyContactUserRequestInput, PropertyUpdateWithoutPropertyContactUserRequestInput>, PropertyUncheckedUpdateWithoutPropertyContactUserRequestInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryFilter<$PrismaModel> | $Enums.PropertyCategory
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumListingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingStatusNullableFilter<$PrismaModel> | $Enums.ListingStatus | null
    isSet?: boolean
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyType[] | ListEnumPropertyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyCategory | EnumPropertyCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyCategory[] | ListEnumPropertyCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PropertyCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyCategoryFilter<$PrismaModel>
    _max?: NestedEnumPropertyCategoryFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumListingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumListingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumListingStatusNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PropertyStatus[] | ListEnumPropertyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type UserRoleCreateWithoutRolePackageInput = {
    id?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    transactions?: TransactionCreateNestedManyWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateWithoutRolePackageInput = {
    id?: string
    userId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserRoleInput
  }

  export type UserRoleCreateOrConnectWithoutRolePackageInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRolePackageInput, UserRoleUncheckedCreateWithoutRolePackageInput>
  }

  export type UserRoleCreateManyRolePackageInputEnvelope = {
    data: UserRoleCreateManyRolePackageInput | UserRoleCreateManyRolePackageInput[]
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRolePackageInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRolePackageInput, UserRoleUncheckedUpdateWithoutRolePackageInput>
    create: XOR<UserRoleCreateWithoutRolePackageInput, UserRoleUncheckedCreateWithoutRolePackageInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRolePackageInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRolePackageInput, UserRoleUncheckedUpdateWithoutRolePackageInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRolePackageInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRolePackageInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: StringFilter<"UserRole"> | string
    userId?: StringFilter<"UserRole"> | string
    rolePackageId?: StringFilter<"UserRole"> | string
    startDate?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    endDate?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    isActive?: BoolFilter<"UserRole"> | boolean
    isPaused?: BoolFilter<"UserRole"> | boolean
    isExpired?: BoolFilter<"UserRole"> | boolean
    message?: StringNullableFilter<"UserRole"> | string | null
    isVerified?: BoolFilter<"UserRole"> | boolean
    verifiedAt?: DateTimeNullableFilter<"UserRole"> | Date | string | null
    verifiedBy?: StringNullableFilter<"UserRole"> | string | null
    createdAt?: DateTimeFilter<"UserRole"> | Date | string
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type UserRoleCreateWithoutUserInput = {
    id?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    rolePackage: RolePackageCreateNestedOneWithoutUserRolesInput
    transactions?: TransactionCreateNestedManyWithoutUserRoleInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string
    rolePackageId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserRoleInput
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    deviceInfo: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    deviceInfo: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type PropertyCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Bookmark?: BookmarkCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyCreateManyUserInputEnvelope = {
    data: PropertyCreateManyUserInput | PropertyCreateManyUserInput[]
  }

  export type BookmarkCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookmarkInput
  }

  export type BookmarkUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    createdAt?: Date | string
  }

  export type BookmarkCreateOrConnectWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkCreateManyUserInputEnvelope = {
    data: BookmarkCreateManyUserInput | BookmarkCreateManyUserInput[]
  }

  export type PropertyViewCreateWithoutUserInput = {
    id?: string
    viewedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPropertyViewInput
  }

  export type PropertyViewUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    viewedAt?: Date | string
  }

  export type PropertyViewCreateOrConnectWithoutUserInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput>
  }

  export type PropertyViewCreateManyUserInputEnvelope = {
    data: PropertyViewCreateManyUserInput | PropertyViewCreateManyUserInput[]
  }

  export type PropertyTourRequestCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutPropertyTourRequestInput
  }

  export type PropertyTourRequestUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyTourRequestCreateOrConnectWithoutUserInput = {
    where: PropertyTourRequestWhereUniqueInput
    create: XOR<PropertyTourRequestCreateWithoutUserInput, PropertyTourRequestUncheckedCreateWithoutUserInput>
  }

  export type PropertyTourRequestCreateManyUserInputEnvelope = {
    data: PropertyTourRequestCreateManyUserInput | PropertyTourRequestCreateManyUserInput[]
  }

  export type PropertyContactUserRequestCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutPropertyContactUserRequestInput
  }

  export type PropertyContactUserRequestUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyContactUserRequestCreateOrConnectWithoutUserInput = {
    where: PropertyContactUserRequestWhereUniqueInput
    create: XOR<PropertyContactUserRequestCreateWithoutUserInput, PropertyContactUserRequestUncheckedCreateWithoutUserInput>
  }

  export type PropertyContactUserRequestCreateManyUserInputEnvelope = {
    data: PropertyContactUserRequestCreateManyUserInput | PropertyContactUserRequestCreateManyUserInput[]
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
    userRole: UserRoleCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    userRoleId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
  }

  export type ReviewCreateWithoutReviewerInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    targetUser: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    targetUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewCreateManyReviewerInputEnvelope = {
    data: ReviewCreateManyReviewerInput | ReviewCreateManyReviewerInput[]
  }

  export type ReviewCreateWithoutTargetUserInput = {
    id?: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
  }

  export type ReviewUncheckedCreateWithoutTargetUserInput = {
    id?: string
    reviewerId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutTargetUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutTargetUserInput, ReviewUncheckedCreateWithoutTargetUserInput>
  }

  export type ReviewCreateManyTargetUserInputEnvelope = {
    data: ReviewCreateManyTargetUserInput | ReviewCreateManyTargetUserInput[]
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    link?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    deviceInfo?: StringFilter<"Session"> | string
    isActive?: BoolFilter<"Session"> | boolean
    lastUsedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type PropertyUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyCreateWithoutUserInput, PropertyUncheckedCreateWithoutUserInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutUserInput, PropertyUncheckedUpdateWithoutUserInput>
  }

  export type PropertyUpdateManyWithWhereWithoutUserInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    title?: StringFilter<"Property"> | string
    slug?: StringFilter<"Property"> | string
    price?: FloatFilter<"Property"> | number
    address?: StringNullableFilter<"Property"> | string | null
    city?: StringNullableFilter<"Property"> | string | null
    state?: StringNullableFilter<"Property"> | string | null
    zip?: StringNullableFilter<"Property"> | string | null
    latitude?: StringNullableFilter<"Property"> | string | null
    longitude?: StringNullableFilter<"Property"> | string | null
    neighborhood?: StringNullableFilter<"Property"> | string | null
    views?: IntFilter<"Property"> | number
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    property?: EnumPropertyCategoryFilter<"Property"> | $Enums.PropertyCategory
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: IntNullableFilter<"Property"> | number | null
    size?: IntNullableFilter<"Property"> | number | null
    lotSize?: FloatNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    hoaFees?: IntNullableFilter<"Property"> | number | null
    leaseLength?: StringNullableFilter<"Property"> | string | null
    furnished?: BoolNullableFilter<"Property"> | boolean | null
    deposit?: FloatNullableFilter<"Property"> | number | null
    moveInDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    amenities?: StringNullableListFilter<"Property">
    garage?: BoolNullableFilter<"Property"> | boolean | null
    basement?: BoolNullableFilter<"Property"> | boolean | null
    fireplace?: BoolNullableFilter<"Property"> | boolean | null
    pool?: BoolNullableFilter<"Property"> | boolean | null
    pet?: StringNullableFilter<"Property"> | string | null
    utilities?: StringNullableFilter<"Property"> | string | null
    income?: StringNullableFilter<"Property"> | string | null
    school?: StringNullableFilter<"Property"> | string | null
    bus?: StringNullableFilter<"Property"> | string | null
    restaurant?: StringNullableFilter<"Property"> | string | null
    images?: JsonNullableFilter<"Property">
    description?: StringFilter<"Property"> | string
    listingStatus?: EnumListingStatusNullableFilter<"Property"> | $Enums.ListingStatus | null
    listingType?: StringFilter<"Property"> | string
    userId?: StringFilter<"Property"> | string
    userName?: StringNullableFilter<"Property"> | string | null
    userAvatar?: StringNullableFilter<"Property"> | string | null
    userEmail?: StringNullableFilter<"Property"> | string | null
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    flagged?: BoolFilter<"Property"> | boolean
    reportedBy?: StringNullableListFilter<"Property">
    flagReason?: StringNullableFilter<"Property"> | string | null
    flagStatus?: StringNullableFilter<"Property"> | string | null
    flaggedAt?: DateTimeNullableFilter<"Property"> | Date | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
  }

  export type BookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutUserInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutUserInput>
  }

  export type BookmarkScalarWhereInput = {
    AND?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    OR?: BookmarkScalarWhereInput[]
    NOT?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    id?: StringFilter<"Bookmark"> | string
    userId?: StringFilter<"Bookmark"> | string
    propertyId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutUserInput, PropertyViewUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyViewCreateWithoutUserInput, PropertyViewUncheckedCreateWithoutUserInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutUserInput, PropertyViewUncheckedUpdateWithoutUserInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutUserInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyViewScalarWhereInput = {
    AND?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    OR?: PropertyViewScalarWhereInput[]
    NOT?: PropertyViewScalarWhereInput | PropertyViewScalarWhereInput[]
    id?: StringFilter<"PropertyView"> | string
    userId?: StringFilter<"PropertyView"> | string
    propertyId?: StringFilter<"PropertyView"> | string
    viewedAt?: DateTimeFilter<"PropertyView"> | Date | string
  }

  export type PropertyTourRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyTourRequestWhereUniqueInput
    update: XOR<PropertyTourRequestUpdateWithoutUserInput, PropertyTourRequestUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyTourRequestCreateWithoutUserInput, PropertyTourRequestUncheckedCreateWithoutUserInput>
  }

  export type PropertyTourRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyTourRequestWhereUniqueInput
    data: XOR<PropertyTourRequestUpdateWithoutUserInput, PropertyTourRequestUncheckedUpdateWithoutUserInput>
  }

  export type PropertyTourRequestUpdateManyWithWhereWithoutUserInput = {
    where: PropertyTourRequestScalarWhereInput
    data: XOR<PropertyTourRequestUpdateManyMutationInput, PropertyTourRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyTourRequestScalarWhereInput = {
    AND?: PropertyTourRequestScalarWhereInput | PropertyTourRequestScalarWhereInput[]
    OR?: PropertyTourRequestScalarWhereInput[]
    NOT?: PropertyTourRequestScalarWhereInput | PropertyTourRequestScalarWhereInput[]
    id?: StringFilter<"PropertyTourRequest"> | string
    userId?: StringFilter<"PropertyTourRequest"> | string
    propertyId?: StringFilter<"PropertyTourRequest"> | string
    name?: StringFilter<"PropertyTourRequest"> | string
    email?: StringFilter<"PropertyTourRequest"> | string
    phone?: StringFilter<"PropertyTourRequest"> | string
    message?: StringNullableFilter<"PropertyTourRequest"> | string | null
    tourTimes?: JsonFilter<"PropertyTourRequest">
    createdAt?: DateTimeFilter<"PropertyTourRequest"> | Date | string
  }

  export type PropertyContactUserRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: PropertyContactUserRequestWhereUniqueInput
    update: XOR<PropertyContactUserRequestUpdateWithoutUserInput, PropertyContactUserRequestUncheckedUpdateWithoutUserInput>
    create: XOR<PropertyContactUserRequestCreateWithoutUserInput, PropertyContactUserRequestUncheckedCreateWithoutUserInput>
  }

  export type PropertyContactUserRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: PropertyContactUserRequestWhereUniqueInput
    data: XOR<PropertyContactUserRequestUpdateWithoutUserInput, PropertyContactUserRequestUncheckedUpdateWithoutUserInput>
  }

  export type PropertyContactUserRequestUpdateManyWithWhereWithoutUserInput = {
    where: PropertyContactUserRequestScalarWhereInput
    data: XOR<PropertyContactUserRequestUpdateManyMutationInput, PropertyContactUserRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type PropertyContactUserRequestScalarWhereInput = {
    AND?: PropertyContactUserRequestScalarWhereInput | PropertyContactUserRequestScalarWhereInput[]
    OR?: PropertyContactUserRequestScalarWhereInput[]
    NOT?: PropertyContactUserRequestScalarWhereInput | PropertyContactUserRequestScalarWhereInput[]
    id?: StringFilter<"PropertyContactUserRequest"> | string
    name?: StringFilter<"PropertyContactUserRequest"> | string
    phone?: StringFilter<"PropertyContactUserRequest"> | string
    email?: StringFilter<"PropertyContactUserRequest"> | string
    message?: StringFilter<"PropertyContactUserRequest"> | string
    userId?: StringFilter<"PropertyContactUserRequest"> | string
    propertyId?: StringFilter<"PropertyContactUserRequest"> | string
    createdAt?: DateTimeFilter<"PropertyContactUserRequest"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    userRoleId?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    method?: StringNullableFilter<"Transaction"> | string | null
    stripeId?: StringFilter<"Transaction"> | string
    invoiceUrl?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutReviewerInput, ReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutReviewerInput, ReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    targetUserId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringFilter<"Review"> | string
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutTargetUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutTargetUserInput, ReviewUncheckedUpdateWithoutTargetUserInput>
    create: XOR<ReviewCreateWithoutTargetUserInput, ReviewUncheckedCreateWithoutTargetUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutTargetUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutTargetUserInput, ReviewUncheckedUpdateWithoutTargetUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutTargetUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutTargetUserInput>
  }

  export type UserCreateWithoutUserRolesInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutUserRolesInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutUserRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
  }

  export type RolePackageCreateWithoutUserRolesInput = {
    id?: string
    name: string
    roleName: $Enums.RoleName
    price: number
    durationDays: number
    features?: RolePackageCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePackageUncheckedCreateWithoutUserRolesInput = {
    id?: string
    name: string
    roleName: $Enums.RoleName
    price: number
    durationDays: number
    features?: RolePackageCreatefeaturesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RolePackageCreateOrConnectWithoutUserRolesInput = {
    where: RolePackageWhereUniqueInput
    create: XOR<RolePackageCreateWithoutUserRolesInput, RolePackageUncheckedCreateWithoutUserRolesInput>
  }

  export type TransactionCreateWithoutUserRoleInput = {
    id?: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserRoleInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserRoleInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserRoleInput, TransactionUncheckedCreateWithoutUserRoleInput>
  }

  export type TransactionCreateManyUserRoleInputEnvelope = {
    data: TransactionCreateManyUserRoleInput | TransactionCreateManyUserRoleInput[]
  }

  export type UserUpsertWithoutUserRolesInput = {
    update: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
    create: XOR<UserCreateWithoutUserRolesInput, UserUncheckedCreateWithoutUserRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserRolesInput, UserUncheckedUpdateWithoutUserRolesInput>
  }

  export type UserUpdateWithoutUserRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type RolePackageUpsertWithoutUserRolesInput = {
    update: XOR<RolePackageUpdateWithoutUserRolesInput, RolePackageUncheckedUpdateWithoutUserRolesInput>
    create: XOR<RolePackageCreateWithoutUserRolesInput, RolePackageUncheckedCreateWithoutUserRolesInput>
    where?: RolePackageWhereInput
  }

  export type RolePackageUpdateToOneWithWhereWithoutUserRolesInput = {
    where?: RolePackageWhereInput
    data: XOR<RolePackageUpdateWithoutUserRolesInput, RolePackageUncheckedUpdateWithoutUserRolesInput>
  }

  export type RolePackageUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    price?: FloatFieldUpdateOperationsInput | number
    durationDays?: IntFieldUpdateOperationsInput | number
    features?: RolePackageUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePackageUncheckedUpdateWithoutUserRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    roleName?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    price?: FloatFieldUpdateOperationsInput | number
    durationDays?: IntFieldUpdateOperationsInput | number
    features?: RolePackageUpdatefeaturesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserRoleInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserRoleInput, TransactionUncheckedUpdateWithoutUserRoleInput>
    create: XOR<TransactionCreateWithoutUserRoleInput, TransactionUncheckedCreateWithoutUserRoleInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserRoleInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserRoleInput, TransactionUncheckedUpdateWithoutUserRoleInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserRoleInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserRoleInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserRoleCreateWithoutTransactionsInput = {
    id?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserRolesInput
    rolePackage: RolePackageCreateNestedOneWithoutUserRolesInput
  }

  export type UserRoleUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    rolePackageId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateOrConnectWithoutTransactionsInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutTransactionsInput, UserRoleUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type UserRoleUpsertWithoutTransactionsInput = {
    update: XOR<UserRoleUpdateWithoutTransactionsInput, UserRoleUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserRoleCreateWithoutTransactionsInput, UserRoleUncheckedCreateWithoutTransactionsInput>
    where?: UserRoleWhereInput
  }

  export type UserRoleUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserRoleWhereInput
    data: XOR<UserRoleUpdateWithoutTransactionsInput, UserRoleUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserRoleUpdateWithoutTransactionsInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    rolePackage?: RolePackageUpdateOneRequiredWithoutUserRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutTransactionsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    rolePackageId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type UserCreateWithoutReviewsGivenInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutReviewsGivenInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
  }

  export type UserCreateWithoutReviewsReceivedInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
  }

  export type UserUncheckedCreateWithoutReviewsReceivedInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
  }

  export type UserCreateOrConnectWithoutReviewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
  }

  export type UserUpsertWithoutReviewsGivenInput = {
    update: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateWithoutReviewsGivenInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsGivenInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUpsertWithoutReviewsReceivedInput = {
    update: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type UserUpdateWithoutReviewsReceivedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsReceivedInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
  }

  export type UserCreateWithoutPropertyInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutPropertyInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutPropertyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
  }

  export type BookmarkCreateWithoutPropertyInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBookmarkInput
  }

  export type BookmarkUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkCreateOrConnectWithoutPropertyInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutPropertyInput, BookmarkUncheckedCreateWithoutPropertyInput>
  }

  export type BookmarkCreateManyPropertyInputEnvelope = {
    data: BookmarkCreateManyPropertyInput | BookmarkCreateManyPropertyInput[]
  }

  export type PropertyViewCreateWithoutPropertyInput = {
    id?: string
    viewedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyViewInput
  }

  export type PropertyViewUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId: string
    viewedAt?: Date | string
  }

  export type PropertyViewCreateOrConnectWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewCreateManyPropertyInputEnvelope = {
    data: PropertyViewCreateManyPropertyInput | PropertyViewCreateManyPropertyInput[]
  }

  export type PropertyTourRequestCreateWithoutPropertyInput = {
    id?: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPropertyTourRequestInput
  }

  export type PropertyTourRequestUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyTourRequestCreateOrConnectWithoutPropertyInput = {
    where: PropertyTourRequestWhereUniqueInput
    create: XOR<PropertyTourRequestCreateWithoutPropertyInput, PropertyTourRequestUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyTourRequestCreateManyPropertyInputEnvelope = {
    data: PropertyTourRequestCreateManyPropertyInput | PropertyTourRequestCreateManyPropertyInput[]
  }

  export type PropertyContactUserRequestCreateWithoutPropertyInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutPropertyContactUserRequestInput
  }

  export type PropertyContactUserRequestUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    userId: string
    createdAt?: Date | string
  }

  export type PropertyContactUserRequestCreateOrConnectWithoutPropertyInput = {
    where: PropertyContactUserRequestWhereUniqueInput
    create: XOR<PropertyContactUserRequestCreateWithoutPropertyInput, PropertyContactUserRequestUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyContactUserRequestCreateManyPropertyInputEnvelope = {
    data: PropertyContactUserRequestCreateManyPropertyInput | PropertyContactUserRequestCreateManyPropertyInput[]
  }

  export type UserUpsertWithoutPropertyInput = {
    update: XOR<UserUpdateWithoutPropertyInput, UserUncheckedUpdateWithoutPropertyInput>
    create: XOR<UserCreateWithoutPropertyInput, UserUncheckedCreateWithoutPropertyInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyInput, UserUncheckedUpdateWithoutPropertyInput>
  }

  export type UserUpdateWithoutPropertyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type BookmarkUpsertWithWhereUniqueWithoutPropertyInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutPropertyInput, BookmarkUncheckedUpdateWithoutPropertyInput>
    create: XOR<BookmarkCreateWithoutPropertyInput, BookmarkUncheckedCreateWithoutPropertyInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutPropertyInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutPropertyInput, BookmarkUncheckedUpdateWithoutPropertyInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutPropertyInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyViewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    update: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyViewCreateWithoutPropertyInput, PropertyViewUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyViewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyViewWhereUniqueInput
    data: XOR<PropertyViewUpdateWithoutPropertyInput, PropertyViewUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyViewUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyViewScalarWhereInput
    data: XOR<PropertyViewUpdateManyMutationInput, PropertyViewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyTourRequestUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyTourRequestWhereUniqueInput
    update: XOR<PropertyTourRequestUpdateWithoutPropertyInput, PropertyTourRequestUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyTourRequestCreateWithoutPropertyInput, PropertyTourRequestUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyTourRequestUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyTourRequestWhereUniqueInput
    data: XOR<PropertyTourRequestUpdateWithoutPropertyInput, PropertyTourRequestUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyTourRequestUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyTourRequestScalarWhereInput
    data: XOR<PropertyTourRequestUpdateManyMutationInput, PropertyTourRequestUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyContactUserRequestUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyContactUserRequestWhereUniqueInput
    update: XOR<PropertyContactUserRequestUpdateWithoutPropertyInput, PropertyContactUserRequestUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyContactUserRequestCreateWithoutPropertyInput, PropertyContactUserRequestUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyContactUserRequestUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyContactUserRequestWhereUniqueInput
    data: XOR<PropertyContactUserRequestUpdateWithoutPropertyInput, PropertyContactUserRequestUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyContactUserRequestUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyContactUserRequestScalarWhereInput
    data: XOR<PropertyContactUserRequestUpdateManyMutationInput, PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyInput>
  }

  export type UserCreateWithoutBookmarkInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutBookmarkInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutBookmarkInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookmarkInput, UserUncheckedCreateWithoutBookmarkInput>
  }

  export type PropertyCreateWithoutBookmarkInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyInput
    PropertyView?: PropertyViewCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutBookmarkInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutBookmarkInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutBookmarkInput, PropertyUncheckedCreateWithoutBookmarkInput>
  }

  export type UserUpsertWithoutBookmarkInput = {
    update: XOR<UserUpdateWithoutBookmarkInput, UserUncheckedUpdateWithoutBookmarkInput>
    create: XOR<UserCreateWithoutBookmarkInput, UserUncheckedCreateWithoutBookmarkInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookmarkInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookmarkInput, UserUncheckedUpdateWithoutBookmarkInput>
  }

  export type UserUpdateWithoutBookmarkInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookmarkInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type PropertyUpsertWithoutBookmarkInput = {
    update: XOR<PropertyUpdateWithoutBookmarkInput, PropertyUncheckedUpdateWithoutBookmarkInput>
    create: XOR<PropertyCreateWithoutBookmarkInput, PropertyUncheckedCreateWithoutBookmarkInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutBookmarkInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutBookmarkInput, PropertyUncheckedUpdateWithoutBookmarkInput>
  }

  export type PropertyUpdateWithoutBookmarkInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutBookmarkInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserCreateWithoutPropertyViewInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutPropertyViewInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutPropertyViewInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyViewInput, UserUncheckedCreateWithoutPropertyViewInput>
  }

  export type PropertyCreateWithoutPropertyViewInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyInput
    Bookmark?: BookmarkCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyViewInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyViewInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyViewInput, PropertyUncheckedCreateWithoutPropertyViewInput>
  }

  export type UserUpsertWithoutPropertyViewInput = {
    update: XOR<UserUpdateWithoutPropertyViewInput, UserUncheckedUpdateWithoutPropertyViewInput>
    create: XOR<UserCreateWithoutPropertyViewInput, UserUncheckedCreateWithoutPropertyViewInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyViewInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyViewInput, UserUncheckedUpdateWithoutPropertyViewInput>
  }

  export type UserUpdateWithoutPropertyViewInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyViewInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type PropertyUpsertWithoutPropertyViewInput = {
    update: XOR<PropertyUpdateWithoutPropertyViewInput, PropertyUncheckedUpdateWithoutPropertyViewInput>
    create: XOR<PropertyCreateWithoutPropertyViewInput, PropertyUncheckedCreateWithoutPropertyViewInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyViewInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyViewInput, PropertyUncheckedUpdateWithoutPropertyViewInput>
  }

  export type PropertyUpdateWithoutPropertyViewInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Bookmark?: BookmarkUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyViewInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookmark?: BookmarkUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserCreateWithoutPropertyTourRequestInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutPropertyTourRequestInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutPropertyTourRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyTourRequestInput, UserUncheckedCreateWithoutPropertyTourRequestInput>
  }

  export type PropertyCreateWithoutPropertyTourRequestInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyInput
    Bookmark?: BookmarkCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyTourRequestInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyTourRequestInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyTourRequestInput, PropertyUncheckedCreateWithoutPropertyTourRequestInput>
  }

  export type UserUpsertWithoutPropertyTourRequestInput = {
    update: XOR<UserUpdateWithoutPropertyTourRequestInput, UserUncheckedUpdateWithoutPropertyTourRequestInput>
    create: XOR<UserCreateWithoutPropertyTourRequestInput, UserUncheckedCreateWithoutPropertyTourRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyTourRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyTourRequestInput, UserUncheckedUpdateWithoutPropertyTourRequestInput>
  }

  export type UserUpdateWithoutPropertyTourRequestInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyTourRequestInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type PropertyUpsertWithoutPropertyTourRequestInput = {
    update: XOR<PropertyUpdateWithoutPropertyTourRequestInput, PropertyUncheckedUpdateWithoutPropertyTourRequestInput>
    create: XOR<PropertyCreateWithoutPropertyTourRequestInput, PropertyUncheckedCreateWithoutPropertyTourRequestInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyTourRequestInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyTourRequestInput, PropertyUncheckedUpdateWithoutPropertyTourRequestInput>
  }

  export type PropertyUpdateWithoutPropertyTourRequestInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Bookmark?: BookmarkUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyTourRequestInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookmark?: BookmarkUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserCreateWithoutPropertyContactUserRequestInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userRoles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    property?: PropertyCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutTargetUserInput
  }

  export type UserUncheckedCreateWithoutPropertyContactUserRequestInput = {
    id?: string
    username: string
    email: string
    password: string
    avatar?: string | null
    avatarPublicId?: string | null
    phone?: string | null
    bio?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    previousRole?: string | null
    role?: string
    isAdmin?: boolean
    status?: $Enums.Status
    resetCode?: string | null
    resetCodeExpiration?: Date | string | null
    flagged?: boolean | null
    flagReason?: string | null
    isNotificationEnabled?: boolean
    isTwoFactorEnabled?: boolean
    twoFactorTempToken?: string | null
    twoFactorTempExp?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    reputationHistory?: InputJsonValue | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userRoles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    property?: PropertyUncheckedCreateNestedManyWithoutUserInput
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutUserInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutTargetUserInput
  }

  export type UserCreateOrConnectWithoutPropertyContactUserRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyContactUserRequestInput, UserUncheckedCreateWithoutPropertyContactUserRequestInput>
  }

  export type PropertyCreateWithoutPropertyContactUserRequestInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPropertyInput
    Bookmark?: BookmarkCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyContactUserRequestInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userId: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Bookmark?: BookmarkUncheckedCreateNestedManyWithoutPropertyInput
    PropertyView?: PropertyViewUncheckedCreateNestedManyWithoutPropertyInput
    PropertyTourRequest?: PropertyTourRequestUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyContactUserRequestInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyContactUserRequestInput, PropertyUncheckedCreateWithoutPropertyContactUserRequestInput>
  }

  export type UserUpsertWithoutPropertyContactUserRequestInput = {
    update: XOR<UserUpdateWithoutPropertyContactUserRequestInput, UserUncheckedUpdateWithoutPropertyContactUserRequestInput>
    create: XOR<UserCreateWithoutPropertyContactUserRequestInput, UserUncheckedCreateWithoutPropertyContactUserRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyContactUserRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyContactUserRequestInput, UserUncheckedUpdateWithoutPropertyContactUserRequestInput>
  }

  export type UserUpdateWithoutPropertyContactUserRequestInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    property?: PropertyUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutTargetUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyContactUserRequestInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    avatarPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    previousRole?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    resetCode?: NullableStringFieldUpdateOperationsInput | string | null
    resetCodeExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flagged?: NullableBoolFieldUpdateOperationsInput | boolean | null
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    isNotificationEnabled?: BoolFieldUpdateOperationsInput | boolean
    isTwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorTempToken?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorTempExp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    reputationHistory?: InputJsonValue | InputJsonValue | null
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userRoles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    property?: PropertyUncheckedUpdateManyWithoutUserNestedInput
    Bookmark?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutUserNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutTargetUserNestedInput
  }

  export type PropertyUpsertWithoutPropertyContactUserRequestInput = {
    update: XOR<PropertyUpdateWithoutPropertyContactUserRequestInput, PropertyUncheckedUpdateWithoutPropertyContactUserRequestInput>
    create: XOR<PropertyCreateWithoutPropertyContactUserRequestInput, PropertyUncheckedCreateWithoutPropertyContactUserRequestInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPropertyContactUserRequestInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPropertyContactUserRequestInput, PropertyUncheckedUpdateWithoutPropertyContactUserRequestInput>
  }

  export type PropertyUpdateWithoutPropertyContactUserRequestInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyNestedInput
    Bookmark?: BookmarkUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyContactUserRequestInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookmark?: BookmarkUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserRoleCreateManyRolePackageInput = {
    id?: string
    userId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
  }

  export type UserRoleUpdateWithoutRolePackageInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserRolesNestedInput
    transactions?: TransactionUpdateManyWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRolePackageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateManyWithoutRolePackageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: string
    read?: boolean
    link?: string | null
    createdAt?: Date | string
  }

  export type UserRoleCreateManyUserInput = {
    id?: string
    rolePackageId: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    isActive?: boolean
    isPaused?: boolean
    isExpired?: boolean
    message?: string | null
    isVerified?: boolean
    verifiedAt?: Date | string | null
    verifiedBy?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    deviceInfo: string
    isActive?: boolean
    lastUsedAt?: Date | string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyCreateManyUserInput = {
    id?: string
    title: string
    slug: string
    price: number
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    latitude?: string | null
    longitude?: string | null
    neighborhood?: string | null
    views?: number
    type: $Enums.PropertyType
    property: $Enums.PropertyCategory
    bedrooms?: number | null
    bathrooms?: number | null
    size?: number | null
    lotSize?: number | null
    yearBuilt?: number | null
    hoaFees?: number | null
    leaseLength?: string | null
    furnished?: boolean | null
    deposit?: number | null
    moveInDate?: Date | string | null
    amenities?: PropertyCreateamenitiesInput | string[]
    garage?: boolean | null
    basement?: boolean | null
    fireplace?: boolean | null
    pool?: boolean | null
    pet?: string | null
    utilities?: string | null
    income?: string | null
    school?: string | null
    bus?: string | null
    restaurant?: string | null
    images?: InputJsonValue | null
    description: string
    listingStatus?: $Enums.ListingStatus | null
    listingType: string
    userName?: string | null
    userAvatar?: string | null
    userEmail?: string | null
    status?: $Enums.PropertyStatus
    flagged?: boolean
    reportedBy?: PropertyCreatereportedByInput | string[]
    flagReason?: string | null
    flagStatus?: string | null
    flaggedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookmarkCreateManyUserInput = {
    id?: string
    propertyId: string
    createdAt?: Date | string
  }

  export type PropertyViewCreateManyUserInput = {
    id?: string
    propertyId: string
    viewedAt?: Date | string
  }

  export type PropertyTourRequestCreateManyUserInput = {
    id?: string
    propertyId: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyContactUserRequestCreateManyUserInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    propertyId: string
    createdAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    userRoleId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateManyReviewerInput = {
    id?: string
    targetUserId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyTargetUserInput = {
    id?: string
    reviewerId: string
    rating: number
    comment: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleUpdateWithoutUserInput = {
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rolePackage?: RolePackageUpdateOneRequiredWithoutUserRolesNestedInput
    transactions?: TransactionUpdateManyWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    rolePackageId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserRoleNestedInput
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    rolePackageId?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPaused?: BoolFieldUpdateOperationsInput | boolean
    isExpired?: BoolFieldUpdateOperationsInput | boolean
    message?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookmark?: BookmarkUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Bookmark?: BookmarkUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyView?: PropertyViewUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyTourRequest?: PropertyTourRequestUncheckedUpdateManyWithoutPropertyNestedInput
    PropertyContactUserRequest?: PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableStringFieldUpdateOperationsInput | string | null
    longitude?: NullableStringFieldUpdateOperationsInput | string | null
    neighborhood?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    property?: EnumPropertyCategoryFieldUpdateOperationsInput | $Enums.PropertyCategory
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableIntFieldUpdateOperationsInput | number | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    hoaFees?: NullableIntFieldUpdateOperationsInput | number | null
    leaseLength?: NullableStringFieldUpdateOperationsInput | string | null
    furnished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    deposit?: NullableFloatFieldUpdateOperationsInput | number | null
    moveInDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amenities?: PropertyUpdateamenitiesInput | string[]
    garage?: NullableBoolFieldUpdateOperationsInput | boolean | null
    basement?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fireplace?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pool?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pet?: NullableStringFieldUpdateOperationsInput | string | null
    utilities?: NullableStringFieldUpdateOperationsInput | string | null
    income?: NullableStringFieldUpdateOperationsInput | string | null
    school?: NullableStringFieldUpdateOperationsInput | string | null
    bus?: NullableStringFieldUpdateOperationsInput | string | null
    restaurant?: NullableStringFieldUpdateOperationsInput | string | null
    images?: InputJsonValue | InputJsonValue | null
    description?: StringFieldUpdateOperationsInput | string
    listingStatus?: NullableEnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus | null
    listingType?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    userAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    userEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reportedBy?: PropertyUpdatereportedByInput | string[]
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    flagStatus?: NullableStringFieldUpdateOperationsInput | string | null
    flaggedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookmarkNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutUserInput = {
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutUserInput = {
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUpdateWithoutUserInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPropertyViewNestedInput
  }

  export type PropertyViewUncheckedUpdateWithoutUserInput = {
    propertyId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUncheckedUpdateManyWithoutUserInput = {
    propertyId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPropertyTourRequestNestedInput
  }

  export type PropertyTourRequestUncheckedUpdateWithoutUserInput = {
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestUncheckedUpdateManyWithoutUserInput = {
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPropertyContactUserRequestNestedInput
  }

  export type PropertyContactUserRequestUncheckedUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestUncheckedUpdateManyWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userRole?: UserRoleUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    userRoleId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    userRoleId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutReviewerInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetUser?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutReviewerInput = {
    targetUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutReviewerInput = {
    targetUserId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutTargetUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
  }

  export type ReviewUncheckedUpdateWithoutTargetUserInput = {
    reviewerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutTargetUserInput = {
    reviewerId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyUserRoleInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    status: string
    method?: string | null
    stripeId: string
    invoiceUrl?: string | null
    createdAt?: Date | string
  }

  export type TransactionUpdateWithoutUserRoleInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    method?: NullableStringFieldUpdateOperationsInput | string | null
    stripeId?: StringFieldUpdateOperationsInput | string
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateManyPropertyInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type PropertyViewCreateManyPropertyInput = {
    id?: string
    userId: string
    viewedAt?: Date | string
  }

  export type PropertyTourRequestCreateManyPropertyInput = {
    id?: string
    userId: string
    name: string
    email: string
    phone: string
    message?: string | null
    tourTimes: InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyContactUserRequestCreateManyPropertyInput = {
    id?: string
    name: string
    phone: string
    email: string
    message: string
    userId: string
    createdAt?: Date | string
  }

  export type BookmarkUpdateWithoutPropertyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarkNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutPropertyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutPropertyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUpdateWithoutPropertyInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPropertyViewNestedInput
  }

  export type PropertyViewUncheckedUpdateWithoutPropertyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyViewUncheckedUpdateManyWithoutPropertyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestUpdateWithoutPropertyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPropertyTourRequestNestedInput
  }

  export type PropertyTourRequestUncheckedUpdateWithoutPropertyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyTourRequestUncheckedUpdateManyWithoutPropertyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tourTimes?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestUpdateWithoutPropertyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutPropertyContactUserRequestNestedInput
  }

  export type PropertyContactUserRequestUncheckedUpdateWithoutPropertyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyContactUserRequestUncheckedUpdateManyWithoutPropertyInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}